/*
 * ============================ WARNING ============================
 * ==== This is an autogenerated file.                          ====
 * ==== Any changes to this file will be lost when recompiling. ====
 * =================================================================
 *
 * This file contains base classes that correspond to the interfaces defined in
 * your interface file. The objects you publish should inherit from these
 * interfaces.
 *
 */

 #ifndef __INTERFACES_HPP
 #define __INTERFACES_HPP


#pragma GCC push_options
#pragma GCC optimize ("s")



class ODriveIntf {
public:

    class CanIntf {
        public:
            enum Error {
                ERROR_NONE                       = 0x00000000,
                ERROR_DUPLICATE_CAN_IDS          = 0x00000001,
            };
            enum Protocol {
                PROTOCOL_SIMPLE                  = 0,
                PROTOCOL_ENCOS                   = 1,
            };
    };


    class AxisIntf {
    public:
        enum Error {
            ERROR_NONE                       = 0x00000000,
            ERROR_INVALID_STATE              = 0x00000001,
            ERROR_DC_BUS_UNDER_VOLTAGE       = 0x00000002,
            ERROR_DC_BUS_OVER_VOLTAGE        = 0x00000004,
            ERROR_CURRENT_MEASUREMENT_TIMEOUT = 0x00000008,
            ERROR_BRAKE_RESISTOR_DISARMED    = 0x00000010,
            ERROR_MOTOR_DISARMED             = 0x00000020,
            ERROR_MOTOR_FAILED               = 0x00000040,
            ERROR_SENSORLESS_ESTIMATOR_FAILED = 0x00000080,
            ERROR_ENCODER_FAILED             = 0x00000100,
            ERROR_CONTROLLER_FAILED          = 0x00000200,
            ERROR_POS_CTRL_DURING_SENSORLESS = 0x00000400,
            ERROR_WATCHDOG_TIMER_EXPIRED     = 0x00000800,
            ERROR_MIN_ENDSTOP_PRESSED        = 0x00001000,
            ERROR_MAX_ENDSTOP_PRESSED        = 0x00002000,
            ERROR_ESTOP_REQUESTED            = 0x00004000,
            ERROR_HOMING_WITHOUT_ENDSTOP     = 0x00020000,
            ERROR_OVER_TEMP                  = 0x00040000,
        };
        enum LockinState {
            LOCKIN_STATE_INACTIVE            = 0,
            LOCKIN_STATE_RAMP                = 1,
            LOCKIN_STATE_ACCELERATE          = 2,
            LOCKIN_STATE_CONST_VEL           = 3,
        };
        enum AxisState {
            AXIS_STATE_UNDEFINED             = 0,
            AXIS_STATE_IDLE                  = 1,
            AXIS_STATE_STARTUP_SEQUENCE      = 2,
            AXIS_STATE_FULL_CALIBRATION_SEQUENCE = 3,
            AXIS_STATE_MOTOR_CALIBRATION     = 4,
            AXIS_STATE_SENSORLESS_CONTROL    = 5,
            AXIS_STATE_ENCODER_INDEX_SEARCH  = 6,
            AXIS_STATE_ENCODER_OFFSET_CALIBRATION = 7,
            AXIS_STATE_CLOSED_LOOP_CONTROL   = 8,
            AXIS_STATE_LOCKIN_SPIN           = 9,
            AXIS_STATE_ENCODER_DIR_FIND      = 10,
            AXIS_STATE_HOMING                = 11,
        };
    };

    class MotorIntf{
        public:
    // Add error enum at the beginning of the class
            enum Error {
                ERROR_NONE                       = 0x00000000,
                ERROR_PHASE_RESISTANCE_OUT_OF_RANGE = 0x00000001,
                ERROR_PHASE_INDUCTANCE_OUT_OF_RANGE = 0x00000002,
                ERROR_ADC_FAILED                 = 0x00000004,
                ERROR_DRV_FAULT                  = 0x00000008,
                ERROR_CONTROL_DEADLINE_MISSED    = 0x00000010,
                ERROR_NOT_IMPLEMENTED_MOTOR_TYPE = 0x00000020,
                ERROR_BRAKE_CURRENT_OUT_OF_RANGE = 0x00000040,
                ERROR_MODULATION_MAGNITUDE       = 0x00000080,
                ERROR_BRAKE_DEADTIME_VIOLATION   = 0x00000100,
                ERROR_UNEXPECTED_TIMER_CALLBACK  = 0x00000200,
                ERROR_CURRENT_SENSE_SATURATION   = 0x00000400,
                ERROR_CURRENT_LIMIT_VIOLATION    = 0x00001000,
                ERROR_BRAKE_DUTY_CYCLE_NAN       = 0x00002000,
                ERROR_DC_BUS_OVER_REGEN_CURRENT  = 0x00004000,
                ERROR_DC_BUS_OVER_CURRENT        = 0x00008000,
                ERROR_BRAKE_RESISTOR_DISARMED    = 0x00010000,
                ERROR_UNKNOWN_CURRENT_MEASUREMENT = 0x00020000,
                ERROR_UNKNOWN_VBUS_VOLTAGE       = 0x00040000,
                ERROR_UNKNOWN_GAINS              = 0x00080000,
                ERROR_UNKNOWN_PHASE_ESTIMATE     = 0x00100000,
                ERROR_UNKNOWN_CURRENT_COMMAND    = 0x00200000,
                ERROR_UNKNOWN_TORQUE             = 0x00400000,
                ERROR_UNKNOWN_PHASE_VEL          = 0x00800000,
                ERROR_BAD_TIMING                 = 0x01000000,
                ERROR_CONTROLLER_FAILED          = 0x02000000,
                ERROR_CONTROLLER_INITIALIZING    = 0x04000000,
                ERROR_I_BUS_OUT_OF_RANGE         = 0x08000000,
                ERROR_UNBALANCED_PHASES          = 0x10000000,
                ERROR_MODULATION_IS_NAN          = 0x20000000,
            };
            enum ArmedState {
                ARMED_STATE_DISARMED             = 0,
                ARMED_STATE_WAITING_FOR_TIMINGS  = 1,
                ARMED_STATE_WAITING_FOR_UPDATE   = 2,
                ARMED_STATE_ARMED                = 3,
            };
            enum MotorType {
                MOTOR_TYPE_HIGH_CURRENT          = 0,
                MOTOR_TYPE_LOW_CURRENT           = 1,
                MOTOR_TYPE_GIMBAL                = 2,
                MOTOR_TYPE_ACIM                  = 3,
            };
            enum TimingLog_t {
                TIMING_LOG_GENERAL,
                TIMING_LOG_ADC_CB_I,
                TIMING_LOG_ADC_CB_DC,
                TIMING_LOG_MEAS_R,
                TIMING_LOG_MEAS_L,
                TIMING_LOG_ENC_CALIB,
                TIMING_LOG_IDX_SEARCH,
                TIMING_LOG_FOC_VOLTAGE,
                TIMING_LOG_FOC_CURRENT,
                TIMING_LOG_SPI_START,
                TIMING_LOG_SAMPLE_NOW,
                TIMING_LOG_SPI_END,
                TIMING_LOG_NUM_SLOTS
            };

    };

    class ControllerIntf {
        public:
            enum Error {
                ERROR_NONE                       = 0x00000000,
                ERROR_OVERSPEED                  = 0x00000001,
                ERROR_INVALID_INPUT_MODE         = 0x00000002,
                ERROR_UNSTABLE_GAIN              = 0x00000004,
                ERROR_INVALID_MIRROR_AXIS        = 0x00000008,
                ERROR_INVALID_LOAD_ENCODER       = 0x00000010,
                ERROR_INVALID_ESTIMATE           = 0x00000020,
            };
            enum ControlMode {
                CONTROL_MODE_VOLTAGE_CONTROL     = 0,
                CONTROL_MODE_TORQUE_CONTROL      = 1,
                CONTROL_MODE_VELOCITY_CONTROL    = 2,
                CONTROL_MODE_POSITION_CONTROL    = 3,
                CONTROL_MODE_PVT_CONTROL         = 4,
            };
            enum InputMode {
                INPUT_MODE_INACTIVE              = 0,
                INPUT_MODE_PASSTHROUGH           = 1,
                INPUT_MODE_VEL_RAMP              = 2,
                INPUT_MODE_POS_FILTER            = 3,
                INPUT_MODE_MIX_CHANNELS          = 4,
                INPUT_MODE_TRAP_TRAJ             = 5,
                INPUT_MODE_TORQUE_RAMP           = 6,
                INPUT_MODE_MIRROR                = 7,
            };

    };


    class EncoderIntf {
        public:
            enum Error {
                ERROR_NONE                       = 0x00000000,
                ERROR_UNSTABLE_GAIN              = 0x00000001,
                ERROR_CPR_POLEPAIRS_MISMATCH     = 0x00000002,
                ERROR_NO_RESPONSE                = 0x00000004,
                ERROR_UNSUPPORTED_ENCODER_MODE   = 0x00000008,
                ERROR_ILLEGAL_HALL_STATE         = 0x00000010,
                ERROR_INDEX_NOT_FOUND_YET        = 0x00000020,
                ERROR_ABS_SPI_TIMEOUT            = 0x00000040,
                ERROR_ABS_SPI_COM_FAIL           = 0x00000080,
                ERROR_ABS_SPI_NOT_READY          = 0x00000100,
            };
            enum Mode {
                MODE_INCREMENTAL                 = 0,
                MODE_HALL                        = 1,
                MODE_SINCOS                      = 2,
                MODE_SPI_ABS_CUI                 = 256,
                MODE_SPI_ABS_AMS                 = 257,
                MODE_SPI_ABS_AEAT                = 258,
                MODE_SPI_ABS_RLS                 = 259,
                MODE_UART_ABS_KING               = 512,
            };
    };


    class ThermistorCurrentLimiterIntf {
        public:
            enum Error {
                ERROR_NONE                       = 0x00000000,
                ERROR_OVER_TEMP                  = 0x00000001,
            };
        };

    class OnboardThermistorCurrentLimiterIntf {
        public:
    };

    class OffboardThermistorCurrentLimiterIntf {
        public:
    };
    enum TimingLog_t {
        TIMING_LOG_GENERAL,
        TIMING_LOG_ADC_CB_I,
        TIMING_LOG_ADC_CB_DC,
        TIMING_LOG_MEAS_R,
        TIMING_LOG_MEAS_L,
        TIMING_LOG_ENC_CALIB,
        TIMING_LOG_IDX_SEARCH,
        TIMING_LOG_FOC_VOLTAGE,
        TIMING_LOG_FOC_CURRENT,
        TIMING_LOG_SPI_START,
        TIMING_LOG_SAMPLE_NOW,
        TIMING_LOG_SPI_END,
        TIMING_LOG_NUM_SLOTS
    };

};

#pragma GCC pop_options

#endif // __INTERFACES_HPP