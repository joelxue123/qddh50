ARM GAS  /tmp/cccnQOYj.s 			page 1


   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 2
  13              		.file	"mc_tasks_foc.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.FOC_Clear,"ax",%progbits
  18              		.align	1
  19              		.weak	FOC_Clear
  20              		.arch armv7e-m
  21              		.syntax unified
  22              		.thumb
  23              		.thumb_func
  24              		.fpu fpv4-sp-d16
  26              	FOC_Clear:
  27              	.LVL0:
  28              	.LFB1870:
  29              		.file 1 "Src/mc_tasks_foc.c"
   1:Src/mc_tasks_foc.c **** 
   2:Src/mc_tasks_foc.c **** /**
   3:Src/mc_tasks_foc.c ****   ******************************************************************************
   4:Src/mc_tasks_foc.c ****   * @file    mc_tasks_foc.c
   5:Src/mc_tasks_foc.c ****   * @author  Motor Control SDK Team, ST Microelectronics
   6:Src/mc_tasks_foc.c ****   * @brief   This file implements tasks definition
   7:Src/mc_tasks_foc.c ****   *
   8:Src/mc_tasks_foc.c ****   ******************************************************************************
   9:Src/mc_tasks_foc.c ****   * @attention
  10:Src/mc_tasks_foc.c ****   *
  11:Src/mc_tasks_foc.c ****   * <h2><center>&copy; Copyright (c) 2024 STMicroelectronics.
  12:Src/mc_tasks_foc.c ****   * All rights reserved.</center></h2>
  13:Src/mc_tasks_foc.c ****   *
  14:Src/mc_tasks_foc.c ****   * This software component is licensed by ST under Ultimate Liberty license
  15:Src/mc_tasks_foc.c ****   * SLA0044, the "License"; You may not use this file except in compliance with
  16:Src/mc_tasks_foc.c ****   * the License. You may obtain a copy of the License at:
  17:Src/mc_tasks_foc.c ****   *                             www.st.com/SLA0044
  18:Src/mc_tasks_foc.c ****   *
  19:Src/mc_tasks_foc.c ****   ******************************************************************************
  20:Src/mc_tasks_foc.c ****   */
  21:Src/mc_tasks_foc.c **** 
  22:Src/mc_tasks_foc.c **** /* Includes ------------------------------------------------------------------*/
  23:Src/mc_tasks_foc.c **** //cstat -MISRAC2012-Rule-21.1
  24:Src/mc_tasks_foc.c **** #include "main.h"
  25:Src/mc_tasks_foc.c **** //cstat +MISRAC2012-Rule-21.1
  26:Src/mc_tasks_foc.c **** #include "mc_type.h"
  27:Src/mc_tasks_foc.c **** #include "mc_math.h"
  28:Src/mc_tasks_foc.c **** #include "motorcontrol.h"
  29:Src/mc_tasks_foc.c **** #include "regular_conversion_manager.h"
ARM GAS  /tmp/cccnQOYj.s 			page 2


  30:Src/mc_tasks_foc.c **** #include "mc_interface.h"
  31:Src/mc_tasks_foc.c **** #include "digital_output.h"
  32:Src/mc_tasks_foc.c **** #include "pwm_common.h"
  33:Src/mc_tasks_foc.c **** #include "mc_tasks.h"
  34:Src/mc_tasks_foc.c **** #include "parameters_conversion.h"
  35:Src/mc_tasks_foc.c **** #include "mcp_config.h"
  36:Src/mc_tasks_foc.c **** #include "mc_app_hooks.h"
  37:Src/mc_tasks_foc.c **** 
  38:Src/mc_tasks_foc.c **** /* USER CODE BEGIN Includes */
  39:Src/mc_tasks_foc.c **** 
  40:Src/mc_tasks_foc.c **** /* USER CODE END Includes */
  41:Src/mc_tasks_foc.c **** 
  42:Src/mc_tasks_foc.c **** /* USER CODE BEGIN Private define */
  43:Src/mc_tasks_foc.c **** /* Private define ------------------------------------------------------------*/
  44:Src/mc_tasks_foc.c **** 
  45:Src/mc_tasks_foc.c **** /* USER CODE END Private define */
  46:Src/mc_tasks_foc.c **** 
  47:Src/mc_tasks_foc.c **** /* Private variables----------------------------------------------------------*/
  48:Src/mc_tasks_foc.c **** 
  49:Src/mc_tasks_foc.c **** static volatile uint16_t hBootCapDelayCounterM1 = ((uint16_t)0);
  50:Src/mc_tasks_foc.c **** static volatile uint16_t hStopPermanencyCounterM1 = ((uint16_t)0);
  51:Src/mc_tasks_foc.c **** 
  52:Src/mc_tasks_foc.c **** #define M1_CHARGE_BOOT_CAP_TICKS          (((uint16_t)SYS_TICK_FREQUENCY * (uint16_t)10) / 1000U)
  53:Src/mc_tasks_foc.c **** #define M1_CHARGE_BOOT_CAP_DUTY_CYCLES ((uint32_t)0.000\
  54:Src/mc_tasks_foc.c ****                                       * ((uint32_t)PWM_PERIOD_CYCLES / 2U))
  55:Src/mc_tasks_foc.c **** #define M2_CHARGE_BOOT_CAP_TICKS         (((uint16_t)SYS_TICK_FREQUENCY * (uint16_t)10) / 1000U)
  56:Src/mc_tasks_foc.c **** #define M2_CHARGE_BOOT_CAP_DUTY_CYCLES ((uint32_t)0\
  57:Src/mc_tasks_foc.c ****                                       * ((uint32_t)PWM_PERIOD_CYCLES2 / 2U))
  58:Src/mc_tasks_foc.c **** 
  59:Src/mc_tasks_foc.c **** /* USER CODE BEGIN Private Variables */
  60:Src/mc_tasks_foc.c **** 
  61:Src/mc_tasks_foc.c **** /* USER CODE END Private Variables */
  62:Src/mc_tasks_foc.c **** 
  63:Src/mc_tasks_foc.c **** /* Private functions ---------------------------------------------------------*/
  64:Src/mc_tasks_foc.c **** void TSK_MediumFrequencyTaskM1(void);
  65:Src/mc_tasks_foc.c **** void FOC_InitAdditionalMethods(uint8_t bMotor);
  66:Src/mc_tasks_foc.c **** void FOC_CalcCurrRef(uint8_t bMotor);
  67:Src/mc_tasks_foc.c **** void TSK_MF_StopProcessing(uint8_t motor);
  68:Src/mc_tasks_foc.c **** 
  69:Src/mc_tasks_foc.c **** MCI_Handle_t *GetMCI(uint8_t bMotor);
  70:Src/mc_tasks_foc.c **** bool SCC_DetectBemf( SCC_Handle_t * pHandle );
  71:Src/mc_tasks_foc.c **** 
  72:Src/mc_tasks_foc.c **** void TSK_SafetyTask_PWMOFF(uint8_t motor);
  73:Src/mc_tasks_foc.c **** 
  74:Src/mc_tasks_foc.c **** /* USER CODE BEGIN Private Functions */
  75:Src/mc_tasks_foc.c **** 
  76:Src/mc_tasks_foc.c **** /* USER CODE END Private Functions */
  77:Src/mc_tasks_foc.c **** /**
  78:Src/mc_tasks_foc.c ****   * @brief  It initializes the whole MC core according to user defined
  79:Src/mc_tasks_foc.c ****   *         parameters.
  80:Src/mc_tasks_foc.c ****   */
  81:Src/mc_tasks_foc.c **** __weak void FOC_Init(void)
  82:Src/mc_tasks_foc.c **** {
  83:Src/mc_tasks_foc.c **** 
  84:Src/mc_tasks_foc.c ****   /* USER CODE BEGIN MCboot 0 */
  85:Src/mc_tasks_foc.c **** 
  86:Src/mc_tasks_foc.c ****   /* USER CODE END MCboot 0 */
ARM GAS  /tmp/cccnQOYj.s 			page 3


  87:Src/mc_tasks_foc.c **** 
  88:Src/mc_tasks_foc.c ****     /**********************************************************/
  89:Src/mc_tasks_foc.c ****     /*    PWM and current sensing component initialization    */
  90:Src/mc_tasks_foc.c ****     /**********************************************************/
  91:Src/mc_tasks_foc.c ****     pwmcHandle[M1] = &PWM_Handle_M1._Super;
  92:Src/mc_tasks_foc.c ****     R3_2_Init(&PWM_Handle_M1);
  93:Src/mc_tasks_foc.c **** 
  94:Src/mc_tasks_foc.c ****     /* USER CODE BEGIN MCboot 1 */
  95:Src/mc_tasks_foc.c **** 
  96:Src/mc_tasks_foc.c ****     /* USER CODE END MCboot 1 */
  97:Src/mc_tasks_foc.c **** 
  98:Src/mc_tasks_foc.c ****     /**************************************/
  99:Src/mc_tasks_foc.c ****     /*    Start timers synchronously      */
 100:Src/mc_tasks_foc.c ****     /**************************************/
 101:Src/mc_tasks_foc.c ****     startTimers();
 102:Src/mc_tasks_foc.c **** 
 103:Src/mc_tasks_foc.c ****     /******************************************************/
 104:Src/mc_tasks_foc.c ****     /*   PID component initialization: speed regulation   */
 105:Src/mc_tasks_foc.c ****     /******************************************************/
 106:Src/mc_tasks_foc.c ****     PID_HandleInit(&PIDSpeedHandle_M1);
 107:Src/mc_tasks_foc.c **** 
 108:Src/mc_tasks_foc.c ****     /******************************************************/
 109:Src/mc_tasks_foc.c ****     /*   Main speed sensor component initialization       */
 110:Src/mc_tasks_foc.c ****     /******************************************************/
 111:Src/mc_tasks_foc.c ****     STO_PLL_Init (&STO_PLL_M1);
 112:Src/mc_tasks_foc.c **** 
 113:Src/mc_tasks_foc.c ****     /******************************************************/
 114:Src/mc_tasks_foc.c ****     /*   Speed & torque component initialization          */
 115:Src/mc_tasks_foc.c ****     /******************************************************/
 116:Src/mc_tasks_foc.c ****     STC_Init(pSTC[M1],&PIDSpeedHandle_M1, &STO_PLL_M1._Super);
 117:Src/mc_tasks_foc.c **** 
 118:Src/mc_tasks_foc.c ****     /**************************************/
 119:Src/mc_tasks_foc.c ****     /*   Rev-up component initialization  */
 120:Src/mc_tasks_foc.c ****     /**************************************/
 121:Src/mc_tasks_foc.c ****     RUC_Init(&RevUpControlM1, pSTC[M1], &VirtualSpeedSensorM1, &STO_M1, pwmcHandle[M1]);
 122:Src/mc_tasks_foc.c **** 
 123:Src/mc_tasks_foc.c ****     /********************************************************/
 124:Src/mc_tasks_foc.c ****     /*   PID component initialization: current regulation   */
 125:Src/mc_tasks_foc.c ****     /********************************************************/
 126:Src/mc_tasks_foc.c ****     PID_HandleInit(&PIDIqHandle_M1);
 127:Src/mc_tasks_foc.c ****     PID_HandleInit(&PIDIdHandle_M1);
 128:Src/mc_tasks_foc.c **** 
 129:Src/mc_tasks_foc.c ****     /*************************************************/
 130:Src/mc_tasks_foc.c ****     /*   Power measurement component initialization  */
 131:Src/mc_tasks_foc.c ****     /*************************************************/
 132:Src/mc_tasks_foc.c ****     pMPM[M1]->pVBS = &(BusVoltageSensor_M1._Super);
 133:Src/mc_tasks_foc.c ****     pMPM[M1]->pFOCVars = &FOCVars[M1];
 134:Src/mc_tasks_foc.c **** 
 135:Src/mc_tasks_foc.c ****     /*******************************************************/
 136:Src/mc_tasks_foc.c ****     /*   Feed forward component initialization             */
 137:Src/mc_tasks_foc.c ****     /*******************************************************/
 138:Src/mc_tasks_foc.c ****     FF_Init(pFF[M1],&(BusVoltageSensor_M1._Super),pPIDId[M1],pPIDIq[M1]);
 139:Src/mc_tasks_foc.c **** 
 140:Src/mc_tasks_foc.c ****     pREMNG[M1] = &RampExtMngrHFParamsM1;
 141:Src/mc_tasks_foc.c ****     REMNG_Init(pREMNG[M1]);
 142:Src/mc_tasks_foc.c **** 
 143:Src/mc_tasks_foc.c ****     SCC.pPWMC = pwmcHandle[M1];
ARM GAS  /tmp/cccnQOYj.s 			page 4


 144:Src/mc_tasks_foc.c ****     SCC.pVBS = &BusVoltageSensor_M1;
 145:Src/mc_tasks_foc.c ****     SCC.pFOCVars = &FOCVars[M1];
 146:Src/mc_tasks_foc.c ****     SCC.pMCI = &Mci[M1];
 147:Src/mc_tasks_foc.c ****     SCC.pVSS = &VirtualSpeedSensorM1;
 148:Src/mc_tasks_foc.c ****     SCC.pCLM = &CircleLimitationM1;
 149:Src/mc_tasks_foc.c ****     SCC.pPIDIq = pPIDIq[M1];
 150:Src/mc_tasks_foc.c ****     SCC.pPIDId = pPIDId[M1];
 151:Src/mc_tasks_foc.c ****     SCC.pRevupCtrl = &RevUpControlM1;
 152:Src/mc_tasks_foc.c ****     SCC.pSTO = &STO_PLL_M1;
 153:Src/mc_tasks_foc.c ****     SCC.pSTC = &SpeednTorqCtrlM1;
 154:Src/mc_tasks_foc.c ****     SCC.pOTT = &OTT;
 155:Src/mc_tasks_foc.c ****     SCC.pHT = MC_NULL;
 156:Src/mc_tasks_foc.c ****     SCC_Init(&SCC);
 157:Src/mc_tasks_foc.c **** 
 158:Src/mc_tasks_foc.c ****     OTT.pSpeedSensor = &STO_PLL_M1._Super;
 159:Src/mc_tasks_foc.c ****     OTT.pFOCVars = &FOCVars[M1];
 160:Src/mc_tasks_foc.c ****     OTT.pPIDSpeed = &PIDSpeedHandle_M1;
 161:Src/mc_tasks_foc.c ****     OTT.pSTC = &SpeednTorqCtrlM1;
 162:Src/mc_tasks_foc.c ****     OTT_Init(&OTT);
 163:Src/mc_tasks_foc.c **** 
 164:Src/mc_tasks_foc.c ****     FOC_Clear(M1);
 165:Src/mc_tasks_foc.c ****     FOCVars[M1].bDriveInput = EXTERNAL;
 166:Src/mc_tasks_foc.c ****     FOCVars[M1].Iqdref = STC_GetDefaultIqdref(pSTC[M1]);
 167:Src/mc_tasks_foc.c ****     FOCVars[M1].UserIdref = STC_GetDefaultIqdref(pSTC[M1]).d;
 168:Src/mc_tasks_foc.c **** 
 169:Src/mc_tasks_foc.c ****     MCI_ExecTorqueRamp(&Mci[M1], STC_GetDefaultIqdref(pSTC[M1]).q, 0);
 170:Src/mc_tasks_foc.c **** 
 171:Src/mc_tasks_foc.c ****     /* USER CODE BEGIN MCboot 2 */
 172:Src/mc_tasks_foc.c **** 
 173:Src/mc_tasks_foc.c ****     /* USER CODE END MCboot 2 */
 174:Src/mc_tasks_foc.c **** }
 175:Src/mc_tasks_foc.c **** 
 176:Src/mc_tasks_foc.c **** /**
 177:Src/mc_tasks_foc.c ****  * @brief Performs stop process and update the state machine.This function
 178:Src/mc_tasks_foc.c ****  *        shall be called only during medium frequency task.
 179:Src/mc_tasks_foc.c ****  */
 180:Src/mc_tasks_foc.c **** void TSK_MF_StopProcessing(uint8_t motor)
 181:Src/mc_tasks_foc.c **** {
 182:Src/mc_tasks_foc.c ****     R3_2_SwitchOffPWM(pwmcHandle[motor]);
 183:Src/mc_tasks_foc.c **** 
 184:Src/mc_tasks_foc.c ****   SCC_Stop(&SCC);
 185:Src/mc_tasks_foc.c ****   OTT_Stop(&OTT);
 186:Src/mc_tasks_foc.c ****   FOC_Clear(motor);
 187:Src/mc_tasks_foc.c **** 
 188:Src/mc_tasks_foc.c ****   TSK_SetStopPermanencyTimeM1(STOPPERMANENCY_TICKS);
 189:Src/mc_tasks_foc.c ****   Mci[motor].State = STOP;
 190:Src/mc_tasks_foc.c **** }
 191:Src/mc_tasks_foc.c **** 
 192:Src/mc_tasks_foc.c **** /**
 193:Src/mc_tasks_foc.c ****   * @brief Executes medium frequency periodic Motor Control tasks
 194:Src/mc_tasks_foc.c ****   *
 195:Src/mc_tasks_foc.c ****   * This function performs some of the control duties on Motor 1 according to the
 196:Src/mc_tasks_foc.c ****   * present state of its state machine. In particular, duties requiring a periodic
 197:Src/mc_tasks_foc.c ****   * execution at a medium frequency rate (such as the speed controller for instance)
 198:Src/mc_tasks_foc.c ****   * are executed here.
 199:Src/mc_tasks_foc.c ****   */
 200:Src/mc_tasks_foc.c **** __weak void TSK_MediumFrequencyTaskM1(void)
ARM GAS  /tmp/cccnQOYj.s 			page 5


 201:Src/mc_tasks_foc.c **** {
 202:Src/mc_tasks_foc.c ****   /* USER CODE BEGIN MediumFrequencyTask M1 0 */
 203:Src/mc_tasks_foc.c **** 
 204:Src/mc_tasks_foc.c ****   /* USER CODE END MediumFrequencyTask M1 0 */
 205:Src/mc_tasks_foc.c **** 
 206:Src/mc_tasks_foc.c ****   int16_t wAux = 0;
 207:Src/mc_tasks_foc.c ****   bool IsSpeedReliable = STO_PLL_CalcAvrgMecSpeedUnit(&STO_PLL_M1, &wAux);
 208:Src/mc_tasks_foc.c ****   PQD_CalcElMotorPower(pMPM[M1]);
 209:Src/mc_tasks_foc.c **** 
 210:Src/mc_tasks_foc.c ****   if (MCI_GetCurrentFaults(&Mci[M1]) == MC_NO_FAULTS)
 211:Src/mc_tasks_foc.c ****   {
 212:Src/mc_tasks_foc.c ****     if (MCI_GetOccurredFaults(&Mci[M1]) == MC_NO_FAULTS)
 213:Src/mc_tasks_foc.c ****     {
 214:Src/mc_tasks_foc.c ****       switch (Mci[M1].State)
 215:Src/mc_tasks_foc.c ****       {
 216:Src/mc_tasks_foc.c **** 
 217:Src/mc_tasks_foc.c ****         case IDLE:
 218:Src/mc_tasks_foc.c ****         {
 219:Src/mc_tasks_foc.c ****           if ((MCI_START == Mci[M1].DirectCommand) || (MCI_MEASURE_OFFSETS == Mci[M1].DirectCommand
 220:Src/mc_tasks_foc.c ****           {
 221:Src/mc_tasks_foc.c ****               RUC_Clear(&RevUpControlM1, MCI_GetImposedMotorDirection(&Mci[M1]));
 222:Src/mc_tasks_foc.c ****             if (pwmcHandle[M1]->offsetCalibStatus == false)
 223:Src/mc_tasks_foc.c ****             {
 224:Src/mc_tasks_foc.c ****               (void)PWMC_CurrentReadingCalibr(pwmcHandle[M1], CRC_START);
 225:Src/mc_tasks_foc.c ****               Mci[M1].State = OFFSET_CALIB;
 226:Src/mc_tasks_foc.c ****             }
 227:Src/mc_tasks_foc.c ****             else
 228:Src/mc_tasks_foc.c ****             {
 229:Src/mc_tasks_foc.c ****               /* Calibration already done. Enables only TIM channels */
 230:Src/mc_tasks_foc.c ****               pwmcHandle[M1]->OffCalibrWaitTimeCounter = 1u;
 231:Src/mc_tasks_foc.c ****               (void)PWMC_CurrentReadingCalibr(pwmcHandle[M1], CRC_EXEC);
 232:Src/mc_tasks_foc.c ****               R3_2_TurnOnLowSides(pwmcHandle[M1],M1_CHARGE_BOOT_CAP_DUTY_CYCLES);
 233:Src/mc_tasks_foc.c ****               TSK_SetChargeBootCapDelayM1(M1_CHARGE_BOOT_CAP_TICKS);
 234:Src/mc_tasks_foc.c ****               Mci[M1].State = CHARGE_BOOT_CAP;
 235:Src/mc_tasks_foc.c ****             }
 236:Src/mc_tasks_foc.c ****             OTT_Clear(&OTT);
 237:Src/mc_tasks_foc.c ****           }
 238:Src/mc_tasks_foc.c ****           else
 239:Src/mc_tasks_foc.c ****           {
 240:Src/mc_tasks_foc.c ****             /* Nothing to be done, FW stays in IDLE state */
 241:Src/mc_tasks_foc.c ****           }
 242:Src/mc_tasks_foc.c ****           break;
 243:Src/mc_tasks_foc.c ****         }
 244:Src/mc_tasks_foc.c **** 
 245:Src/mc_tasks_foc.c ****         case OFFSET_CALIB:
 246:Src/mc_tasks_foc.c ****         {
 247:Src/mc_tasks_foc.c ****           if (MCI_STOP == Mci[M1].DirectCommand)
 248:Src/mc_tasks_foc.c ****           {
 249:Src/mc_tasks_foc.c ****             TSK_MF_StopProcessing(M1);
 250:Src/mc_tasks_foc.c ****           }
 251:Src/mc_tasks_foc.c ****           else
 252:Src/mc_tasks_foc.c ****           {
 253:Src/mc_tasks_foc.c ****             if (PWMC_CurrentReadingCalibr(pwmcHandle[M1], CRC_EXEC))
 254:Src/mc_tasks_foc.c ****             {
 255:Src/mc_tasks_foc.c ****               if (MCI_MEASURE_OFFSETS == Mci[M1].DirectCommand)
 256:Src/mc_tasks_foc.c ****               {
 257:Src/mc_tasks_foc.c ****                 FOC_Clear(M1);
ARM GAS  /tmp/cccnQOYj.s 			page 6


 258:Src/mc_tasks_foc.c ****                 Mci[M1].DirectCommand = MCI_NO_COMMAND;
 259:Src/mc_tasks_foc.c ****                 Mci[M1].State = IDLE;
 260:Src/mc_tasks_foc.c ****               }
 261:Src/mc_tasks_foc.c ****               else
 262:Src/mc_tasks_foc.c ****               {
 263:Src/mc_tasks_foc.c ****                 Mci[M1].State = WAIT_STOP_MOTOR;
 264:Src/mc_tasks_foc.c ****               }
 265:Src/mc_tasks_foc.c ****             }
 266:Src/mc_tasks_foc.c ****             else
 267:Src/mc_tasks_foc.c ****             {
 268:Src/mc_tasks_foc.c ****               /* Nothing to be done, FW waits for offset calibration to finish */
 269:Src/mc_tasks_foc.c ****             }
 270:Src/mc_tasks_foc.c ****           }
 271:Src/mc_tasks_foc.c ****           break;
 272:Src/mc_tasks_foc.c ****         }
 273:Src/mc_tasks_foc.c **** 
 274:Src/mc_tasks_foc.c ****         case CHARGE_BOOT_CAP:
 275:Src/mc_tasks_foc.c ****         {
 276:Src/mc_tasks_foc.c ****           if (MCI_STOP == Mci[M1].DirectCommand)
 277:Src/mc_tasks_foc.c ****           {
 278:Src/mc_tasks_foc.c ****             TSK_MF_StopProcessing(M1);
 279:Src/mc_tasks_foc.c ****           }
 280:Src/mc_tasks_foc.c ****           else
 281:Src/mc_tasks_foc.c ****           {
 282:Src/mc_tasks_foc.c ****             if (TSK_ChargeBootCapDelayHasElapsedM1())
 283:Src/mc_tasks_foc.c ****             {
 284:Src/mc_tasks_foc.c ****               R3_2_SwitchOffPWM(pwmcHandle[M1]);
 285:Src/mc_tasks_foc.c ****               FOCVars[M1].bDriveInput = EXTERNAL;
 286:Src/mc_tasks_foc.c ****               STC_SetSpeedSensor( pSTC[M1], &VirtualSpeedSensorM1._Super );
 287:Src/mc_tasks_foc.c **** 
 288:Src/mc_tasks_foc.c ****               STO_PLL_Clear(&STO_PLL_M1);
 289:Src/mc_tasks_foc.c ****               PWMC_Clear(pwmcHandle[M1]);
 290:Src/mc_tasks_foc.c **** 
 291:Src/mc_tasks_foc.c ****               FOC_Clear( M1 );
 292:Src/mc_tasks_foc.c **** 
 293:Src/mc_tasks_foc.c ****         SCC_Start(&SCC);
 294:Src/mc_tasks_foc.c ****               /* The generic function needs to be called here as the undelying
 295:Src/mc_tasks_foc.c ****                * implementation changes in time depending on the Profiler's state
 296:Src/mc_tasks_foc.c ****                * machine. Calling the generic function ensures that the correct
 297:Src/mc_tasks_foc.c ****                * implementation is invoked */
 298:Src/mc_tasks_foc.c ****               PWMC_SwitchOnPWM(pwmcHandle[M1]);
 299:Src/mc_tasks_foc.c ****               Mci[M1].State = START;
 300:Src/mc_tasks_foc.c ****               PWMC_SwitchOnPWM(pwmcHandle[M1]);
 301:Src/mc_tasks_foc.c ****             }
 302:Src/mc_tasks_foc.c ****             else
 303:Src/mc_tasks_foc.c ****             {
 304:Src/mc_tasks_foc.c ****               /* Nothing to be done, FW waits for bootstrap capacitor to charge */
 305:Src/mc_tasks_foc.c ****             }
 306:Src/mc_tasks_foc.c ****           }
 307:Src/mc_tasks_foc.c ****           break;
 308:Src/mc_tasks_foc.c ****         }
 309:Src/mc_tasks_foc.c **** 
 310:Src/mc_tasks_foc.c ****         case START:
 311:Src/mc_tasks_foc.c ****         {
 312:Src/mc_tasks_foc.c ****           if (MCI_STOP == Mci[M1].DirectCommand)
 313:Src/mc_tasks_foc.c ****           {
 314:Src/mc_tasks_foc.c ****             TSK_MF_StopProcessing(M1);
ARM GAS  /tmp/cccnQOYj.s 			page 7


 315:Src/mc_tasks_foc.c ****           }
 316:Src/mc_tasks_foc.c ****           else
 317:Src/mc_tasks_foc.c ****           {
 318:Src/mc_tasks_foc.c ****             /* Mechanical speed as imposed by the Virtual Speed Sensor during the Rev Up phase. */
 319:Src/mc_tasks_foc.c ****             int16_t hForcedMecSpeedUnit;
 320:Src/mc_tasks_foc.c ****             qd_t IqdRef;
 321:Src/mc_tasks_foc.c ****             bool ObserverConverged;
 322:Src/mc_tasks_foc.c **** 
 323:Src/mc_tasks_foc.c ****             /* Execute the Rev Up procedure */
 324:Src/mc_tasks_foc.c ****             if(! RUC_Exec(&RevUpControlM1))
 325:Src/mc_tasks_foc.c ****             {
 326:Src/mc_tasks_foc.c ****             /* The time allowed for the startup sequence has expired */
 327:Src/mc_tasks_foc.c ****               /* However, no error is generated when OPEN LOOP is enabled
 328:Src/mc_tasks_foc.c ****                * since then the system does not try to close the loop... */
 329:Src/mc_tasks_foc.c ****             }
 330:Src/mc_tasks_foc.c ****             else
 331:Src/mc_tasks_foc.c ****             {
 332:Src/mc_tasks_foc.c ****               /* Execute the torque open loop current start-up ramp:
 333:Src/mc_tasks_foc.c ****                * Compute the Iq reference current as configured in the Rev Up sequence */
 334:Src/mc_tasks_foc.c ****               IqdRef.q = STC_CalcTorqueReference(pSTC[M1]);
 335:Src/mc_tasks_foc.c ****               IqdRef.d = FOCVars[M1].UserIdref;
 336:Src/mc_tasks_foc.c ****               /* Iqd reference current used by the High Frequency Loop to generate the PWM output *
 337:Src/mc_tasks_foc.c ****               FOCVars[M1].Iqdref = IqdRef;
 338:Src/mc_tasks_foc.c ****            }
 339:Src/mc_tasks_foc.c **** 
 340:Src/mc_tasks_foc.c ****             (void)VSS_CalcAvrgMecSpeedUnit(&VirtualSpeedSensorM1, &hForcedMecSpeedUnit);
 341:Src/mc_tasks_foc.c **** 
 342:Src/mc_tasks_foc.c ****               ObserverConverged = STO_PLL_IsObserverConverged(&STO_PLL_M1, &hForcedMecSpeedUnit);
 343:Src/mc_tasks_foc.c ****               STO_SetDirection(&STO_PLL_M1, (int8_t)MCI_GetImposedMotorDirection(&Mci[M1]));
 344:Src/mc_tasks_foc.c **** 
 345:Src/mc_tasks_foc.c ****               (void)VSS_SetStartTransition(&VirtualSpeedSensorM1, ObserverConverged);
 346:Src/mc_tasks_foc.c ****             if (ObserverConverged)
 347:Src/mc_tasks_foc.c ****             {
 348:Src/mc_tasks_foc.c ****               qd_t StatorCurrent = MCM_Park(FOCVars[M1].Ialphabeta, SPD_GetElAngle(&STO_PLL_M1._Sup
 349:Src/mc_tasks_foc.c **** 
 350:Src/mc_tasks_foc.c ****               /* Start switch over ramp. This ramp will transition from the revup to the closed loo
 351:Src/mc_tasks_foc.c ****               REMNG_Init(pREMNG[M1]);
 352:Src/mc_tasks_foc.c ****               (void)REMNG_ExecRamp(pREMNG[M1], FOCVars[M1].Iqdref.q, 0);
 353:Src/mc_tasks_foc.c ****               (void)REMNG_ExecRamp(pREMNG[M1], StatorCurrent.q, TRANSITION_DURATION);
 354:Src/mc_tasks_foc.c **** 
 355:Src/mc_tasks_foc.c ****               Mci[M1].State = SWITCH_OVER;
 356:Src/mc_tasks_foc.c ****             }
 357:Src/mc_tasks_foc.c ****           }
 358:Src/mc_tasks_foc.c ****           break;
 359:Src/mc_tasks_foc.c ****         }
 360:Src/mc_tasks_foc.c **** 
 361:Src/mc_tasks_foc.c ****         case SWITCH_OVER:
 362:Src/mc_tasks_foc.c ****         {
 363:Src/mc_tasks_foc.c ****           if (MCI_STOP == Mci[M1].DirectCommand)
 364:Src/mc_tasks_foc.c ****           {
 365:Src/mc_tasks_foc.c ****             TSK_MF_StopProcessing(M1);
 366:Src/mc_tasks_foc.c ****           }
 367:Src/mc_tasks_foc.c ****           else
 368:Src/mc_tasks_foc.c ****           {
 369:Src/mc_tasks_foc.c ****             bool LoopClosed;
 370:Src/mc_tasks_foc.c ****             int16_t hForcedMecSpeedUnit;
 371:Src/mc_tasks_foc.c **** 
ARM GAS  /tmp/cccnQOYj.s 			page 8


 372:Src/mc_tasks_foc.c ****               /* Compute the virtual speed and positions of the rotor.
 373:Src/mc_tasks_foc.c ****                  The function returns true if the virtual speed is in the reliability range */
 374:Src/mc_tasks_foc.c ****               LoopClosed = VSS_CalcAvrgMecSpeedUnit(&VirtualSpeedSensorM1, &hForcedMecSpeedUnit);
 375:Src/mc_tasks_foc.c ****               /* Check if the transition ramp has completed. */
 376:Src/mc_tasks_foc.c ****               bool tempBool;
 377:Src/mc_tasks_foc.c ****               tempBool = VSS_TransitionEnded(&VirtualSpeedSensorM1);
 378:Src/mc_tasks_foc.c ****               LoopClosed = LoopClosed || tempBool;
 379:Src/mc_tasks_foc.c **** 
 380:Src/mc_tasks_foc.c ****               /* If any of the above conditions is true, the loop is considered closed.
 381:Src/mc_tasks_foc.c ****                  The state machine transitions to the RUN state */
 382:Src/mc_tasks_foc.c ****               if (true ==  LoopClosed)
 383:Src/mc_tasks_foc.c ****               {
 384:Src/mc_tasks_foc.c **** #if PID_SPEED_INTEGRAL_INIT_DIV == 0
 385:Src/mc_tasks_foc.c ****                 PID_SetIntegralTerm(&PIDSpeedHandle_M1, 0);
 386:Src/mc_tasks_foc.c **** #else
 387:Src/mc_tasks_foc.c ****                 PID_SetIntegralTerm(&PIDSpeedHandle_M1,
 388:Src/mc_tasks_foc.c ****                                     (((int32_t)FOCVars[M1].Iqdref.q * (int16_t)PID_GetKIDivisor(&PI
 389:Src/mc_tasks_foc.c ****                                     / PID_SPEED_INTEGRAL_INIT_DIV));
 390:Src/mc_tasks_foc.c **** #endif
 391:Src/mc_tasks_foc.c ****                 OTT_SR(&OTT);
 392:Src/mc_tasks_foc.c ****                 /* USER CODE BEGIN MediumFrequencyTask M1 1 */
 393:Src/mc_tasks_foc.c **** 
 394:Src/mc_tasks_foc.c ****                 /* USER CODE END MediumFrequencyTask M1 1 */
 395:Src/mc_tasks_foc.c ****                 STC_SetSpeedSensor(pSTC[M1], &STO_PLL_M1._Super); /* Observer has converged */
 396:Src/mc_tasks_foc.c ****                 FOC_InitAdditionalMethods(M1);
 397:Src/mc_tasks_foc.c ****                 FOC_CalcCurrRef(M1);
 398:Src/mc_tasks_foc.c ****                 STC_ForceSpeedReferenceToCurrentSpeed(pSTC[M1]); /* Init the reference speed to cur
 399:Src/mc_tasks_foc.c ****                 MCI_ExecBufferedCommands(&Mci[M1]); /* Exec the speed ramp after changing of the sp
 400:Src/mc_tasks_foc.c ****                 Mci[M1].State = RUN;
 401:Src/mc_tasks_foc.c ****               }
 402:Src/mc_tasks_foc.c ****           }
 403:Src/mc_tasks_foc.c ****           break;
 404:Src/mc_tasks_foc.c ****         }
 405:Src/mc_tasks_foc.c **** 
 406:Src/mc_tasks_foc.c ****         case RUN:
 407:Src/mc_tasks_foc.c ****         {
 408:Src/mc_tasks_foc.c ****           if (MCI_STOP == Mci[M1].DirectCommand)
 409:Src/mc_tasks_foc.c ****           {
 410:Src/mc_tasks_foc.c ****             TSK_MF_StopProcessing(M1);
 411:Src/mc_tasks_foc.c ****           }
 412:Src/mc_tasks_foc.c ****           else
 413:Src/mc_tasks_foc.c ****           {
 414:Src/mc_tasks_foc.c ****             /* USER CODE BEGIN MediumFrequencyTask M1 2 */
 415:Src/mc_tasks_foc.c **** 
 416:Src/mc_tasks_foc.c ****             /* USER CODE END MediumFrequencyTask M1 2 */
 417:Src/mc_tasks_foc.c **** 
 418:Src/mc_tasks_foc.c ****             MCI_ExecBufferedCommands(&Mci[M1]);
 419:Src/mc_tasks_foc.c **** 
 420:Src/mc_tasks_foc.c ****               FOC_CalcCurrRef(M1);
 421:Src/mc_tasks_foc.c ****               if(!IsSpeedReliable)
 422:Src/mc_tasks_foc.c ****               {
 423:Src/mc_tasks_foc.c ****                 MCI_FaultProcessing(&Mci[M1], MC_SPEED_FDBK, 0);
 424:Src/mc_tasks_foc.c ****               }
 425:Src/mc_tasks_foc.c ****               else
 426:Src/mc_tasks_foc.c ****               {
 427:Src/mc_tasks_foc.c ****                 /* Nothing to do */
 428:Src/mc_tasks_foc.c ****               }
ARM GAS  /tmp/cccnQOYj.s 			page 9


 429:Src/mc_tasks_foc.c ****             OTT_MF(&OTT);
 430:Src/mc_tasks_foc.c ****           }
 431:Src/mc_tasks_foc.c ****           break;
 432:Src/mc_tasks_foc.c ****         }
 433:Src/mc_tasks_foc.c **** 
 434:Src/mc_tasks_foc.c ****         case STOP:
 435:Src/mc_tasks_foc.c ****         {
 436:Src/mc_tasks_foc.c ****           if (TSK_StopPermanencyTimeHasElapsedM1())
 437:Src/mc_tasks_foc.c ****           {
 438:Src/mc_tasks_foc.c **** 
 439:Src/mc_tasks_foc.c ****             STC_SetSpeedSensor(pSTC[M1], &VirtualSpeedSensorM1._Super);    /* Sensor-less */
 440:Src/mc_tasks_foc.c ****             VSS_Clear(&VirtualSpeedSensorM1); /* Reset measured speed in IDLE */
 441:Src/mc_tasks_foc.c ****             /* USER CODE BEGIN MediumFrequencyTask M1 5 */
 442:Src/mc_tasks_foc.c **** 
 443:Src/mc_tasks_foc.c ****             /* USER CODE END MediumFrequencyTask M1 5 */
 444:Src/mc_tasks_foc.c ****             Mci[M1].DirectCommand = MCI_NO_COMMAND;
 445:Src/mc_tasks_foc.c ****             Mci[M1].State = IDLE;
 446:Src/mc_tasks_foc.c ****           }
 447:Src/mc_tasks_foc.c ****           else
 448:Src/mc_tasks_foc.c ****           {
 449:Src/mc_tasks_foc.c ****             /* Nothing to do, FW waits for to stop */
 450:Src/mc_tasks_foc.c ****           }
 451:Src/mc_tasks_foc.c ****           break;
 452:Src/mc_tasks_foc.c ****         }
 453:Src/mc_tasks_foc.c **** 
 454:Src/mc_tasks_foc.c ****         case FAULT_OVER:
 455:Src/mc_tasks_foc.c ****         {
 456:Src/mc_tasks_foc.c ****           if (MCI_ACK_FAULTS == Mci[M1].DirectCommand)
 457:Src/mc_tasks_foc.c ****           {
 458:Src/mc_tasks_foc.c ****             Mci[M1].DirectCommand = MCI_NO_COMMAND;
 459:Src/mc_tasks_foc.c ****             Mci[M1].State = IDLE;
 460:Src/mc_tasks_foc.c ****           }
 461:Src/mc_tasks_foc.c ****           else
 462:Src/mc_tasks_foc.c ****           {
 463:Src/mc_tasks_foc.c ****             /* Nothing to do, FW stays in FAULT_OVER state until acknowledgement */
 464:Src/mc_tasks_foc.c ****           }
 465:Src/mc_tasks_foc.c ****           break;
 466:Src/mc_tasks_foc.c ****         }
 467:Src/mc_tasks_foc.c **** 
 468:Src/mc_tasks_foc.c ****         case FAULT_NOW:
 469:Src/mc_tasks_foc.c ****         {
 470:Src/mc_tasks_foc.c ****           Mci[M1].State = FAULT_OVER;
 471:Src/mc_tasks_foc.c ****           break;
 472:Src/mc_tasks_foc.c ****         }
 473:Src/mc_tasks_foc.c **** 
 474:Src/mc_tasks_foc.c ****         case WAIT_STOP_MOTOR:
 475:Src/mc_tasks_foc.c ****         {
 476:Src/mc_tasks_foc.c ****           if (MCI_STOP == Mci[M1].DirectCommand)
 477:Src/mc_tasks_foc.c ****           {
 478:Src/mc_tasks_foc.c ****             TSK_MF_StopProcessing(M1);
 479:Src/mc_tasks_foc.c ****           }
 480:Src/mc_tasks_foc.c ****           else
 481:Src/mc_tasks_foc.c ****           {
 482:Src/mc_tasks_foc.c ****             if (0 == SCC_DetectBemf(&SCC))
 483:Src/mc_tasks_foc.c ****             {
 484:Src/mc_tasks_foc.c ****               /* In a sensorless configuration. Initiate the Revup procedure */
 485:Src/mc_tasks_foc.c ****               FOCVars[M1].bDriveInput = EXTERNAL;
ARM GAS  /tmp/cccnQOYj.s 			page 10


 486:Src/mc_tasks_foc.c ****               STC_SetSpeedSensor(pSTC[M1], &VirtualSpeedSensorM1._Super);
 487:Src/mc_tasks_foc.c ****                STO_PLL_Clear(&STO_PLL_M1);
 488:Src/mc_tasks_foc.c ****               FOC_Clear(M1);
 489:Src/mc_tasks_foc.c ****               SCC_Start(&SCC);
 490:Src/mc_tasks_foc.c ****               /* The generic function needs to be called here as the undelying
 491:Src/mc_tasks_foc.c ****                * implementation changes in time depending on the Profiler's state
 492:Src/mc_tasks_foc.c ****                * machine. Calling the generic function ensures that the correct
 493:Src/mc_tasks_foc.c ****                * implementation is invoked */
 494:Src/mc_tasks_foc.c ****               PWMC_SwitchOnPWM(pwmcHandle[M1]);
 495:Src/mc_tasks_foc.c ****               Mci[M1].State = START;
 496:Src/mc_tasks_foc.c ****             }
 497:Src/mc_tasks_foc.c ****             else
 498:Src/mc_tasks_foc.c ****             {
 499:Src/mc_tasks_foc.c ****               /* Nothing to do */
 500:Src/mc_tasks_foc.c ****             }
 501:Src/mc_tasks_foc.c ****           }
 502:Src/mc_tasks_foc.c ****           break;
 503:Src/mc_tasks_foc.c ****         }
 504:Src/mc_tasks_foc.c **** 
 505:Src/mc_tasks_foc.c ****         default:
 506:Src/mc_tasks_foc.c ****           break;
 507:Src/mc_tasks_foc.c ****        }
 508:Src/mc_tasks_foc.c ****     }
 509:Src/mc_tasks_foc.c ****     else
 510:Src/mc_tasks_foc.c ****     {
 511:Src/mc_tasks_foc.c ****       Mci[M1].State = FAULT_OVER;
 512:Src/mc_tasks_foc.c ****     }
 513:Src/mc_tasks_foc.c ****   }
 514:Src/mc_tasks_foc.c ****   else
 515:Src/mc_tasks_foc.c ****   {
 516:Src/mc_tasks_foc.c ****     Mci[M1].State = FAULT_NOW;
 517:Src/mc_tasks_foc.c ****   }
 518:Src/mc_tasks_foc.c ****   SCC_MF(&SCC);
 519:Src/mc_tasks_foc.c ****   /* USER CODE BEGIN MediumFrequencyTask M1 6 */
 520:Src/mc_tasks_foc.c **** 
 521:Src/mc_tasks_foc.c ****   /* USER CODE END MediumFrequencyTask M1 6 */
 522:Src/mc_tasks_foc.c **** }
 523:Src/mc_tasks_foc.c **** 
 524:Src/mc_tasks_foc.c **** /**
 525:Src/mc_tasks_foc.c ****   * @brief  It re-initializes the current and voltage variables. Moreover
 526:Src/mc_tasks_foc.c ****   *         it clears qd currents PI controllers, voltage sensor and SpeednTorque
 527:Src/mc_tasks_foc.c ****   *         controller. It must be called before each motor restart.
 528:Src/mc_tasks_foc.c ****   *         It does not clear speed sensor.
 529:Src/mc_tasks_foc.c ****   * @param  bMotor related motor it can be M1 or M2.
 530:Src/mc_tasks_foc.c ****   */
 531:Src/mc_tasks_foc.c **** __weak void FOC_Clear(uint8_t bMotor)
 532:Src/mc_tasks_foc.c **** {
  30              		.loc 1 532 1 view -0
  31              		.cfi_startproc
  32              		@ args = 0, pretend = 0, frame = 0
  33              		@ frame_needed = 0, uses_anonymous_args = 0
  34              		.loc 1 532 1 is_stmt 0 view .LVU1
  35 0000 38B5     		push	{r3, r4, r5, lr}
  36              	.LCFI0:
  37              		.cfi_def_cfa_offset 16
  38              		.cfi_offset 3, -16
  39              		.cfi_offset 4, -12
ARM GAS  /tmp/cccnQOYj.s 			page 11


  40              		.cfi_offset 5, -8
  41              		.cfi_offset 14, -4
  42 0002 0546     		mov	r5, r0
 533:Src/mc_tasks_foc.c ****   /* USER CODE BEGIN FOC_Clear 0 */
 534:Src/mc_tasks_foc.c **** 
 535:Src/mc_tasks_foc.c ****   /* USER CODE END FOC_Clear 0 */
 536:Src/mc_tasks_foc.c **** 
 537:Src/mc_tasks_foc.c ****   ab_t NULL_ab = {((int16_t)0), ((int16_t)0)};
  43              		.loc 1 537 3 is_stmt 1 view .LVU2
  44              	.LVL1:
 538:Src/mc_tasks_foc.c ****   qd_t NULL_qd = {((int16_t)0), ((int16_t)0)};
  45              		.loc 1 538 3 view .LVU3
 539:Src/mc_tasks_foc.c ****   alphabeta_t NULL_alphabeta = {((int16_t)0), ((int16_t)0)};
  46              		.loc 1 539 3 view .LVU4
 540:Src/mc_tasks_foc.c **** 
 541:Src/mc_tasks_foc.c ****   FOCVars[bMotor].Iab = NULL_ab;
  47              		.loc 1 541 3 view .LVU5
  48              		.loc 1 541 23 is_stmt 0 view .LVU6
  49 0004 1A49     		ldr	r1, .L4
  50 0006 2622     		movs	r2, #38
  51 0008 00FB02F2 		mul	r2, r0, r2
  52 000c 8B18     		adds	r3, r1, r2
  53 000e 0024     		movs	r4, #0
  54 0010 8C52     		strh	r4, [r1, r2]	@ movhi
  55 0012 5C80     		strh	r4, [r3, #2]	@ movhi
 542:Src/mc_tasks_foc.c ****   FOCVars[bMotor].Ialphabeta = NULL_alphabeta;
  56              		.loc 1 542 3 is_stmt 1 view .LVU7
  57              		.loc 1 542 30 is_stmt 0 view .LVU8
  58 0014 9C80     		strh	r4, [r3, #4]	@ movhi
  59 0016 DC80     		strh	r4, [r3, #6]	@ movhi
 543:Src/mc_tasks_foc.c ****   FOCVars[bMotor].Iqd = NULL_qd;
  60              		.loc 1 543 3 is_stmt 1 view .LVU9
  61              		.loc 1 543 23 is_stmt 0 view .LVU10
  62 0018 9C81     		strh	r4, [r3, #12]	@ movhi
  63 001a DC81     		strh	r4, [r3, #14]	@ movhi
 544:Src/mc_tasks_foc.c ****     FOCVars[bMotor].Iqdref = NULL_qd;
  64              		.loc 1 544 5 is_stmt 1 view .LVU11
  65              		.loc 1 544 28 is_stmt 0 view .LVU12
  66 001c 1C82     		strh	r4, [r3, #16]	@ movhi
  67 001e 5C82     		strh	r4, [r3, #18]	@ movhi
 545:Src/mc_tasks_foc.c ****   FOCVars[bMotor].hTeref = (int16_t)0;
  68              		.loc 1 545 3 is_stmt 1 view .LVU13
  69              		.loc 1 545 26 is_stmt 0 view .LVU14
  70 0020 DC83     		strh	r4, [r3, #30]	@ movhi
 546:Src/mc_tasks_foc.c ****   FOCVars[bMotor].Vqd = NULL_qd;
  71              		.loc 1 546 3 is_stmt 1 view .LVU15
  72              		.loc 1 546 23 is_stmt 0 view .LVU16
  73 0022 DC82     		strh	r4, [r3, #22]	@ movhi
  74 0024 1C83     		strh	r4, [r3, #24]	@ movhi
 547:Src/mc_tasks_foc.c ****   FOCVars[bMotor].Valphabeta = NULL_alphabeta;
  75              		.loc 1 547 3 is_stmt 1 view .LVU17
  76              		.loc 1 547 30 is_stmt 0 view .LVU18
  77 0026 5C83     		strh	r4, [r3, #26]	@ movhi
  78 0028 9C83     		strh	r4, [r3, #28]	@ movhi
 548:Src/mc_tasks_foc.c ****   FOCVars[bMotor].hElAngle = (int16_t)0;
  79              		.loc 1 548 3 is_stmt 1 view .LVU19
  80              		.loc 1 548 28 is_stmt 0 view .LVU20
ARM GAS  /tmp/cccnQOYj.s 			page 12


  81 002a 1C84     		strh	r4, [r3, #32]	@ movhi
 549:Src/mc_tasks_foc.c **** 
 550:Src/mc_tasks_foc.c ****   PID_SetIntegralTerm(pPIDIq[bMotor], ((int32_t)0));
  82              		.loc 1 550 3 is_stmt 1 view .LVU21
  83 002c 2146     		mov	r1, r4
  84 002e 114B     		ldr	r3, .L4+4
  85 0030 53F82000 		ldr	r0, [r3, r0, lsl #2]
  86              	.LVL2:
  87              		.loc 1 550 3 is_stmt 0 view .LVU22
  88 0034 FFF7FEFF 		bl	PID_SetIntegralTerm
  89              	.LVL3:
 551:Src/mc_tasks_foc.c ****   PID_SetIntegralTerm(pPIDId[bMotor], ((int32_t)0));
  90              		.loc 1 551 3 is_stmt 1 view .LVU23
  91 0038 2146     		mov	r1, r4
  92 003a 0F4B     		ldr	r3, .L4+8
  93 003c 53F82500 		ldr	r0, [r3, r5, lsl #2]
  94 0040 FFF7FEFF 		bl	PID_SetIntegralTerm
  95              	.LVL4:
 552:Src/mc_tasks_foc.c **** 
 553:Src/mc_tasks_foc.c ****   STC_Clear(pSTC[bMotor]);
  96              		.loc 1 553 3 view .LVU24
  97 0044 0D4B     		ldr	r3, .L4+12
  98 0046 53F82500 		ldr	r0, [r3, r5, lsl #2]
  99 004a FFF7FEFF 		bl	STC_Clear
 100              	.LVL5:
 554:Src/mc_tasks_foc.c **** 
 555:Src/mc_tasks_foc.c ****   PWMC_SwitchOffPWM(pwmcHandle[bMotor]);
 101              		.loc 1 555 3 view .LVU25
 102 004e 0C4B     		ldr	r3, .L4+16
 103 0050 53F82500 		ldr	r0, [r3, r5, lsl #2]
 104 0054 FFF7FEFF 		bl	PWMC_SwitchOffPWM
 105              	.LVL6:
 556:Src/mc_tasks_foc.c **** 
 557:Src/mc_tasks_foc.c ****   if (NULL == pFF[bMotor])
 106              		.loc 1 557 3 view .LVU26
 107              		.loc 1 557 18 is_stmt 0 view .LVU27
 108 0058 0A4B     		ldr	r3, .L4+20
 109 005a 53F82500 		ldr	r0, [r3, r5, lsl #2]
 110              		.loc 1 557 6 view .LVU28
 111 005e 08B1     		cbz	r0, .L2
 558:Src/mc_tasks_foc.c ****   {
 559:Src/mc_tasks_foc.c ****     /* Nothing to do */
 560:Src/mc_tasks_foc.c ****   }
 561:Src/mc_tasks_foc.c ****   else
 562:Src/mc_tasks_foc.c ****   {
 563:Src/mc_tasks_foc.c ****     FF_Clear(pFF[bMotor]);
 112              		.loc 1 563 5 is_stmt 1 view .LVU29
 113 0060 FFF7FEFF 		bl	FF_Clear
 114              	.LVL7:
 115              	.L2:
 564:Src/mc_tasks_foc.c ****   }
 565:Src/mc_tasks_foc.c **** 
 566:Src/mc_tasks_foc.c ****   MC_Perf_Clear(&PerfTraces,bMotor);
 116              		.loc 1 566 3 view .LVU30
 117 0064 2946     		mov	r1, r5
 118 0066 0848     		ldr	r0, .L4+24
 119 0068 FFF7FEFF 		bl	MC_Perf_Clear
ARM GAS  /tmp/cccnQOYj.s 			page 13


 120              	.LVL8:
 567:Src/mc_tasks_foc.c ****   /* USER CODE BEGIN FOC_Clear 1 */
 568:Src/mc_tasks_foc.c **** 
 569:Src/mc_tasks_foc.c ****   /* USER CODE END FOC_Clear 1 */
 570:Src/mc_tasks_foc.c **** }
 121              		.loc 1 570 1 is_stmt 0 view .LVU31
 122 006c 38BD     		pop	{r3, r4, r5, pc}
 123              	.L5:
 124 006e 00BF     		.align	2
 125              	.L4:
 126 0070 00000000 		.word	FOCVars
 127 0074 00000000 		.word	pPIDIq
 128 0078 00000000 		.word	pPIDId
 129 007c 00000000 		.word	pSTC
 130 0080 00000000 		.word	pwmcHandle
 131 0084 00000000 		.word	pFF
 132 0088 00000000 		.word	PerfTraces
 133              		.cfi_endproc
 134              	.LFE1870:
 136              		.section	.text.FOC_Init,"ax",%progbits
 137              		.align	1
 138              		.weak	FOC_Init
 139              		.syntax unified
 140              		.thumb
 141              		.thumb_func
 142              		.fpu fpv4-sp-d16
 144              	FOC_Init:
 145              	.LFB1867:
  82:Src/mc_tasks_foc.c **** 
 146              		.loc 1 82 1 is_stmt 1 view -0
 147              		.cfi_startproc
 148              		@ args = 0, pretend = 0, frame = 8
 149              		@ frame_needed = 0, uses_anonymous_args = 0
 150 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 151              	.LCFI1:
 152              		.cfi_def_cfa_offset 36
 153              		.cfi_offset 4, -36
 154              		.cfi_offset 5, -32
 155              		.cfi_offset 6, -28
 156              		.cfi_offset 7, -24
 157              		.cfi_offset 8, -20
 158              		.cfi_offset 9, -16
 159              		.cfi_offset 10, -12
 160              		.cfi_offset 11, -8
 161              		.cfi_offset 14, -4
 162 0004 85B0     		sub	sp, sp, #20
 163              	.LCFI2:
 164              		.cfi_def_cfa_offset 56
  91:Src/mc_tasks_foc.c ****     R3_2_Init(&PWM_Handle_M1);
 165              		.loc 1 91 5 view .LVU33
  91:Src/mc_tasks_foc.c ****     R3_2_Init(&PWM_Handle_M1);
 166              		.loc 1 91 20 is_stmt 0 view .LVU34
 167 0006 DFF85C91 		ldr	r9, .L8+64
 168 000a 4648     		ldr	r0, .L8
 169 000c C9F80000 		str	r0, [r9]
  92:Src/mc_tasks_foc.c **** 
 170              		.loc 1 92 5 is_stmt 1 view .LVU35
ARM GAS  /tmp/cccnQOYj.s 			page 14


 171 0010 FFF7FEFF 		bl	R3_2_Init
 172              	.LVL9:
 101:Src/mc_tasks_foc.c **** 
 173              		.loc 1 101 5 view .LVU36
 174 0014 FFF7FEFF 		bl	startTimers
 175              	.LVL10:
 106:Src/mc_tasks_foc.c **** 
 176              		.loc 1 106 5 view .LVU37
 177 0018 434F     		ldr	r7, .L8+4
 178 001a 3846     		mov	r0, r7
 179 001c FFF7FEFF 		bl	PID_HandleInit
 180              	.LVL11:
 111:Src/mc_tasks_foc.c **** 
 181              		.loc 1 111 5 view .LVU38
 182 0020 424E     		ldr	r6, .L8+8
 183 0022 3046     		mov	r0, r6
 184 0024 FFF7FEFF 		bl	STO_PLL_Init
 185              	.LVL12:
 116:Src/mc_tasks_foc.c **** 
 186              		.loc 1 116 5 view .LVU39
 187 0028 414D     		ldr	r5, .L8+12
 188 002a 3246     		mov	r2, r6
 189 002c 3946     		mov	r1, r7
 190 002e 2868     		ldr	r0, [r5]
 191 0030 FFF7FEFF 		bl	STC_Init
 192              	.LVL13:
 121:Src/mc_tasks_foc.c **** 
 193              		.loc 1 121 5 view .LVU40
 194 0034 D9F80030 		ldr	r3, [r9]
 195 0038 0093     		str	r3, [sp]
 196 003a 3E4B     		ldr	r3, .L8+16
 197 003c 3E4A     		ldr	r2, .L8+20
 198 003e 2968     		ldr	r1, [r5]
 199 0040 3E48     		ldr	r0, .L8+24
 200 0042 FFF7FEFF 		bl	RUC_Init
 201              	.LVL14:
 126:Src/mc_tasks_foc.c ****     PID_HandleInit(&PIDIdHandle_M1);
 202              		.loc 1 126 5 view .LVU41
 203 0046 3E48     		ldr	r0, .L8+28
 204 0048 FFF7FEFF 		bl	PID_HandleInit
 205              	.LVL15:
 127:Src/mc_tasks_foc.c **** 
 206              		.loc 1 127 5 view .LVU42
 207 004c 3D48     		ldr	r0, .L8+32
 208 004e FFF7FEFF 		bl	PID_HandleInit
 209              	.LVL16:
 132:Src/mc_tasks_foc.c ****     pMPM[M1]->pFOCVars = &FOCVars[M1];
 210              		.loc 1 132 5 view .LVU43
 132:Src/mc_tasks_foc.c ****     pMPM[M1]->pFOCVars = &FOCVars[M1];
 211              		.loc 1 132 9 is_stmt 0 view .LVU44
 212 0052 3D4B     		ldr	r3, .L8+36
 213 0054 1B68     		ldr	r3, [r3]
 132:Src/mc_tasks_foc.c ****     pMPM[M1]->pFOCVars = &FOCVars[M1];
 214              		.loc 1 132 20 view .LVU45
 215 0056 DFF81081 		ldr	r8, .L8+68
 216 005a C3F80C80 		str	r8, [r3, #12]
 133:Src/mc_tasks_foc.c **** 
ARM GAS  /tmp/cccnQOYj.s 			page 15


 217              		.loc 1 133 5 is_stmt 1 view .LVU46
 133:Src/mc_tasks_foc.c **** 
 218              		.loc 1 133 24 is_stmt 0 view .LVU47
 219 005e 3B4C     		ldr	r4, .L8+40
 220 0060 9C60     		str	r4, [r3, #8]
 138:Src/mc_tasks_foc.c **** 
 221              		.loc 1 138 5 is_stmt 1 view .LVU48
 222 0062 DFF808B1 		ldr	fp, .L8+72
 223 0066 DFF808A1 		ldr	r10, .L8+76
 224 006a DBF80030 		ldr	r3, [fp]
 225 006e DAF80020 		ldr	r2, [r10]
 226 0072 4146     		mov	r1, r8
 227 0074 3648     		ldr	r0, .L8+44
 228 0076 0068     		ldr	r0, [r0]
 229 0078 FFF7FEFF 		bl	FF_Init
 230              	.LVL17:
 140:Src/mc_tasks_foc.c ****     REMNG_Init(pREMNG[M1]);
 231              		.loc 1 140 5 view .LVU49
 140:Src/mc_tasks_foc.c ****     REMNG_Init(pREMNG[M1]);
 232              		.loc 1 140 16 is_stmt 0 view .LVU50
 233 007c 3548     		ldr	r0, .L8+48
 234 007e 364B     		ldr	r3, .L8+52
 235 0080 1860     		str	r0, [r3]
 141:Src/mc_tasks_foc.c **** 
 236              		.loc 1 141 5 is_stmt 1 view .LVU51
 237 0082 FFF7FEFF 		bl	REMNG_Init
 238              	.LVL18:
 143:Src/mc_tasks_foc.c ****     SCC.pVBS = &BusVoltageSensor_M1;
 239              		.loc 1 143 5 view .LVU52
 143:Src/mc_tasks_foc.c ****     SCC.pVBS = &BusVoltageSensor_M1;
 240              		.loc 1 143 15 is_stmt 0 view .LVU53
 241 0086 3548     		ldr	r0, .L8+56
 242 0088 D9F80030 		ldr	r3, [r9]
 243 008c 0360     		str	r3, [r0]
 144:Src/mc_tasks_foc.c ****     SCC.pFOCVars = &FOCVars[M1];
 244              		.loc 1 144 5 is_stmt 1 view .LVU54
 144:Src/mc_tasks_foc.c ****     SCC.pFOCVars = &FOCVars[M1];
 245              		.loc 1 144 14 is_stmt 0 view .LVU55
 246 008e C0F80480 		str	r8, [r0, #4]
 145:Src/mc_tasks_foc.c ****     SCC.pMCI = &Mci[M1];
 247              		.loc 1 145 5 is_stmt 1 view .LVU56
 145:Src/mc_tasks_foc.c ****     SCC.pMCI = &Mci[M1];
 248              		.loc 1 145 18 is_stmt 0 view .LVU57
 249 0092 8460     		str	r4, [r0, #8]
 146:Src/mc_tasks_foc.c ****     SCC.pVSS = &VirtualSpeedSensorM1;
 250              		.loc 1 146 5 is_stmt 1 view .LVU58
 146:Src/mc_tasks_foc.c ****     SCC.pVSS = &VirtualSpeedSensorM1;
 251              		.loc 1 146 14 is_stmt 0 view .LVU59
 252 0094 DFF8DC80 		ldr	r8, .L8+80
 253 0098 C0F80C80 		str	r8, [r0, #12]
 147:Src/mc_tasks_foc.c ****     SCC.pCLM = &CircleLimitationM1;
 254              		.loc 1 147 5 is_stmt 1 view .LVU60
 147:Src/mc_tasks_foc.c ****     SCC.pCLM = &CircleLimitationM1;
 255              		.loc 1 147 14 is_stmt 0 view .LVU61
 256 009c 264B     		ldr	r3, .L8+20
 257 009e 0361     		str	r3, [r0, #16]
 148:Src/mc_tasks_foc.c ****     SCC.pPIDIq = pPIDIq[M1];
ARM GAS  /tmp/cccnQOYj.s 			page 16


 258              		.loc 1 148 5 is_stmt 1 view .LVU62
 148:Src/mc_tasks_foc.c ****     SCC.pPIDIq = pPIDIq[M1];
 259              		.loc 1 148 14 is_stmt 0 view .LVU63
 260 00a0 2F4B     		ldr	r3, .L8+60
 261 00a2 4361     		str	r3, [r0, #20]
 149:Src/mc_tasks_foc.c ****     SCC.pPIDId = pPIDId[M1];
 262              		.loc 1 149 5 is_stmt 1 view .LVU64
 149:Src/mc_tasks_foc.c ****     SCC.pPIDId = pPIDId[M1];
 263              		.loc 1 149 16 is_stmt 0 view .LVU65
 264 00a4 DBF80030 		ldr	r3, [fp]
 265 00a8 8361     		str	r3, [r0, #24]
 150:Src/mc_tasks_foc.c ****     SCC.pRevupCtrl = &RevUpControlM1;
 266              		.loc 1 150 5 is_stmt 1 view .LVU66
 150:Src/mc_tasks_foc.c ****     SCC.pRevupCtrl = &RevUpControlM1;
 267              		.loc 1 150 16 is_stmt 0 view .LVU67
 268 00aa DAF80030 		ldr	r3, [r10]
 269 00ae C361     		str	r3, [r0, #28]
 151:Src/mc_tasks_foc.c ****     SCC.pSTO = &STO_PLL_M1;
 270              		.loc 1 151 5 is_stmt 1 view .LVU68
 151:Src/mc_tasks_foc.c ****     SCC.pSTO = &STO_PLL_M1;
 271              		.loc 1 151 20 is_stmt 0 view .LVU69
 272 00b0 224B     		ldr	r3, .L8+24
 273 00b2 0362     		str	r3, [r0, #32]
 152:Src/mc_tasks_foc.c ****     SCC.pSTC = &SpeednTorqCtrlM1;
 274              		.loc 1 152 5 is_stmt 1 view .LVU70
 152:Src/mc_tasks_foc.c ****     SCC.pSTC = &SpeednTorqCtrlM1;
 275              		.loc 1 152 14 is_stmt 0 view .LVU71
 276 00b4 4662     		str	r6, [r0, #36]
 153:Src/mc_tasks_foc.c ****     SCC.pOTT = &OTT;
 277              		.loc 1 153 5 is_stmt 1 view .LVU72
 153:Src/mc_tasks_foc.c ****     SCC.pOTT = &OTT;
 278              		.loc 1 153 14 is_stmt 0 view .LVU73
 279 00b6 DFF8C0B0 		ldr	fp, .L8+84
 280 00ba C0F828B0 		str	fp, [r0, #40]
 154:Src/mc_tasks_foc.c ****     SCC.pHT = MC_NULL;
 281              		.loc 1 154 5 is_stmt 1 view .LVU74
 154:Src/mc_tasks_foc.c ****     SCC.pHT = MC_NULL;
 282              		.loc 1 154 14 is_stmt 0 view .LVU75
 283 00be DFF8BC90 		ldr	r9, .L8+88
 284 00c2 C0F82C90 		str	r9, [r0, #44]
 155:Src/mc_tasks_foc.c ****     SCC_Init(&SCC);
 285              		.loc 1 155 5 is_stmt 1 view .LVU76
 155:Src/mc_tasks_foc.c ****     SCC_Init(&SCC);
 286              		.loc 1 155 13 is_stmt 0 view .LVU77
 287 00c6 4FF0000A 		mov	r10, #0
 288 00ca C0F830A0 		str	r10, [r0, #48]
 156:Src/mc_tasks_foc.c **** 
 289              		.loc 1 156 5 is_stmt 1 view .LVU78
 290 00ce FFF7FEFF 		bl	SCC_Init
 291              	.LVL19:
 158:Src/mc_tasks_foc.c ****     OTT.pFOCVars = &FOCVars[M1];
 292              		.loc 1 158 5 view .LVU79
 158:Src/mc_tasks_foc.c ****     OTT.pFOCVars = &FOCVars[M1];
 293              		.loc 1 158 22 is_stmt 0 view .LVU80
 294 00d2 C9F80060 		str	r6, [r9]
 159:Src/mc_tasks_foc.c ****     OTT.pPIDSpeed = &PIDSpeedHandle_M1;
 295              		.loc 1 159 5 is_stmt 1 view .LVU81
ARM GAS  /tmp/cccnQOYj.s 			page 17


 159:Src/mc_tasks_foc.c ****     OTT.pPIDSpeed = &PIDSpeedHandle_M1;
 296              		.loc 1 159 18 is_stmt 0 view .LVU82
 297 00d6 C9F80440 		str	r4, [r9, #4]
 160:Src/mc_tasks_foc.c ****     OTT.pSTC = &SpeednTorqCtrlM1;
 298              		.loc 1 160 5 is_stmt 1 view .LVU83
 160:Src/mc_tasks_foc.c ****     OTT.pSTC = &SpeednTorqCtrlM1;
 299              		.loc 1 160 19 is_stmt 0 view .LVU84
 300 00da C9F80870 		str	r7, [r9, #8]
 161:Src/mc_tasks_foc.c ****     OTT_Init(&OTT);
 301              		.loc 1 161 5 is_stmt 1 view .LVU85
 161:Src/mc_tasks_foc.c ****     OTT_Init(&OTT);
 302              		.loc 1 161 14 is_stmt 0 view .LVU86
 303 00de C9F80CB0 		str	fp, [r9, #12]
 162:Src/mc_tasks_foc.c **** 
 304              		.loc 1 162 5 is_stmt 1 view .LVU87
 305 00e2 4846     		mov	r0, r9
 306 00e4 FFF7FEFF 		bl	OTT_Init
 307              	.LVL20:
 164:Src/mc_tasks_foc.c ****     FOCVars[M1].bDriveInput = EXTERNAL;
 308              		.loc 1 164 5 view .LVU88
 309 00e8 5046     		mov	r0, r10
 310 00ea FFF7FEFF 		bl	FOC_Clear
 311              	.LVL21:
 165:Src/mc_tasks_foc.c ****     FOCVars[M1].Iqdref = STC_GetDefaultIqdref(pSTC[M1]);
 312              		.loc 1 165 5 view .LVU89
 165:Src/mc_tasks_foc.c ****     FOCVars[M1].Iqdref = STC_GetDefaultIqdref(pSTC[M1]);
 313              		.loc 1 165 29 is_stmt 0 view .LVU90
 314 00ee 0123     		movs	r3, #1
 315 00f0 84F82430 		strb	r3, [r4, #36]
 166:Src/mc_tasks_foc.c ****     FOCVars[M1].UserIdref = STC_GetDefaultIqdref(pSTC[M1]).d;
 316              		.loc 1 166 5 is_stmt 1 view .LVU91
 166:Src/mc_tasks_foc.c ****     FOCVars[M1].UserIdref = STC_GetDefaultIqdref(pSTC[M1]).d;
 317              		.loc 1 166 26 is_stmt 0 view .LVU92
 318 00f4 2868     		ldr	r0, [r5]
 319 00f6 FFF7FEFF 		bl	STC_GetDefaultIqdref
 320              	.LVL22:
 321 00fa 2082     		strh	r0, [r4, #16]	@ movhi
 322 00fc C0F30F40 		ubfx	r0, r0, #16, #16
 323 0100 6082     		strh	r0, [r4, #18]	@ movhi
 167:Src/mc_tasks_foc.c **** 
 324              		.loc 1 167 5 is_stmt 1 view .LVU93
 167:Src/mc_tasks_foc.c **** 
 325              		.loc 1 167 29 is_stmt 0 view .LVU94
 326 0102 2868     		ldr	r0, [r5]
 327 0104 FFF7FEFF 		bl	STC_GetDefaultIqdref
 328              	.LVL23:
 329 0108 C0F30F40 		ubfx	r0, r0, #16, #16
 167:Src/mc_tasks_foc.c **** 
 330              		.loc 1 167 27 view .LVU95
 331 010c A082     		strh	r0, [r4, #20]	@ movhi
 169:Src/mc_tasks_foc.c **** 
 332              		.loc 1 169 5 is_stmt 1 view .LVU96
 169:Src/mc_tasks_foc.c **** 
 333              		.loc 1 169 34 is_stmt 0 view .LVU97
 334 010e 2868     		ldr	r0, [r5]
 335 0110 FFF7FEFF 		bl	STC_GetDefaultIqdref
 336              	.LVL24:
ARM GAS  /tmp/cccnQOYj.s 			page 18


 169:Src/mc_tasks_foc.c **** 
 337              		.loc 1 169 5 view .LVU98
 338 0114 5246     		mov	r2, r10
 339 0116 01B2     		sxth	r1, r0
 340 0118 4046     		mov	r0, r8
 341 011a FFF7FEFF 		bl	MCI_ExecTorqueRamp
 342              	.LVL25:
 174:Src/mc_tasks_foc.c **** 
 343              		.loc 1 174 1 view .LVU99
 344 011e 05B0     		add	sp, sp, #20
 345              	.LCFI3:
 346              		.cfi_def_cfa_offset 36
 347              		@ sp needed
 348 0120 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 349              	.L9:
 350              		.align	2
 351              	.L8:
 352 0124 00000000 		.word	PWM_Handle_M1
 353 0128 00000000 		.word	PIDSpeedHandle_M1
 354 012c 00000000 		.word	STO_PLL_M1
 355 0130 00000000 		.word	pSTC
 356 0134 00000000 		.word	STO_M1
 357 0138 00000000 		.word	VirtualSpeedSensorM1
 358 013c 00000000 		.word	RevUpControlM1
 359 0140 00000000 		.word	PIDIqHandle_M1
 360 0144 00000000 		.word	PIDIdHandle_M1
 361 0148 00000000 		.word	pMPM
 362 014c 00000000 		.word	FOCVars
 363 0150 00000000 		.word	pFF
 364 0154 00000000 		.word	RampExtMngrHFParamsM1
 365 0158 00000000 		.word	pREMNG
 366 015c 00000000 		.word	SCC
 367 0160 00000000 		.word	CircleLimitationM1
 368 0164 00000000 		.word	pwmcHandle
 369 0168 00000000 		.word	BusVoltageSensor_M1
 370 016c 00000000 		.word	pPIDIq
 371 0170 00000000 		.word	pPIDId
 372 0174 00000000 		.word	Mci
 373 0178 00000000 		.word	SpeednTorqCtrlM1
 374 017c 00000000 		.word	OTT
 375              		.cfi_endproc
 376              	.LFE1867:
 378              		.section	.text.TSK_MF_StopProcessing,"ax",%progbits
 379              		.align	1
 380              		.global	TSK_MF_StopProcessing
 381              		.syntax unified
 382              		.thumb
 383              		.thumb_func
 384              		.fpu fpv4-sp-d16
 386              	TSK_MF_StopProcessing:
 387              	.LVL26:
 388              	.LFB1868:
 181:Src/mc_tasks_foc.c ****     R3_2_SwitchOffPWM(pwmcHandle[motor]);
 389              		.loc 1 181 1 is_stmt 1 view -0
 390              		.cfi_startproc
 391              		@ args = 0, pretend = 0, frame = 0
 392              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/cccnQOYj.s 			page 19


 181:Src/mc_tasks_foc.c ****     R3_2_SwitchOffPWM(pwmcHandle[motor]);
 393              		.loc 1 181 1 is_stmt 0 view .LVU101
 394 0000 10B5     		push	{r4, lr}
 395              	.LCFI4:
 396              		.cfi_def_cfa_offset 8
 397              		.cfi_offset 4, -8
 398              		.cfi_offset 14, -4
 399 0002 0446     		mov	r4, r0
 182:Src/mc_tasks_foc.c **** 
 400              		.loc 1 182 5 is_stmt 1 view .LVU102
 401 0004 0C4B     		ldr	r3, .L12
 402 0006 53F82000 		ldr	r0, [r3, r0, lsl #2]
 403              	.LVL27:
 182:Src/mc_tasks_foc.c **** 
 404              		.loc 1 182 5 is_stmt 0 view .LVU103
 405 000a FFF7FEFF 		bl	R3_2_SwitchOffPWM
 406              	.LVL28:
 184:Src/mc_tasks_foc.c ****   OTT_Stop(&OTT);
 407              		.loc 1 184 3 is_stmt 1 view .LVU104
 408 000e 0B48     		ldr	r0, .L12+4
 409 0010 FFF7FEFF 		bl	SCC_Stop
 410              	.LVL29:
 185:Src/mc_tasks_foc.c ****   FOC_Clear(motor);
 411              		.loc 1 185 3 view .LVU105
 412 0014 0A48     		ldr	r0, .L12+8
 413 0016 FFF7FEFF 		bl	OTT_Stop
 414              	.LVL30:
 186:Src/mc_tasks_foc.c **** 
 415              		.loc 1 186 3 view .LVU106
 416 001a 2046     		mov	r0, r4
 417 001c FFF7FEFF 		bl	FOC_Clear
 418              	.LVL31:
 188:Src/mc_tasks_foc.c ****   Mci[motor].State = STOP;
 419              		.loc 1 188 3 view .LVU107
 420 0020 4FF44870 		mov	r0, #800
 421 0024 FFF7FEFF 		bl	TSK_SetStopPermanencyTimeM1
 422              	.LVL32:
 189:Src/mc_tasks_foc.c **** }
 423              		.loc 1 189 3 view .LVU108
 189:Src/mc_tasks_foc.c **** }
 424              		.loc 1 189 20 is_stmt 0 view .LVU109
 425 0028 0648     		ldr	r0, .L12+12
 426 002a 2C23     		movs	r3, #44
 427 002c 03FB0404 		mla	r4, r3, r4, r0
 428 0030 0823     		movs	r3, #8
 429 0032 E377     		strb	r3, [r4, #31]
 190:Src/mc_tasks_foc.c **** 
 430              		.loc 1 190 1 view .LVU110
 431 0034 10BD     		pop	{r4, pc}
 432              	.L13:
 433 0036 00BF     		.align	2
 434              	.L12:
 435 0038 00000000 		.word	pwmcHandle
 436 003c 00000000 		.word	SCC
 437 0040 00000000 		.word	OTT
 438 0044 00000000 		.word	Mci
 439              		.cfi_endproc
ARM GAS  /tmp/cccnQOYj.s 			page 20


 440              	.LFE1868:
 442              		.section	.text.FOC_InitAdditionalMethods,"ax",%progbits
 443              		.align	1
 444              		.weak	FOC_InitAdditionalMethods
 445              		.syntax unified
 446              		.thumb
 447              		.thumb_func
 448              		.fpu fpv4-sp-d16
 450              	FOC_InitAdditionalMethods:
 451              	.LVL33:
 452              	.LFB1871:
 571:Src/mc_tasks_foc.c **** 
 572:Src/mc_tasks_foc.c **** /**
 573:Src/mc_tasks_foc.c ****   * @brief  Use this method to initialize additional methods (if any) in
 574:Src/mc_tasks_foc.c ****   *         START_TO_RUN state.
 575:Src/mc_tasks_foc.c ****   * @param  bMotor related motor it can be M1 or M2.
 576:Src/mc_tasks_foc.c ****   */
 577:Src/mc_tasks_foc.c **** __weak void FOC_InitAdditionalMethods(uint8_t bMotor) //cstat !RED-func-no-effect
 578:Src/mc_tasks_foc.c **** {
 453              		.loc 1 578 1 is_stmt 1 view -0
 454              		.cfi_startproc
 455              		@ args = 0, pretend = 0, frame = 0
 456              		@ frame_needed = 0, uses_anonymous_args = 0
 579:Src/mc_tasks_foc.c ****     if (M_NONE == bMotor)
 457              		.loc 1 579 5 view .LVU112
 458              		.loc 1 579 8 is_stmt 0 view .LVU113
 459 0000 FF28     		cmp	r0, #255
 460 0002 07D0     		beq	.L17
 578:Src/mc_tasks_foc.c ****     if (M_NONE == bMotor)
 461              		.loc 1 578 1 view .LVU114
 462 0004 08B5     		push	{r3, lr}
 463              	.LCFI5:
 464              		.cfi_def_cfa_offset 8
 465              		.cfi_offset 3, -8
 466              		.cfi_offset 14, -4
 580:Src/mc_tasks_foc.c ****     {
 581:Src/mc_tasks_foc.c ****       /* Nothing to do */
 582:Src/mc_tasks_foc.c ****     }
 583:Src/mc_tasks_foc.c ****     else
 584:Src/mc_tasks_foc.c ****     {
 585:Src/mc_tasks_foc.c ****       if (NULL == pFF[bMotor])
 467              		.loc 1 585 7 is_stmt 1 view .LVU115
 468              		.loc 1 585 22 is_stmt 0 view .LVU116
 469 0006 044B     		ldr	r3, .L20
 470 0008 53F82000 		ldr	r0, [r3, r0, lsl #2]
 471              	.LVL34:
 472              		.loc 1 585 10 view .LVU117
 473 000c 08B1     		cbz	r0, .L14
 586:Src/mc_tasks_foc.c ****       {
 587:Src/mc_tasks_foc.c ****         /* Nothing to do */
 588:Src/mc_tasks_foc.c ****       }
 589:Src/mc_tasks_foc.c ****       else
 590:Src/mc_tasks_foc.c ****       {
 591:Src/mc_tasks_foc.c ****         FF_InitFOCAdditionalMethods(pFF[bMotor]);
 474              		.loc 1 591 9 is_stmt 1 view .LVU118
 475 000e FFF7FEFF 		bl	FF_InitFOCAdditionalMethods
 476              	.LVL35:
ARM GAS  /tmp/cccnQOYj.s 			page 21


 477              	.L14:
 592:Src/mc_tasks_foc.c ****       }
 593:Src/mc_tasks_foc.c ****   /* USER CODE BEGIN FOC_InitAdditionalMethods 0 */
 594:Src/mc_tasks_foc.c **** 
 595:Src/mc_tasks_foc.c ****   /* USER CODE END FOC_InitAdditionalMethods 0 */
 596:Src/mc_tasks_foc.c ****     }
 597:Src/mc_tasks_foc.c **** }
 478              		.loc 1 597 1 is_stmt 0 view .LVU119
 479 0012 08BD     		pop	{r3, pc}
 480              	.LVL36:
 481              	.L17:
 482              	.LCFI6:
 483              		.cfi_def_cfa_offset 0
 484              		.cfi_restore 3
 485              		.cfi_restore 14
 486              		.loc 1 597 1 view .LVU120
 487 0014 7047     		bx	lr
 488              	.L21:
 489 0016 00BF     		.align	2
 490              	.L20:
 491 0018 00000000 		.word	pFF
 492              		.cfi_endproc
 493              	.LFE1871:
 495              		.section	.text.FOC_CalcCurrRef,"ax",%progbits
 496              		.align	1
 497              		.weak	FOC_CalcCurrRef
 498              		.syntax unified
 499              		.thumb
 500              		.thumb_func
 501              		.fpu fpv4-sp-d16
 503              	FOC_CalcCurrRef:
 504              	.LVL37:
 505              	.LFB1872:
 598:Src/mc_tasks_foc.c **** 
 599:Src/mc_tasks_foc.c **** /**
 600:Src/mc_tasks_foc.c ****   * @brief  It computes the new values of Iqdref (current references on qd
 601:Src/mc_tasks_foc.c ****   *         reference frame) based on the required electrical torque information
 602:Src/mc_tasks_foc.c ****   *         provided by oTSC object (internally clocked).
 603:Src/mc_tasks_foc.c ****   *         If implemented in the derived class it executes flux weakening and/or
 604:Src/mc_tasks_foc.c ****   *         MTPA algorithm(s). It must be called with the periodicity specified
 605:Src/mc_tasks_foc.c ****   *         in oTSC parameters.
 606:Src/mc_tasks_foc.c ****   * @param  bMotor related motor it can be M1 or M2.
 607:Src/mc_tasks_foc.c ****   */
 608:Src/mc_tasks_foc.c **** __weak void FOC_CalcCurrRef(uint8_t bMotor)
 609:Src/mc_tasks_foc.c **** {
 506              		.loc 1 609 1 is_stmt 1 view -0
 507              		.cfi_startproc
 508              		@ args = 0, pretend = 0, frame = 8
 509              		@ frame_needed = 0, uses_anonymous_args = 0
 510              		.loc 1 609 1 is_stmt 0 view .LVU122
 511 0000 30B5     		push	{r4, r5, lr}
 512              	.LCFI7:
 513              		.cfi_def_cfa_offset 12
 514              		.cfi_offset 4, -12
 515              		.cfi_offset 5, -8
 516              		.cfi_offset 14, -4
 517 0002 83B0     		sub	sp, sp, #12
ARM GAS  /tmp/cccnQOYj.s 			page 22


 518              	.LCFI8:
 519              		.cfi_def_cfa_offset 24
 520 0004 0446     		mov	r4, r0
 610:Src/mc_tasks_foc.c ****   qd_t IqdTmp;
 521              		.loc 1 610 3 is_stmt 1 view .LVU123
 611:Src/mc_tasks_foc.c **** 
 612:Src/mc_tasks_foc.c ****   /* Enter critical section */
 613:Src/mc_tasks_foc.c ****   /* Disable interrupts to avoid any interruption during Iqd reference latching */
 614:Src/mc_tasks_foc.c ****   /* to avoid MF task writing them while HF task reading them */
 615:Src/mc_tasks_foc.c ****   __disable_irq();
 522              		.loc 1 615 3 view .LVU124
 523              	.LBB17:
 524              	.LBI17:
 525              		.file 2 "Drivers/CMSIS/Include/cmsis_gcc.h"
   1:Drivers/CMSIS/Include/cmsis_gcc.h **** /**************************************************************************//**
   2:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @version  V5.2.0
   5:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @date     08. May 2019
   6:Drivers/CMSIS/Include/cmsis_gcc.h ****  ******************************************************************************/
   7:Drivers/CMSIS/Include/cmsis_gcc.h **** /*
   8:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Copyright (c) 2009-2019 Arm Limited. All rights reserved.
   9:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  10:Drivers/CMSIS/Include/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  12:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:Drivers/CMSIS/Include/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:Drivers/CMSIS/Include/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  16:Drivers/CMSIS/Include/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  18:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:Drivers/CMSIS/Include/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:Drivers/CMSIS/Include/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:Drivers/CMSIS/Include/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:Drivers/CMSIS/Include/cmsis_gcc.h ****  * limitations under the License.
  23:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  24:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  25:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  28:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  34:Drivers/CMSIS/Include/cmsis_gcc.h **** /* Fallback for __has_builtin */
  35:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __has_builtin
  36:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  38:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  39:Drivers/CMSIS/Include/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ASM
  41:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __ASM                                  __asm
  42:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  43:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __INLINE
ARM GAS  /tmp/cccnQOYj.s 			page 23


  44:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __INLINE                               inline
  45:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  46:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
  48:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  49:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_FORCEINLINE                 
  50:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_FORCEINLINE                   __attribute__((always_inline)) static inline
  51:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif                                           
  52:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __NO_RETURN
  53:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((__noreturn__))
  54:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  55:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __USED
  56:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
  57:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  58:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __WEAK
  59:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  60:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  61:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED
  62:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  63:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  64:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  65:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
  66:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  67:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_UNION
  68:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
  69:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  70:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  71:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  72:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  73:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  74:Drivers/CMSIS/Include/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  75:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  76:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  77:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  78:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  79:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  80:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  81:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  82:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  83:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  84:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  85:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  86:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
  87:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  88:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  89:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  90:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  91:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  92:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  93:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  94:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
  95:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  96:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  97:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  98:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  99:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 100:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
ARM GAS  /tmp/cccnQOYj.s 			page 24


 101:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 102:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
 103:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
 104:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
 105:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 106:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 107:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 108:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 109:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 110:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ALIGNED
 111:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 112:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 113:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __RESTRICT
 114:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 115:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 116:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __COMPILER_BARRIER
 117:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __COMPILER_BARRIER()                   __ASM volatile("":::"memory")
 118:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 119:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 120:Drivers/CMSIS/Include/cmsis_gcc.h **** /* #########################  Startup and Lowlevel Init  ######################## */
 121:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 122:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __PROGRAM_START
 123:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 124:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 125:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Initializes data and bss sections
 126:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details This default implementations initialized all data and additional bss
 127:Drivers/CMSIS/Include/cmsis_gcc.h ****            sections relying on .copy.table and .zero.table specified properly
 128:Drivers/CMSIS/Include/cmsis_gcc.h ****            in the used linker script.
 129:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 130:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 131:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE __NO_RETURN void __cmsis_start(void)
 132:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 133:Drivers/CMSIS/Include/cmsis_gcc.h ****   extern void _start(void) __NO_RETURN;
 134:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 135:Drivers/CMSIS/Include/cmsis_gcc.h ****   typedef struct {
 136:Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t const* src;
 137:Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t* dest;
 138:Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t  wlen;
 139:Drivers/CMSIS/Include/cmsis_gcc.h ****   } __copy_table_t;
 140:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 141:Drivers/CMSIS/Include/cmsis_gcc.h ****   typedef struct {
 142:Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t* dest;
 143:Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t  wlen;
 144:Drivers/CMSIS/Include/cmsis_gcc.h ****   } __zero_table_t;
 145:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 146:Drivers/CMSIS/Include/cmsis_gcc.h ****   extern const __copy_table_t __copy_table_start__;
 147:Drivers/CMSIS/Include/cmsis_gcc.h ****   extern const __copy_table_t __copy_table_end__;
 148:Drivers/CMSIS/Include/cmsis_gcc.h ****   extern const __zero_table_t __zero_table_start__;
 149:Drivers/CMSIS/Include/cmsis_gcc.h ****   extern const __zero_table_t __zero_table_end__;
 150:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 151:Drivers/CMSIS/Include/cmsis_gcc.h ****   for (__copy_table_t const* pTable = &__copy_table_start__; pTable < &__copy_table_end__; ++pTable
 152:Drivers/CMSIS/Include/cmsis_gcc.h ****     for(uint32_t i=0u; i<pTable->wlen; ++i) {
 153:Drivers/CMSIS/Include/cmsis_gcc.h ****       pTable->dest[i] = pTable->src[i];
 154:Drivers/CMSIS/Include/cmsis_gcc.h ****     }
 155:Drivers/CMSIS/Include/cmsis_gcc.h ****   }
 156:Drivers/CMSIS/Include/cmsis_gcc.h ****  
 157:Drivers/CMSIS/Include/cmsis_gcc.h ****   for (__zero_table_t const* pTable = &__zero_table_start__; pTable < &__zero_table_end__; ++pTable
ARM GAS  /tmp/cccnQOYj.s 			page 25


 158:Drivers/CMSIS/Include/cmsis_gcc.h ****     for(uint32_t i=0u; i<pTable->wlen; ++i) {
 159:Drivers/CMSIS/Include/cmsis_gcc.h ****       pTable->dest[i] = 0u;
 160:Drivers/CMSIS/Include/cmsis_gcc.h ****     }
 161:Drivers/CMSIS/Include/cmsis_gcc.h ****   }
 162:Drivers/CMSIS/Include/cmsis_gcc.h ****  
 163:Drivers/CMSIS/Include/cmsis_gcc.h ****   _start();
 164:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 165:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 166:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __PROGRAM_START           __cmsis_start
 167:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 168:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 169:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __INITIAL_SP
 170:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __INITIAL_SP              __StackTop
 171:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 172:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 173:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __STACK_LIMIT
 174:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __STACK_LIMIT             __StackLimit
 175:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 176:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 177:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __VECTOR_TABLE
 178:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __VECTOR_TABLE            __Vectors
 179:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 180:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 181:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __VECTOR_TABLE_ATTRIBUTE
 182:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __VECTOR_TABLE_ATTRIBUTE  __attribute((used, section(".vectors")))
 183:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 184:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 185:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
 186:Drivers/CMSIS/Include/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 187:Drivers/CMSIS/Include/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 188:Drivers/CMSIS/Include/cmsis_gcc.h ****   @{
 189:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 190:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 191:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 192:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
 193:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
 194:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 195:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 196:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_irq(void)
 197:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 198:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 199:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 200:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 201:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 202:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 203:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 204:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
 205:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 206:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 207:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_irq(void)
 526              		.loc 2 207 27 view .LVU125
 527              	.LBB18:
 208:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 209:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 528              		.loc 2 209 3 view .LVU126
 529              		.syntax unified
 530              	@ 209 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
ARM GAS  /tmp/cccnQOYj.s 			page 26


 531 0006 72B6     		cpsid i
 532              	@ 0 "" 2
 533              		.thumb
 534              		.syntax unified
 535              	.LBE18:
 536              	.LBE17:
 616:Src/mc_tasks_foc.c ****   IqdTmp = FOCVars[bMotor].Iqdref;
 537              		.loc 1 616 3 view .LVU127
 538              		.loc 1 616 10 is_stmt 0 view .LVU128
 539 0008 184B     		ldr	r3, .L26
 540 000a 2622     		movs	r2, #38
 541 000c 02FB0033 		mla	r3, r2, r0, r3
 542 0010 1869     		ldr	r0, [r3, #16]	@ unaligned
 543              	.LVL38:
 544              		.loc 1 616 10 view .LVU129
 545 0012 0190     		str	r0, [sp, #4]
 546 0014 B3F91050 		ldrsh	r5, [r3, #16]
 547              	.LVL39:
 617:Src/mc_tasks_foc.c **** 
 618:Src/mc_tasks_foc.c ****   /* Exit critical section */
 619:Src/mc_tasks_foc.c ****   __enable_irq();
 548              		.loc 1 619 3 is_stmt 1 view .LVU130
 549              	.LBB19:
 550              	.LBI19:
 196:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 551              		.loc 2 196 27 view .LVU131
 552              	.LBB20:
 198:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 553              		.loc 2 198 3 view .LVU132
 554              		.syntax unified
 555              	@ 198 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 556 0018 62B6     		cpsie i
 557              	@ 0 "" 2
 558              		.thumb
 559              		.syntax unified
 560              	.LBE20:
 561              	.LBE19:
 620:Src/mc_tasks_foc.c **** 
 621:Src/mc_tasks_foc.c ****   /* USER CODE BEGIN FOC_CalcCurrRef 0 */
 622:Src/mc_tasks_foc.c **** 
 623:Src/mc_tasks_foc.c ****   /* USER CODE END FOC_CalcCurrRef 0 */
 624:Src/mc_tasks_foc.c ****   if (INTERNAL == FOCVars[bMotor].bDriveInput)
 562              		.loc 1 624 3 view .LVU133
 563              		.loc 1 624 6 is_stmt 0 view .LVU134
 564 001a 93F82430 		ldrb	r3, [r3, #36]	@ zero_extendqisi2
 565 001e 5BB1     		cbz	r3, .L25
 566              	.LVL40:
 567              	.L23:
 625:Src/mc_tasks_foc.c ****   {
 626:Src/mc_tasks_foc.c ****     FOCVars[bMotor].hTeref = STC_CalcTorqueReference(pSTC[bMotor]);
 627:Src/mc_tasks_foc.c ****     IqdTmp.q = FOCVars[bMotor].hTeref;
 628:Src/mc_tasks_foc.c **** 
 629:Src/mc_tasks_foc.c ****     if (NULL == pFF[bMotor])
 630:Src/mc_tasks_foc.c ****     {
 631:Src/mc_tasks_foc.c ****       /* Nothing to do */
 632:Src/mc_tasks_foc.c ****     }
 633:Src/mc_tasks_foc.c ****     else
ARM GAS  /tmp/cccnQOYj.s 			page 27


 634:Src/mc_tasks_foc.c ****     {
 635:Src/mc_tasks_foc.c ****       FF_VqdffComputation(pFF[bMotor], IqdTmp, pSTC[bMotor]);
 636:Src/mc_tasks_foc.c ****     }
 637:Src/mc_tasks_foc.c ****   }
 638:Src/mc_tasks_foc.c ****   else
 639:Src/mc_tasks_foc.c ****   {
 640:Src/mc_tasks_foc.c ****     /* Nothing to do */
 641:Src/mc_tasks_foc.c ****   }
 568              		.loc 1 641 3 is_stmt 1 view .LVU135
 642:Src/mc_tasks_foc.c **** 
 643:Src/mc_tasks_foc.c ****   /* Enter critical section */
 644:Src/mc_tasks_foc.c ****   /* Disable interrupts to avoid any interruption during Iqd reference restoring */
 645:Src/mc_tasks_foc.c ****   __disable_irq();
 569              		.loc 1 645 3 view .LVU136
 570              	.LBB21:
 571              	.LBI21:
 207:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 572              		.loc 2 207 27 view .LVU137
 573              	.LBB22:
 574              		.loc 2 209 3 view .LVU138
 575              		.syntax unified
 576              	@ 209 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 577 0020 72B6     		cpsid i
 578              	@ 0 "" 2
 579              		.thumb
 580              		.syntax unified
 581              	.LBE22:
 582              	.LBE21:
 646:Src/mc_tasks_foc.c ****   FOCVars[bMotor].Iqdref = IqdTmp;
 583              		.loc 1 646 3 view .LVU139
 584              		.loc 1 646 26 is_stmt 0 view .LVU140
 585 0022 ADF80450 		strh	r5, [sp, #4]	@ movhi
 586 0026 1148     		ldr	r0, .L26
 587 0028 2623     		movs	r3, #38
 588 002a 03FB0404 		mla	r4, r3, r4, r0
 589 002e 0198     		ldr	r0, [sp, #4]
 590 0030 2061     		str	r0, [r4, #16]	@ unaligned
 647:Src/mc_tasks_foc.c **** 
 648:Src/mc_tasks_foc.c ****   /* Exit critical section */
 649:Src/mc_tasks_foc.c ****   __enable_irq();
 591              		.loc 1 649 3 is_stmt 1 view .LVU141
 592              	.LBB23:
 593              	.LBI23:
 196:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 594              		.loc 2 196 27 view .LVU142
 595              	.LBB24:
 198:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 596              		.loc 2 198 3 view .LVU143
 597              		.syntax unified
 598              	@ 198 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 599 0032 62B6     		cpsie i
 600              	@ 0 "" 2
 601              	.LVL41:
 198:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 602              		.loc 2 198 3 is_stmt 0 view .LVU144
 603              		.thumb
 604              		.syntax unified
ARM GAS  /tmp/cccnQOYj.s 			page 28


 605              	.LBE24:
 606              	.LBE23:
 650:Src/mc_tasks_foc.c ****   /* USER CODE BEGIN FOC_CalcCurrRef 1 */
 651:Src/mc_tasks_foc.c **** 
 652:Src/mc_tasks_foc.c ****   /* USER CODE END FOC_CalcCurrRef 1 */
 653:Src/mc_tasks_foc.c **** }
 607              		.loc 1 653 1 view .LVU145
 608 0034 03B0     		add	sp, sp, #12
 609              	.LCFI9:
 610              		.cfi_remember_state
 611              		.cfi_def_cfa_offset 12
 612              		@ sp needed
 613 0036 30BD     		pop	{r4, r5, pc}
 614              	.LVL42:
 615              	.L25:
 616              	.LCFI10:
 617              		.cfi_restore_state
 626:Src/mc_tasks_foc.c ****     IqdTmp.q = FOCVars[bMotor].hTeref;
 618              		.loc 1 626 5 is_stmt 1 view .LVU146
 626:Src/mc_tasks_foc.c ****     IqdTmp.q = FOCVars[bMotor].hTeref;
 619              		.loc 1 626 30 is_stmt 0 view .LVU147
 620 0038 0D4B     		ldr	r3, .L26+4
 621 003a 53F82400 		ldr	r0, [r3, r4, lsl #2]
 622 003e FFF7FEFF 		bl	STC_CalcTorqueReference
 623              	.LVL43:
 624 0042 0546     		mov	r5, r0
 625              	.LVL44:
 626:Src/mc_tasks_foc.c ****     IqdTmp.q = FOCVars[bMotor].hTeref;
 626              		.loc 1 626 28 view .LVU148
 627 0044 094B     		ldr	r3, .L26
 628 0046 2622     		movs	r2, #38
 629 0048 02FB0433 		mla	r3, r2, r4, r3
 630 004c D883     		strh	r0, [r3, #30]	@ movhi
 627:Src/mc_tasks_foc.c **** 
 631              		.loc 1 627 5 is_stmt 1 view .LVU149
 632              	.LVL45:
 629:Src/mc_tasks_foc.c ****     {
 633              		.loc 1 629 5 view .LVU150
 629:Src/mc_tasks_foc.c ****     {
 634              		.loc 1 629 20 is_stmt 0 view .LVU151
 635 004e 094B     		ldr	r3, .L26+8
 636 0050 53F82400 		ldr	r0, [r3, r4, lsl #2]
 629:Src/mc_tasks_foc.c ****     {
 637              		.loc 1 629 8 view .LVU152
 638 0054 0028     		cmp	r0, #0
 639 0056 E3D0     		beq	.L23
 635:Src/mc_tasks_foc.c ****     }
 640              		.loc 1 635 7 is_stmt 1 view .LVU153
 635:Src/mc_tasks_foc.c ****     }
 641              		.loc 1 635 7 is_stmt 0 view .LVU154
 642 0058 ADF80450 		strh	r5, [sp, #4]	@ movhi
 643 005c 044B     		ldr	r3, .L26+4
 644 005e 53F82420 		ldr	r2, [r3, r4, lsl #2]
 645 0062 0199     		ldr	r1, [sp, #4]
 646 0064 FFF7FEFF 		bl	FF_VqdffComputation
 647              	.LVL46:
 648 0068 DAE7     		b	.L23
ARM GAS  /tmp/cccnQOYj.s 			page 29


 649              	.L27:
 650 006a 00BF     		.align	2
 651              	.L26:
 652 006c 00000000 		.word	FOCVars
 653 0070 00000000 		.word	pSTC
 654 0074 00000000 		.word	pFF
 655              		.cfi_endproc
 656              	.LFE1872:
 658              		.section	.text.TSK_MediumFrequencyTaskM1,"ax",%progbits
 659              		.align	1
 660              		.weak	TSK_MediumFrequencyTaskM1
 661              		.syntax unified
 662              		.thumb
 663              		.thumb_func
 664              		.fpu fpv4-sp-d16
 666              	TSK_MediumFrequencyTaskM1:
 667              	.LFB1869:
 201:Src/mc_tasks_foc.c ****   /* USER CODE BEGIN MediumFrequencyTask M1 0 */
 668              		.loc 1 201 1 is_stmt 1 view -0
 669              		.cfi_startproc
 670              		@ args = 0, pretend = 0, frame = 16
 671              		@ frame_needed = 0, uses_anonymous_args = 0
 672 0000 70B5     		push	{r4, r5, r6, lr}
 673              	.LCFI11:
 674              		.cfi_def_cfa_offset 16
 675              		.cfi_offset 4, -16
 676              		.cfi_offset 5, -12
 677              		.cfi_offset 6, -8
 678              		.cfi_offset 14, -4
 679 0002 84B0     		sub	sp, sp, #16
 680              	.LCFI12:
 681              		.cfi_def_cfa_offset 32
 206:Src/mc_tasks_foc.c ****   bool IsSpeedReliable = STO_PLL_CalcAvrgMecSpeedUnit(&STO_PLL_M1, &wAux);
 682              		.loc 1 206 3 view .LVU156
 206:Src/mc_tasks_foc.c ****   bool IsSpeedReliable = STO_PLL_CalcAvrgMecSpeedUnit(&STO_PLL_M1, &wAux);
 683              		.loc 1 206 11 is_stmt 0 view .LVU157
 684 0004 0023     		movs	r3, #0
 685 0006 ADF80E30 		strh	r3, [sp, #14]	@ movhi
 207:Src/mc_tasks_foc.c ****   PQD_CalcElMotorPower(pMPM[M1]);
 686              		.loc 1 207 3 is_stmt 1 view .LVU158
 207:Src/mc_tasks_foc.c ****   PQD_CalcElMotorPower(pMPM[M1]);
 687              		.loc 1 207 26 is_stmt 0 view .LVU159
 688 000a 0DF10E01 		add	r1, sp, #14
 689 000e B348     		ldr	r0, .L68
 690 0010 FFF7FEFF 		bl	STO_PLL_CalcAvrgMecSpeedUnit
 691              	.LVL47:
 692 0014 0446     		mov	r4, r0
 693              	.LVL48:
 208:Src/mc_tasks_foc.c **** 
 694              		.loc 1 208 3 is_stmt 1 view .LVU160
 695 0016 B24B     		ldr	r3, .L68+4
 696 0018 1868     		ldr	r0, [r3]
 697 001a FFF7FEFF 		bl	PQD_CalcElMotorPower
 698              	.LVL49:
 210:Src/mc_tasks_foc.c ****   {
 699              		.loc 1 210 3 view .LVU161
 210:Src/mc_tasks_foc.c ****   {
ARM GAS  /tmp/cccnQOYj.s 			page 30


 700              		.loc 1 210 7 is_stmt 0 view .LVU162
 701 001e B148     		ldr	r0, .L68+8
 702 0020 FFF7FEFF 		bl	MCI_GetCurrentFaults
 703              	.LVL50:
 210:Src/mc_tasks_foc.c ****   {
 704              		.loc 1 210 6 view .LVU163
 705 0024 38B1     		cbz	r0, .L58
 516:Src/mc_tasks_foc.c ****   }
 706              		.loc 1 516 5 is_stmt 1 view .LVU164
 516:Src/mc_tasks_foc.c ****   }
 707              		.loc 1 516 19 is_stmt 0 view .LVU165
 708 0026 AF4B     		ldr	r3, .L68+8
 709 0028 0A22     		movs	r2, #10
 710 002a DA77     		strb	r2, [r3, #31]
 711              	.LVL51:
 712              	.L31:
 518:Src/mc_tasks_foc.c ****   /* USER CODE BEGIN MediumFrequencyTask M1 6 */
 713              		.loc 1 518 3 is_stmt 1 view .LVU166
 714 002c AE48     		ldr	r0, .L68+12
 715 002e FFF7FEFF 		bl	SCC_MF
 716              	.LVL52:
 522:Src/mc_tasks_foc.c **** 
 717              		.loc 1 522 1 is_stmt 0 view .LVU167
 718 0032 04B0     		add	sp, sp, #16
 719              	.LCFI13:
 720              		.cfi_remember_state
 721              		.cfi_def_cfa_offset 16
 722              		@ sp needed
 723 0034 70BD     		pop	{r4, r5, r6, pc}
 724              	.LVL53:
 725              	.L58:
 726              	.LCFI14:
 727              		.cfi_restore_state
 212:Src/mc_tasks_foc.c ****     {
 728              		.loc 1 212 5 is_stmt 1 view .LVU168
 212:Src/mc_tasks_foc.c ****     {
 729              		.loc 1 212 9 is_stmt 0 view .LVU169
 730 0036 AB48     		ldr	r0, .L68+8
 731 0038 FFF7FEFF 		bl	MCI_GetOccurredFaults
 732              	.LVL54:
 212:Src/mc_tasks_foc.c ****     {
 733              		.loc 1 212 8 view .LVU170
 734 003c 0028     		cmp	r0, #0
 735 003e 40F0AE81 		bne	.L30
 214:Src/mc_tasks_foc.c ****       {
 736              		.loc 1 214 7 is_stmt 1 view .LVU171
 214:Src/mc_tasks_foc.c ****       {
 737              		.loc 1 214 22 is_stmt 0 view .LVU172
 738 0042 A84B     		ldr	r3, .L68+8
 739 0044 DB7F     		ldrb	r3, [r3, #31]	@ zero_extendqisi2
 740 0046 142B     		cmp	r3, #20
 741 0048 F0D8     		bhi	.L31
 742 004a 01A2     		adr	r2, .L33
 743 004c 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 744              		.p2align 2
 745              	.L33:
 746 0050 A5000000 		.word	.L42+1
ARM GAS  /tmp/cccnQOYj.s 			page 31


 747 0054 2D000000 		.word	.L31+1
 748 0058 2D000000 		.word	.L31+1
 749 005c 2D000000 		.word	.L31+1
 750 0060 9D010000 		.word	.L41+1
 751 0064 2D000000 		.word	.L31+1
 752 0068 AB020000 		.word	.L40+1
 753 006c 2D000000 		.word	.L31+1
 754 0070 0D030000 		.word	.L39+1
 755 0074 2D000000 		.word	.L31+1
 756 0078 47030000 		.word	.L38+1
 757 007c 33030000 		.word	.L37+1
 758 0080 2D000000 		.word	.L31+1
 759 0084 2D000000 		.word	.L31+1
 760 0088 2D000000 		.word	.L31+1
 761 008c 2D000000 		.word	.L31+1
 762 0090 3D010000 		.word	.L36+1
 763 0094 FF000000 		.word	.L35+1
 764 0098 2D000000 		.word	.L31+1
 765 009c 37020000 		.word	.L34+1
 766 00a0 4F030000 		.word	.L32+1
 767              		.p2align 1
 768              	.L42:
 219:Src/mc_tasks_foc.c ****           {
 769              		.loc 1 219 11 is_stmt 1 view .LVU173
 219:Src/mc_tasks_foc.c ****           {
 770              		.loc 1 219 36 is_stmt 0 view .LVU174
 771 00a4 8F4B     		ldr	r3, .L68+8
 219:Src/mc_tasks_foc.c ****           {
 772              		.loc 1 219 14 view .LVU175
 773 00a6 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 774 00a8 03F0FD03 		and	r3, r3, #253
 775 00ac 012B     		cmp	r3, #1
 776 00ae BDD1     		bne	.L31
 221:Src/mc_tasks_foc.c ****             if (pwmcHandle[M1]->offsetCalibStatus == false)
 777              		.loc 1 221 15 is_stmt 1 view .LVU176
 778 00b0 8C48     		ldr	r0, .L68+8
 779 00b2 FFF7FEFF 		bl	MCI_GetImposedMotorDirection
 780              	.LVL55:
 781 00b6 0146     		mov	r1, r0
 782 00b8 8C48     		ldr	r0, .L68+16
 783 00ba FFF7FEFF 		bl	RUC_Clear
 784              	.LVL56:
 222:Src/mc_tasks_foc.c ****             {
 785              		.loc 1 222 13 view .LVU177
 222:Src/mc_tasks_foc.c ****             {
 786              		.loc 1 222 27 is_stmt 0 view .LVU178
 787 00be 8C4B     		ldr	r3, .L68+20
 788 00c0 1868     		ldr	r0, [r3]
 222:Src/mc_tasks_foc.c ****             {
 789              		.loc 1 222 16 view .LVU179
 790 00c2 90F87F30 		ldrb	r3, [r0, #127]	@ zero_extendqisi2
 791 00c6 4BB9     		cbnz	r3, .L43
 224:Src/mc_tasks_foc.c ****               Mci[M1].State = OFFSET_CALIB;
 792              		.loc 1 224 15 is_stmt 1 view .LVU180
 224:Src/mc_tasks_foc.c ****               Mci[M1].State = OFFSET_CALIB;
 793              		.loc 1 224 21 is_stmt 0 view .LVU181
 794 00c8 0021     		movs	r1, #0
ARM GAS  /tmp/cccnQOYj.s 			page 32


 795 00ca FFF7FEFF 		bl	PWMC_CurrentReadingCalibr
 796              	.LVL57:
 225:Src/mc_tasks_foc.c ****             }
 797              		.loc 1 225 15 is_stmt 1 view .LVU182
 225:Src/mc_tasks_foc.c ****             }
 798              		.loc 1 225 29 is_stmt 0 view .LVU183
 799 00ce 854B     		ldr	r3, .L68+8
 800 00d0 1122     		movs	r2, #17
 801 00d2 DA77     		strb	r2, [r3, #31]
 802              	.L44:
 236:Src/mc_tasks_foc.c ****           }
 803              		.loc 1 236 13 is_stmt 1 view .LVU184
 804 00d4 8748     		ldr	r0, .L68+24
 805 00d6 FFF7FEFF 		bl	OTT_Clear
 806              	.LVL58:
 807 00da A7E7     		b	.L31
 808              	.L43:
 230:Src/mc_tasks_foc.c ****               (void)PWMC_CurrentReadingCalibr(pwmcHandle[M1], CRC_EXEC);
 809              		.loc 1 230 15 view .LVU185
 230:Src/mc_tasks_foc.c ****               (void)PWMC_CurrentReadingCalibr(pwmcHandle[M1], CRC_EXEC);
 810              		.loc 1 230 56 is_stmt 0 view .LVU186
 811 00dc 0121     		movs	r1, #1
 812 00de A0F86010 		strh	r1, [r0, #96]	@ movhi
 231:Src/mc_tasks_foc.c ****               R3_2_TurnOnLowSides(pwmcHandle[M1],M1_CHARGE_BOOT_CAP_DUTY_CYCLES);
 813              		.loc 1 231 15 is_stmt 1 view .LVU187
 231:Src/mc_tasks_foc.c ****               R3_2_TurnOnLowSides(pwmcHandle[M1],M1_CHARGE_BOOT_CAP_DUTY_CYCLES);
 814              		.loc 1 231 21 is_stmt 0 view .LVU188
 815 00e2 FFF7FEFF 		bl	PWMC_CurrentReadingCalibr
 816              	.LVL59:
 232:Src/mc_tasks_foc.c ****               TSK_SetChargeBootCapDelayM1(M1_CHARGE_BOOT_CAP_TICKS);
 817              		.loc 1 232 15 is_stmt 1 view .LVU189
 818 00e6 0021     		movs	r1, #0
 819 00e8 814B     		ldr	r3, .L68+20
 820 00ea 1868     		ldr	r0, [r3]
 821 00ec FFF7FEFF 		bl	R3_2_TurnOnLowSides
 822              	.LVL60:
 233:Src/mc_tasks_foc.c ****               Mci[M1].State = CHARGE_BOOT_CAP;
 823              		.loc 1 233 15 view .LVU190
 824 00f0 1420     		movs	r0, #20
 825 00f2 FFF7FEFF 		bl	TSK_SetChargeBootCapDelayM1
 826              	.LVL61:
 234:Src/mc_tasks_foc.c ****             }
 827              		.loc 1 234 15 view .LVU191
 234:Src/mc_tasks_foc.c ****             }
 828              		.loc 1 234 29 is_stmt 0 view .LVU192
 829 00f6 7B4B     		ldr	r3, .L68+8
 830 00f8 1022     		movs	r2, #16
 831 00fa DA77     		strb	r2, [r3, #31]
 832 00fc EAE7     		b	.L44
 833              	.L35:
 247:Src/mc_tasks_foc.c ****           {
 834              		.loc 1 247 11 is_stmt 1 view .LVU193
 247:Src/mc_tasks_foc.c ****           {
 835              		.loc 1 247 34 is_stmt 0 view .LVU194
 836 00fe 794B     		ldr	r3, .L68+8
 247:Src/mc_tasks_foc.c ****           {
 837              		.loc 1 247 14 view .LVU195
ARM GAS  /tmp/cccnQOYj.s 			page 33


 838 0100 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 839 0102 052B     		cmp	r3, #5
 840 0104 0ED0     		beq	.L59
 253:Src/mc_tasks_foc.c ****             {
 841              		.loc 1 253 13 is_stmt 1 view .LVU196
 253:Src/mc_tasks_foc.c ****             {
 842              		.loc 1 253 17 is_stmt 0 view .LVU197
 843 0106 0121     		movs	r1, #1
 844 0108 794B     		ldr	r3, .L68+20
 845 010a 1868     		ldr	r0, [r3]
 846 010c FFF7FEFF 		bl	PWMC_CurrentReadingCalibr
 847              	.LVL62:
 253:Src/mc_tasks_foc.c ****             {
 848              		.loc 1 253 16 view .LVU198
 849 0110 0028     		cmp	r0, #0
 850 0112 8BD0     		beq	.L31
 255:Src/mc_tasks_foc.c ****               {
 851              		.loc 1 255 15 is_stmt 1 view .LVU199
 255:Src/mc_tasks_foc.c ****               {
 852              		.loc 1 255 49 is_stmt 0 view .LVU200
 853 0114 734B     		ldr	r3, .L68+8
 255:Src/mc_tasks_foc.c ****               {
 854              		.loc 1 255 18 view .LVU201
 855 0116 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 856 0118 032B     		cmp	r3, #3
 857 011a 07D0     		beq	.L60
 263:Src/mc_tasks_foc.c ****               }
 858              		.loc 1 263 17 is_stmt 1 view .LVU202
 263:Src/mc_tasks_foc.c ****               }
 859              		.loc 1 263 31 is_stmt 0 view .LVU203
 860 011c 714B     		ldr	r3, .L68+8
 861 011e 1422     		movs	r2, #20
 862 0120 DA77     		strb	r2, [r3, #31]
 863 0122 83E7     		b	.L31
 864              	.L59:
 249:Src/mc_tasks_foc.c ****           }
 865              		.loc 1 249 13 is_stmt 1 view .LVU204
 866 0124 0020     		movs	r0, #0
 867 0126 FFF7FEFF 		bl	TSK_MF_StopProcessing
 868              	.LVL63:
 869 012a 7FE7     		b	.L31
 870              	.L60:
 257:Src/mc_tasks_foc.c ****                 Mci[M1].DirectCommand = MCI_NO_COMMAND;
 871              		.loc 1 257 17 view .LVU205
 872 012c 0020     		movs	r0, #0
 873 012e FFF7FEFF 		bl	FOC_Clear
 874              	.LVL64:
 258:Src/mc_tasks_foc.c ****                 Mci[M1].State = IDLE;
 875              		.loc 1 258 17 view .LVU206
 258:Src/mc_tasks_foc.c ****                 Mci[M1].State = IDLE;
 876              		.loc 1 258 39 is_stmt 0 view .LVU207
 877 0132 6C4B     		ldr	r3, .L68+8
 878 0134 0022     		movs	r2, #0
 879 0136 9A77     		strb	r2, [r3, #30]
 259:Src/mc_tasks_foc.c ****               }
 880              		.loc 1 259 17 is_stmt 1 view .LVU208
 259:Src/mc_tasks_foc.c ****               }
ARM GAS  /tmp/cccnQOYj.s 			page 34


 881              		.loc 1 259 31 is_stmt 0 view .LVU209
 882 0138 DA77     		strb	r2, [r3, #31]
 883 013a 77E7     		b	.L31
 884              	.L36:
 276:Src/mc_tasks_foc.c ****           {
 885              		.loc 1 276 11 is_stmt 1 view .LVU210
 276:Src/mc_tasks_foc.c ****           {
 886              		.loc 1 276 34 is_stmt 0 view .LVU211
 887 013c 694B     		ldr	r3, .L68+8
 276:Src/mc_tasks_foc.c ****           {
 888              		.loc 1 276 14 view .LVU212
 889 013e 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 890 0140 052B     		cmp	r3, #5
 891 0142 27D0     		beq	.L61
 282:Src/mc_tasks_foc.c ****             {
 892              		.loc 1 282 13 is_stmt 1 view .LVU213
 282:Src/mc_tasks_foc.c ****             {
 893              		.loc 1 282 17 is_stmt 0 view .LVU214
 894 0144 FFF7FEFF 		bl	TSK_ChargeBootCapDelayHasElapsedM1
 895              	.LVL65:
 282:Src/mc_tasks_foc.c ****             {
 896              		.loc 1 282 16 view .LVU215
 897 0148 0028     		cmp	r0, #0
 898 014a 3FF46FAF 		beq	.L31
 284:Src/mc_tasks_foc.c ****               FOCVars[M1].bDriveInput = EXTERNAL;
 899              		.loc 1 284 15 is_stmt 1 view .LVU216
 900 014e 684C     		ldr	r4, .L68+20
 901              	.LVL66:
 284:Src/mc_tasks_foc.c ****               FOCVars[M1].bDriveInput = EXTERNAL;
 902              		.loc 1 284 15 is_stmt 0 view .LVU217
 903 0150 2068     		ldr	r0, [r4]
 904 0152 FFF7FEFF 		bl	R3_2_SwitchOffPWM
 905              	.LVL67:
 285:Src/mc_tasks_foc.c ****               STC_SetSpeedSensor( pSTC[M1], &VirtualSpeedSensorM1._Super );
 906              		.loc 1 285 15 is_stmt 1 view .LVU218
 285:Src/mc_tasks_foc.c ****               STC_SetSpeedSensor( pSTC[M1], &VirtualSpeedSensorM1._Super );
 907              		.loc 1 285 39 is_stmt 0 view .LVU219
 908 0156 684B     		ldr	r3, .L68+28
 909 0158 0122     		movs	r2, #1
 910 015a 83F82420 		strb	r2, [r3, #36]
 286:Src/mc_tasks_foc.c **** 
 911              		.loc 1 286 15 is_stmt 1 view .LVU220
 912 015e 6749     		ldr	r1, .L68+32
 913 0160 674B     		ldr	r3, .L68+36
 914 0162 1868     		ldr	r0, [r3]
 915 0164 FFF7FEFF 		bl	STC_SetSpeedSensor
 916              	.LVL68:
 288:Src/mc_tasks_foc.c ****               PWMC_Clear(pwmcHandle[M1]);
 917              		.loc 1 288 15 view .LVU221
 918 0168 5C48     		ldr	r0, .L68
 919 016a FFF7FEFF 		bl	STO_PLL_Clear
 920              	.LVL69:
 289:Src/mc_tasks_foc.c **** 
 921              		.loc 1 289 15 view .LVU222
 922 016e 2068     		ldr	r0, [r4]
 923 0170 FFF7FEFF 		bl	PWMC_Clear
 924              	.LVL70:
ARM GAS  /tmp/cccnQOYj.s 			page 35


 291:Src/mc_tasks_foc.c **** 
 925              		.loc 1 291 15 view .LVU223
 926 0174 0020     		movs	r0, #0
 927 0176 FFF7FEFF 		bl	FOC_Clear
 928              	.LVL71:
 293:Src/mc_tasks_foc.c ****               /* The generic function needs to be called here as the undelying
 929              		.loc 1 293 9 view .LVU224
 930 017a 5B48     		ldr	r0, .L68+12
 931 017c FFF7FEFF 		bl	SCC_Start
 932              	.LVL72:
 298:Src/mc_tasks_foc.c ****               Mci[M1].State = START;
 933              		.loc 1 298 15 view .LVU225
 934 0180 2068     		ldr	r0, [r4]
 935 0182 FFF7FEFF 		bl	PWMC_SwitchOnPWM
 936              	.LVL73:
 299:Src/mc_tasks_foc.c ****               PWMC_SwitchOnPWM(pwmcHandle[M1]);
 937              		.loc 1 299 15 view .LVU226
 299:Src/mc_tasks_foc.c ****               PWMC_SwitchOnPWM(pwmcHandle[M1]);
 938              		.loc 1 299 29 is_stmt 0 view .LVU227
 939 0186 574B     		ldr	r3, .L68+8
 940 0188 0422     		movs	r2, #4
 941 018a DA77     		strb	r2, [r3, #31]
 300:Src/mc_tasks_foc.c ****             }
 942              		.loc 1 300 15 is_stmt 1 view .LVU228
 943 018c 2068     		ldr	r0, [r4]
 944 018e FFF7FEFF 		bl	PWMC_SwitchOnPWM
 945              	.LVL74:
 946 0192 4BE7     		b	.L31
 947              	.LVL75:
 948              	.L61:
 278:Src/mc_tasks_foc.c ****           }
 949              		.loc 1 278 13 view .LVU229
 950 0194 0020     		movs	r0, #0
 951 0196 FFF7FEFF 		bl	TSK_MF_StopProcessing
 952              	.LVL76:
 953 019a 47E7     		b	.L31
 954              	.L41:
 312:Src/mc_tasks_foc.c ****           {
 955              		.loc 1 312 11 view .LVU230
 312:Src/mc_tasks_foc.c ****           {
 956              		.loc 1 312 34 is_stmt 0 view .LVU231
 957 019c 514B     		ldr	r3, .L68+8
 312:Src/mc_tasks_foc.c ****           {
 958              		.loc 1 312 14 view .LVU232
 959 019e 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 960 01a0 052B     		cmp	r3, #5
 961 01a2 3AD0     		beq	.L62
 962              	.LBB25:
 319:Src/mc_tasks_foc.c ****             qd_t IqdRef;
 963              		.loc 1 319 13 is_stmt 1 view .LVU233
 320:Src/mc_tasks_foc.c ****             bool ObserverConverged;
 964              		.loc 1 320 13 view .LVU234
 321:Src/mc_tasks_foc.c **** 
 965              		.loc 1 321 13 view .LVU235
 324:Src/mc_tasks_foc.c ****             {
 966              		.loc 1 324 13 view .LVU236
 324:Src/mc_tasks_foc.c ****             {
ARM GAS  /tmp/cccnQOYj.s 			page 36


 967              		.loc 1 324 18 is_stmt 0 view .LVU237
 968 01a4 5148     		ldr	r0, .L68+16
 969 01a6 FFF7FEFF 		bl	RUC_Exec
 970              	.LVL77:
 324:Src/mc_tasks_foc.c ****             {
 971              		.loc 1 324 15 view .LVU238
 972 01aa 0028     		cmp	r0, #0
 973 01ac 39D1     		bne	.L63
 974              	.L49:
 340:Src/mc_tasks_foc.c **** 
 975              		.loc 1 340 13 is_stmt 1 view .LVU239
 340:Src/mc_tasks_foc.c **** 
 976              		.loc 1 340 19 is_stmt 0 view .LVU240
 977 01ae 534D     		ldr	r5, .L68+32
 978 01b0 0DF10601 		add	r1, sp, #6
 979 01b4 2846     		mov	r0, r5
 980 01b6 FFF7FEFF 		bl	VSS_CalcAvrgMecSpeedUnit
 981              	.LVL78:
 342:Src/mc_tasks_foc.c ****               STO_SetDirection(&STO_PLL_M1, (int8_t)MCI_GetImposedMotorDirection(&Mci[M1]));
 982              		.loc 1 342 15 is_stmt 1 view .LVU241
 342:Src/mc_tasks_foc.c ****               STO_SetDirection(&STO_PLL_M1, (int8_t)MCI_GetImposedMotorDirection(&Mci[M1]));
 983              		.loc 1 342 35 is_stmt 0 view .LVU242
 984 01ba 484E     		ldr	r6, .L68
 985 01bc 0DF10601 		add	r1, sp, #6
 986 01c0 3046     		mov	r0, r6
 987 01c2 FFF7FEFF 		bl	STO_PLL_IsObserverConverged
 988              	.LVL79:
 989 01c6 0446     		mov	r4, r0
 990              	.LVL80:
 343:Src/mc_tasks_foc.c **** 
 991              		.loc 1 343 15 is_stmt 1 view .LVU243
 343:Src/mc_tasks_foc.c **** 
 992              		.loc 1 343 53 is_stmt 0 view .LVU244
 993 01c8 4648     		ldr	r0, .L68+8
 994 01ca FFF7FEFF 		bl	MCI_GetImposedMotorDirection
 995              	.LVL81:
 343:Src/mc_tasks_foc.c **** 
 996              		.loc 1 343 15 view .LVU245
 997 01ce 41B2     		sxtb	r1, r0
 998 01d0 3046     		mov	r0, r6
 999 01d2 FFF7FEFF 		bl	STO_SetDirection
 1000              	.LVL82:
 345:Src/mc_tasks_foc.c ****             if (ObserverConverged)
 1001              		.loc 1 345 15 is_stmt 1 view .LVU246
 345:Src/mc_tasks_foc.c ****             if (ObserverConverged)
 1002              		.loc 1 345 21 is_stmt 0 view .LVU247
 1003 01d6 2146     		mov	r1, r4
 1004 01d8 2846     		mov	r0, r5
 1005 01da FFF7FEFF 		bl	VSS_SetStartTransition
 1006              	.LVL83:
 346:Src/mc_tasks_foc.c ****             {
 1007              		.loc 1 346 13 is_stmt 1 view .LVU248
 346:Src/mc_tasks_foc.c ****             {
 1008              		.loc 1 346 16 is_stmt 0 view .LVU249
 1009 01de 002C     		cmp	r4, #0
 1010 01e0 3FF424AF 		beq	.L31
 1011              	.LBB26:
ARM GAS  /tmp/cccnQOYj.s 			page 37


 348:Src/mc_tasks_foc.c **** 
 1012              		.loc 1 348 15 is_stmt 1 view .LVU250
 1013              	.LVL84:
 1014              	.LBB27:
 1015              	.LBI27:
 1016              		.file 3 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h"
   1:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** /**
   2:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   ******************************************************************************
   3:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @file    speed_pos_fdbk.h
   4:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @author  Motor Control SDK Team, ST Microelectronics
   5:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @brief   This file provides all definitions and functions prototypes
   6:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   *          of the Speed & Position Feedback component of the Motor Control SDK.
   7:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   *
   8:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   ******************************************************************************
   9:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @attention
  10:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   *
  11:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * <h2><center>&copy; Copyright (c) 2024 STMicroelectronics.
  12:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * All rights reserved.</center></h2>
  13:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   *
  14:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * This software component is licensed by ST under Ultimate Liberty license
  15:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * SLA0044, the "License"; You may not use this file except in compliance with
  16:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * the License. You may obtain a copy of the License at:
  17:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   *                             www.st.com/SLA0044
  18:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   *
  19:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   ******************************************************************************
  20:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @ingroup SpeednPosFdbk
  21:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   */
  22:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
  23:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** /* Define to prevent recursive inclusion -------------------------------------*/
  24:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** #ifndef SPEEDNPOSFDBK_H
  25:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** #define SPEEDNPOSFDBK_H
  26:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
  27:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** #ifdef __cplusplus
  28:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** extern "C" {
  29:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** #endif /* __cplusplus */
  30:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
  31:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** /* Includes ------------------------------------------------------------------*/
  32:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** /* Already into mc_type.h */
  33:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** /* #include "stdint.h" */
  34:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** #include "mc_type.h"
  35:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
  36:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** /** @addtogroup MCSDK
  37:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @{
  38:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   */
  39:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
  40:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** /** @addtogroup SpeednPosFdbk
  41:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @{
  42:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   */
  43:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
  44:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** /* Exported types ------------------------------------------------------------*/
  45:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** /**
  46:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @brief  SpeednPosFdbk  handles definitions of mechanical and electrical speed, mechanical accel
  47:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   *                        and electrical angle and all constants and scale values for a reliable m
  48:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   *                        computation in appropriated unit.
  49:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   */
  50:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** typedef struct
  51:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** {
ARM GAS  /tmp/cccnQOYj.s 			page 38


  52:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
  53:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   uint8_t bSpeedErrorNumber;          /*!< Number of time the average mechanical speed is not valid
  54:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   uint8_t bElToMecRatio;              /*!< Coefficient used to transform electrical to mechanical q
  55:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****                                            viceversa. It usually coincides with motor pole pairs nu
  56:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   uint8_t SpeedUnit;                  /*!< The speed unit value is defined into mc_stm_types.h by
  57:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****                                            [SPEED_UNIT](measurement_units.md) in tenth of Hertz.*/
  58:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   uint8_t bMaximumSpeedErrorsNumber;  /*!< Maximum value of not valid speed measurements before an 
  59:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   int16_t hElAngle;                   /*!< Estimated electrical angle reported by the implemented s
  60:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****                                            method. */
  61:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   int16_t hMecAngle;                  /*!< Instantaneous measure of rotor mechanical angle. */
  62:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   int32_t wMecAngle;                  /*!< Mechanical angle frame based on coefficient #bElToMecRat
  63:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   int16_t hAvrMecSpeedUnit;           /*!< Average mechanical speed expressed in the unit defined b
  64:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****                                            [SPEED_UNIT](measurement_units.md). */
  65:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   int16_t hElSpeedDpp;                /*!< Instantaneous electrical speed expressed in Digit Per co
  66:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****                                            ([dpp](measurement_units.md)),
  67:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****                                            expresses the angular speed as the variation of the elec
  68:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   int16_t InstantaneousElSpeedDpp;    /*!< Instantaneous computed electrical speed, expressed in
  69:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****                                            [dpp](measurement_units.md). */
  70:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   int16_t hMecAccelUnitP;             /*!< Average mechanical acceleration expressed in the unit de
  71:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****                                            only reported with encoder implementation */
  72:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   uint16_t hMaxReliableMecSpeedUnit;  /*!< Maximum value of measured mechanical speed that is consi
  73:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****                                            Expressed in the unit defined by [SPEED_UNIT](measuremen
  74:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   uint16_t hMinReliableMecSpeedUnit;  /*!< Minimum value of measured mechanical speed that is consi
  75:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****                                            Expressed in the unit defined by [SPEED_UNIT](measuremen
  76:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   uint16_t hMaxReliableMecAccelUnitP; /*!< Maximum value of measured acceleration that is considere
  77:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****                                            Constant value equal to 65535, expressed in the unit def
  78:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****                                            [SPEED_UNIT](measurement_units.md). */
  79:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   uint16_t hMeasurementFrequency;     /*!< Frequency at which the user will request a measurement o
  80:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****                                            electrical angle. Expressed in PWM_FREQ_SCALING * Hz. */
  81:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   uint32_t DPPConvFactor;             /*!< Conversion factor (65536/#PWM_FREQ_SCALING) used to conv
  82:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****                                            from the unit defined by [SPEED_UNIT](measurement_units.
  83:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****                                            [dpp](measurement_units.md). */
  84:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
  85:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
  86:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** } SpeednPosFdbk_Handle_t;
  87:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
  88:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** /**
  89:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @brief input structure type definition for SPD_CalcAngle
  90:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   */
  91:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** typedef struct
  92:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** {
  93:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   alphabeta_t  Valfa_beta;            /*!< Voltage Components in alfa beta reference frame */
  94:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   alphabeta_t  Ialfa_beta;            /*!< Current Components in alfa beta reference frame */
  95:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   uint16_t     Vbus;                  /*!< Virtual Bus Voltage information */
  96:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** } Observer_Inputs_t;
  97:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
  98:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
  99:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** int32_t SPD_GetMecAngle(const SpeednPosFdbk_Handle_t *pHandle);
 100:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
 101:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** int16_t SPD_GetAvrgMecSpeedUnit(const SpeednPosFdbk_Handle_t *pHandle);
 102:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
 103:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** int16_t SPD_GetElSpeedDpp(const SpeednPosFdbk_Handle_t *pHandle);
 104:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
 105:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** bool SPD_IsMecSpeedReliable(SpeednPosFdbk_Handle_t *pHandle, const int16_t *pMecSpeedUnit);
 106:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
 107:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** int16_t SPD_GetS16Speed(const SpeednPosFdbk_Handle_t *pHandle);
 108:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
ARM GAS  /tmp/cccnQOYj.s 			page 39


 109:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** uint8_t SPD_GetElToMecRatio(const SpeednPosFdbk_Handle_t *pHandle);
 110:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
 111:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** void SPD_SetElToMecRatio(SpeednPosFdbk_Handle_t *pHandle, uint8_t bPP);
 112:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
 113:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** /**
 114:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @brief  Returns the last computed rotor electrical angle, expressed in [s16degrees](measurement
 115:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @param  pHandle: handler of the current instance of the SpeednPosFdbk component.
 116:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @retval int16_t rotor electrical angle.
 117:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   */
 118:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** static inline int16_t SPD_GetElAngle(const SpeednPosFdbk_Handle_t *pHandle)
 1017              		.loc 3 118 23 view .LVU251
 1018              	.LBB28:
 119:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** {
 120:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** #ifdef NULL_PTR_CHECK_SPD_POS_FBK
 121:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   return ((MC_NULL == pHandle) ? 0 : pHandle->hElAngle);
 122:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** #else
 123:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   return (pHandle->hElAngle);
 1019              		.loc 3 123 3 view .LVU252
 1020              		.loc 3 123 3 is_stmt 0 view .LVU253
 1021              	.LBE28:
 1022              	.LBE27:
 348:Src/mc_tasks_foc.c **** 
 1023              		.loc 1 348 36 view .LVU254
 1024 01e4 444D     		ldr	r5, .L68+28
 1025 01e6 B6F90410 		ldrsh	r1, [r6, #4]
 1026 01ea 6868     		ldr	r0, [r5, #4]	@ unaligned
 1027 01ec FFF7FEFF 		bl	MCM_Park
 1028              	.LVL85:
 1029 01f0 0290     		str	r0, [sp, #8]
 351:Src/mc_tasks_foc.c ****               (void)REMNG_ExecRamp(pREMNG[M1], FOCVars[M1].Iqdref.q, 0);
 1030              		.loc 1 351 15 is_stmt 1 view .LVU255
 1031 01f2 444C     		ldr	r4, .L68+40
 1032              	.LVL86:
 351:Src/mc_tasks_foc.c ****               (void)REMNG_ExecRamp(pREMNG[M1], FOCVars[M1].Iqdref.q, 0);
 1033              		.loc 1 351 15 is_stmt 0 view .LVU256
 1034 01f4 2068     		ldr	r0, [r4]
 1035 01f6 FFF7FEFF 		bl	REMNG_Init
 1036              	.LVL87:
 352:Src/mc_tasks_foc.c ****               (void)REMNG_ExecRamp(pREMNG[M1], StatorCurrent.q, TRANSITION_DURATION);
 1037              		.loc 1 352 15 is_stmt 1 view .LVU257
 352:Src/mc_tasks_foc.c ****               (void)REMNG_ExecRamp(pREMNG[M1], StatorCurrent.q, TRANSITION_DURATION);
 1038              		.loc 1 352 21 is_stmt 0 view .LVU258
 1039 01fa 0022     		movs	r2, #0
 1040 01fc B5F91010 		ldrsh	r1, [r5, #16]
 1041 0200 2068     		ldr	r0, [r4]
 1042 0202 FFF7FEFF 		bl	REMNG_ExecRamp
 1043              	.LVL88:
 353:Src/mc_tasks_foc.c **** 
 1044              		.loc 1 353 15 is_stmt 1 view .LVU259
 353:Src/mc_tasks_foc.c **** 
 1045              		.loc 1 353 21 is_stmt 0 view .LVU260
 1046 0206 1922     		movs	r2, #25
 1047 0208 BDF90810 		ldrsh	r1, [sp, #8]
 1048 020c 2068     		ldr	r0, [r4]
 1049 020e FFF7FEFF 		bl	REMNG_ExecRamp
 1050              	.LVL89:
 355:Src/mc_tasks_foc.c ****             }
ARM GAS  /tmp/cccnQOYj.s 			page 40


 1051              		.loc 1 355 15 is_stmt 1 view .LVU261
 355:Src/mc_tasks_foc.c ****             }
 1052              		.loc 1 355 29 is_stmt 0 view .LVU262
 1053 0212 344B     		ldr	r3, .L68+8
 1054 0214 1322     		movs	r2, #19
 1055 0216 DA77     		strb	r2, [r3, #31]
 1056 0218 08E7     		b	.L31
 1057              	.LVL90:
 1058              	.L62:
 355:Src/mc_tasks_foc.c ****             }
 1059              		.loc 1 355 29 view .LVU263
 1060              	.LBE26:
 1061              	.LBE25:
 314:Src/mc_tasks_foc.c ****           }
 1062              		.loc 1 314 13 is_stmt 1 view .LVU264
 1063 021a 0020     		movs	r0, #0
 1064 021c FFF7FEFF 		bl	TSK_MF_StopProcessing
 1065              	.LVL91:
 1066 0220 04E7     		b	.L31
 1067              	.L63:
 1068              	.LBB29:
 334:Src/mc_tasks_foc.c ****               IqdRef.d = FOCVars[M1].UserIdref;
 1069              		.loc 1 334 15 view .LVU265
 334:Src/mc_tasks_foc.c ****               IqdRef.d = FOCVars[M1].UserIdref;
 1070              		.loc 1 334 26 is_stmt 0 view .LVU266
 1071 0222 374B     		ldr	r3, .L68+36
 1072 0224 1868     		ldr	r0, [r3]
 1073 0226 FFF7FEFF 		bl	STC_CalcTorqueReference
 1074              	.LVL92:
 335:Src/mc_tasks_foc.c ****               /* Iqd reference current used by the High Frequency Loop to generate the PWM output *
 1075              		.loc 1 335 15 is_stmt 1 view .LVU267
 335:Src/mc_tasks_foc.c ****               /* Iqd reference current used by the High Frequency Loop to generate the PWM output *
 1076              		.loc 1 335 37 is_stmt 0 view .LVU268
 1077 022a 334B     		ldr	r3, .L68+28
 1078 022c B3F91420 		ldrsh	r2, [r3, #20]
 1079              	.LVL93:
 337:Src/mc_tasks_foc.c ****            }
 1080              		.loc 1 337 15 is_stmt 1 view .LVU269
 337:Src/mc_tasks_foc.c ****            }
 1081              		.loc 1 337 34 is_stmt 0 view .LVU270
 1082 0230 1882     		strh	r0, [r3, #16]	@ movhi
 1083 0232 5A82     		strh	r2, [r3, #18]	@ movhi
 1084 0234 BBE7     		b	.L49
 1085              	.LVL94:
 1086              	.L34:
 337:Src/mc_tasks_foc.c ****            }
 1087              		.loc 1 337 34 view .LVU271
 1088              	.LBE29:
 363:Src/mc_tasks_foc.c ****           {
 1089              		.loc 1 363 11 is_stmt 1 view .LVU272
 363:Src/mc_tasks_foc.c ****           {
 1090              		.loc 1 363 34 is_stmt 0 view .LVU273
 1091 0236 2B4B     		ldr	r3, .L68+8
 363:Src/mc_tasks_foc.c ****           {
 1092              		.loc 1 363 14 view .LVU274
 1093 0238 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 1094 023a 052B     		cmp	r3, #5
ARM GAS  /tmp/cccnQOYj.s 			page 41


 1095 023c 31D0     		beq	.L64
 1096              	.LBB30:
 369:Src/mc_tasks_foc.c ****             int16_t hForcedMecSpeedUnit;
 1097              		.loc 1 369 13 is_stmt 1 view .LVU275
 370:Src/mc_tasks_foc.c **** 
 1098              		.loc 1 370 13 view .LVU276
 374:Src/mc_tasks_foc.c ****               /* Check if the transition ramp has completed. */
 1099              		.loc 1 374 15 view .LVU277
 374:Src/mc_tasks_foc.c ****               /* Check if the transition ramp has completed. */
 1100              		.loc 1 374 28 is_stmt 0 view .LVU278
 1101 023e 2F4D     		ldr	r5, .L68+32
 1102 0240 02A9     		add	r1, sp, #8
 1103 0242 2846     		mov	r0, r5
 1104 0244 FFF7FEFF 		bl	VSS_CalcAvrgMecSpeedUnit
 1105              	.LVL95:
 1106 0248 0446     		mov	r4, r0
 1107              	.LVL96:
 376:Src/mc_tasks_foc.c ****               tempBool = VSS_TransitionEnded(&VirtualSpeedSensorM1);
 1108              		.loc 1 376 15 is_stmt 1 view .LVU279
 377:Src/mc_tasks_foc.c ****               LoopClosed = LoopClosed || tempBool;
 1109              		.loc 1 377 15 view .LVU280
 377:Src/mc_tasks_foc.c ****               LoopClosed = LoopClosed || tempBool;
 1110              		.loc 1 377 26 is_stmt 0 view .LVU281
 1111 024a 2846     		mov	r0, r5
 1112 024c FFF7FEFF 		bl	VSS_TransitionEnded
 1113              	.LVL97:
 378:Src/mc_tasks_foc.c **** 
 1114              		.loc 1 378 15 is_stmt 1 view .LVU282
 378:Src/mc_tasks_foc.c **** 
 1115              		.loc 1 378 39 is_stmt 0 view .LVU283
 1116 0250 14B9     		cbnz	r4, .L52
 1117              	.LVL98:
 382:Src/mc_tasks_foc.c ****               {
 1118              		.loc 1 382 15 is_stmt 1 discriminator 6 view .LVU284
 382:Src/mc_tasks_foc.c ****               {
 1119              		.loc 1 382 18 is_stmt 0 discriminator 6 view .LVU285
 1120 0252 0028     		cmp	r0, #0
 1121 0254 3FF4EAAE 		beq	.L31
 1122              	.LVL99:
 1123              	.L52:
 387:Src/mc_tasks_foc.c ****                                     (((int32_t)FOCVars[M1].Iqdref.q * (int16_t)PID_GetKIDivisor(&PI
 1124              		.loc 1 387 17 is_stmt 1 view .LVU286
 388:Src/mc_tasks_foc.c ****                                     / PID_SPEED_INTEGRAL_INIT_DIV));
 1125              		.loc 1 388 66 is_stmt 0 view .LVU287
 1126 0258 274B     		ldr	r3, .L68+28
 388:Src/mc_tasks_foc.c ****                                     / PID_SPEED_INTEGRAL_INIT_DIV));
 1127              		.loc 1 388 39 view .LVU288
 1128 025a B3F91050 		ldrsh	r5, [r3, #16]
 388:Src/mc_tasks_foc.c ****                                     / PID_SPEED_INTEGRAL_INIT_DIV));
 1129              		.loc 1 388 80 view .LVU289
 1130 025e 2A4C     		ldr	r4, .L68+44
 1131 0260 2046     		mov	r0, r4
 1132              	.LVL100:
 388:Src/mc_tasks_foc.c ****                                     / PID_SPEED_INTEGRAL_INIT_DIV));
 1133              		.loc 1 388 80 view .LVU290
 1134 0262 FFF7FEFF 		bl	PID_GetKIDivisor
 1135              	.LVL101:
ARM GAS  /tmp/cccnQOYj.s 			page 42


 388:Src/mc_tasks_foc.c ****                                     / PID_SPEED_INTEGRAL_INIT_DIV));
 1136              		.loc 1 388 71 view .LVU291
 1137 0266 01B2     		sxth	r1, r0
 387:Src/mc_tasks_foc.c ****                                     (((int32_t)FOCVars[M1].Iqdref.q * (int16_t)PID_GetKIDivisor(&PI
 1138              		.loc 1 387 17 view .LVU292
 1139 0268 05FB01F1 		mul	r1, r5, r1
 1140 026c 2046     		mov	r0, r4
 1141 026e FFF7FEFF 		bl	PID_SetIntegralTerm
 1142              	.LVL102:
 391:Src/mc_tasks_foc.c ****                 /* USER CODE BEGIN MediumFrequencyTask M1 1 */
 1143              		.loc 1 391 17 is_stmt 1 view .LVU293
 1144 0272 2048     		ldr	r0, .L68+24
 1145 0274 FFF7FEFF 		bl	OTT_SR
 1146              	.LVL103:
 395:Src/mc_tasks_foc.c ****                 FOC_InitAdditionalMethods(M1);
 1147              		.loc 1 395 17 view .LVU294
 1148 0278 214C     		ldr	r4, .L68+36
 1149 027a 1849     		ldr	r1, .L68
 1150 027c 2068     		ldr	r0, [r4]
 1151 027e FFF7FEFF 		bl	STC_SetSpeedSensor
 1152              	.LVL104:
 396:Src/mc_tasks_foc.c ****                 FOC_CalcCurrRef(M1);
 1153              		.loc 1 396 17 view .LVU295
 1154 0282 0020     		movs	r0, #0
 1155 0284 FFF7FEFF 		bl	FOC_InitAdditionalMethods
 1156              	.LVL105:
 397:Src/mc_tasks_foc.c ****                 STC_ForceSpeedReferenceToCurrentSpeed(pSTC[M1]); /* Init the reference speed to cur
 1157              		.loc 1 397 17 view .LVU296
 1158 0288 0020     		movs	r0, #0
 1159 028a FFF7FEFF 		bl	FOC_CalcCurrRef
 1160              	.LVL106:
 398:Src/mc_tasks_foc.c ****                 MCI_ExecBufferedCommands(&Mci[M1]); /* Exec the speed ramp after changing of the sp
 1161              		.loc 1 398 17 view .LVU297
 1162 028e 2068     		ldr	r0, [r4]
 1163 0290 FFF7FEFF 		bl	STC_ForceSpeedReferenceToCurrentSpeed
 1164              	.LVL107:
 399:Src/mc_tasks_foc.c ****                 Mci[M1].State = RUN;
 1165              		.loc 1 399 17 view .LVU298
 1166 0294 134C     		ldr	r4, .L68+8
 1167 0296 2046     		mov	r0, r4
 1168 0298 FFF7FEFF 		bl	MCI_ExecBufferedCommands
 1169              	.LVL108:
 400:Src/mc_tasks_foc.c ****               }
 1170              		.loc 1 400 17 view .LVU299
 400:Src/mc_tasks_foc.c ****               }
 1171              		.loc 1 400 31 is_stmt 0 view .LVU300
 1172 029c 0623     		movs	r3, #6
 1173 029e E377     		strb	r3, [r4, #31]
 1174 02a0 C4E6     		b	.L31
 1175              	.LVL109:
 1176              	.L64:
 400:Src/mc_tasks_foc.c ****               }
 1177              		.loc 1 400 31 view .LVU301
 1178              	.LBE30:
 365:Src/mc_tasks_foc.c ****           }
 1179              		.loc 1 365 13 is_stmt 1 view .LVU302
 1180 02a2 0020     		movs	r0, #0
ARM GAS  /tmp/cccnQOYj.s 			page 43


 1181 02a4 FFF7FEFF 		bl	TSK_MF_StopProcessing
 1182              	.LVL110:
 1183 02a8 C0E6     		b	.L31
 1184              	.L40:
 408:Src/mc_tasks_foc.c ****           {
 1185              		.loc 1 408 11 view .LVU303
 408:Src/mc_tasks_foc.c ****           {
 1186              		.loc 1 408 34 is_stmt 0 view .LVU304
 1187 02aa 0E4B     		ldr	r3, .L68+8
 408:Src/mc_tasks_foc.c ****           {
 1188              		.loc 1 408 14 view .LVU305
 1189 02ac 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 1190 02ae 052B     		cmp	r3, #5
 1191 02b0 0AD0     		beq	.L65
 418:Src/mc_tasks_foc.c **** 
 1192              		.loc 1 418 13 is_stmt 1 view .LVU306
 1193 02b2 0C48     		ldr	r0, .L68+8
 1194 02b4 FFF7FEFF 		bl	MCI_ExecBufferedCommands
 1195              	.LVL111:
 420:Src/mc_tasks_foc.c ****               if(!IsSpeedReliable)
 1196              		.loc 1 420 15 view .LVU307
 1197 02b8 0020     		movs	r0, #0
 1198 02ba FFF7FEFF 		bl	FOC_CalcCurrRef
 1199              	.LVL112:
 421:Src/mc_tasks_foc.c ****               {
 1200              		.loc 1 421 15 view .LVU308
 421:Src/mc_tasks_foc.c ****               {
 1201              		.loc 1 421 17 is_stmt 0 view .LVU309
 1202 02be 3CB1     		cbz	r4, .L66
 1203              	.L55:
 428:Src/mc_tasks_foc.c ****             OTT_MF(&OTT);
 1204              		.loc 1 428 15 is_stmt 1 view .LVU310
 429:Src/mc_tasks_foc.c ****           }
 1205              		.loc 1 429 13 view .LVU311
 1206 02c0 0C48     		ldr	r0, .L68+24
 1207 02c2 FFF7FEFF 		bl	OTT_MF
 1208              	.LVL113:
 1209 02c6 B1E6     		b	.L31
 1210              	.L65:
 410:Src/mc_tasks_foc.c ****           }
 1211              		.loc 1 410 13 view .LVU312
 1212 02c8 0020     		movs	r0, #0
 1213 02ca FFF7FEFF 		bl	TSK_MF_StopProcessing
 1214              	.LVL114:
 1215 02ce ADE6     		b	.L31
 1216              	.L66:
 423:Src/mc_tasks_foc.c ****               }
 1217              		.loc 1 423 17 view .LVU313
 1218 02d0 0022     		movs	r2, #0
 1219 02d2 2021     		movs	r1, #32
 1220 02d4 0348     		ldr	r0, .L68+8
 1221 02d6 FFF7FEFF 		bl	MCI_FaultProcessing
 1222              	.LVL115:
 1223 02da F1E7     		b	.L55
 1224              	.L69:
 1225              		.align	2
 1226              	.L68:
ARM GAS  /tmp/cccnQOYj.s 			page 44


 1227 02dc 00000000 		.word	STO_PLL_M1
 1228 02e0 00000000 		.word	pMPM
 1229 02e4 00000000 		.word	Mci
 1230 02e8 00000000 		.word	SCC
 1231 02ec 00000000 		.word	RevUpControlM1
 1232 02f0 00000000 		.word	pwmcHandle
 1233 02f4 00000000 		.word	OTT
 1234 02f8 00000000 		.word	FOCVars
 1235 02fc 00000000 		.word	VirtualSpeedSensorM1
 1236 0300 00000000 		.word	pSTC
 1237 0304 00000000 		.word	pREMNG
 1238 0308 00000000 		.word	PIDSpeedHandle_M1
 1239              	.L39:
 436:Src/mc_tasks_foc.c ****           {
 1240              		.loc 1 436 11 view .LVU314
 436:Src/mc_tasks_foc.c ****           {
 1241              		.loc 1 436 15 is_stmt 0 view .LVU315
 1242 030c FFF7FEFF 		bl	TSK_StopPermanencyTimeHasElapsedM1
 1243              	.LVL116:
 436:Src/mc_tasks_foc.c ****           {
 1244              		.loc 1 436 14 view .LVU316
 1245 0310 0028     		cmp	r0, #0
 1246 0312 3FF48BAE 		beq	.L31
 439:Src/mc_tasks_foc.c ****             VSS_Clear(&VirtualSpeedSensorM1); /* Reset measured speed in IDLE */
 1247              		.loc 1 439 13 is_stmt 1 view .LVU317
 1248 0316 244C     		ldr	r4, .L70
 1249              	.LVL117:
 439:Src/mc_tasks_foc.c ****             VSS_Clear(&VirtualSpeedSensorM1); /* Reset measured speed in IDLE */
 1250              		.loc 1 439 13 is_stmt 0 view .LVU318
 1251 0318 2146     		mov	r1, r4
 1252 031a 244B     		ldr	r3, .L70+4
 1253 031c 1868     		ldr	r0, [r3]
 1254 031e FFF7FEFF 		bl	STC_SetSpeedSensor
 1255              	.LVL118:
 440:Src/mc_tasks_foc.c ****             /* USER CODE BEGIN MediumFrequencyTask M1 5 */
 1256              		.loc 1 440 13 is_stmt 1 view .LVU319
 1257 0322 2046     		mov	r0, r4
 1258 0324 FFF7FEFF 		bl	VSS_Clear
 1259              	.LVL119:
 444:Src/mc_tasks_foc.c ****             Mci[M1].State = IDLE;
 1260              		.loc 1 444 13 view .LVU320
 444:Src/mc_tasks_foc.c ****             Mci[M1].State = IDLE;
 1261              		.loc 1 444 35 is_stmt 0 view .LVU321
 1262 0328 214B     		ldr	r3, .L70+8
 1263 032a 0022     		movs	r2, #0
 1264 032c 9A77     		strb	r2, [r3, #30]
 445:Src/mc_tasks_foc.c ****           }
 1265              		.loc 1 445 13 is_stmt 1 view .LVU322
 445:Src/mc_tasks_foc.c ****           }
 1266              		.loc 1 445 27 is_stmt 0 view .LVU323
 1267 032e DA77     		strb	r2, [r3, #31]
 1268 0330 7CE6     		b	.L31
 1269              	.LVL120:
 1270              	.L37:
 456:Src/mc_tasks_foc.c ****           {
 1271              		.loc 1 456 11 is_stmt 1 view .LVU324
 456:Src/mc_tasks_foc.c ****           {
ARM GAS  /tmp/cccnQOYj.s 			page 45


 1272              		.loc 1 456 40 is_stmt 0 view .LVU325
 1273 0332 1F4B     		ldr	r3, .L70+8
 456:Src/mc_tasks_foc.c ****           {
 1274              		.loc 1 456 14 view .LVU326
 1275 0334 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 1276 0336 022B     		cmp	r3, #2
 1277 0338 7FF478AE 		bne	.L31
 458:Src/mc_tasks_foc.c ****             Mci[M1].State = IDLE;
 1278              		.loc 1 458 13 is_stmt 1 view .LVU327
 458:Src/mc_tasks_foc.c ****             Mci[M1].State = IDLE;
 1279              		.loc 1 458 35 is_stmt 0 view .LVU328
 1280 033c 1C4B     		ldr	r3, .L70+8
 1281 033e 0022     		movs	r2, #0
 1282 0340 9A77     		strb	r2, [r3, #30]
 459:Src/mc_tasks_foc.c ****           }
 1283              		.loc 1 459 13 is_stmt 1 view .LVU329
 459:Src/mc_tasks_foc.c ****           }
 1284              		.loc 1 459 27 is_stmt 0 view .LVU330
 1285 0342 DA77     		strb	r2, [r3, #31]
 1286 0344 72E6     		b	.L31
 1287              	.L38:
 470:Src/mc_tasks_foc.c ****           break;
 1288              		.loc 1 470 11 is_stmt 1 view .LVU331
 470:Src/mc_tasks_foc.c ****           break;
 1289              		.loc 1 470 25 is_stmt 0 view .LVU332
 1290 0346 1A4B     		ldr	r3, .L70+8
 1291 0348 0B22     		movs	r2, #11
 1292 034a DA77     		strb	r2, [r3, #31]
 471:Src/mc_tasks_foc.c ****         }
 1293              		.loc 1 471 11 is_stmt 1 view .LVU333
 1294 034c 6EE6     		b	.L31
 1295              	.L32:
 476:Src/mc_tasks_foc.c ****           {
 1296              		.loc 1 476 11 view .LVU334
 476:Src/mc_tasks_foc.c ****           {
 1297              		.loc 1 476 34 is_stmt 0 view .LVU335
 1298 034e 184B     		ldr	r3, .L70+8
 476:Src/mc_tasks_foc.c ****           {
 1299              		.loc 1 476 14 view .LVU336
 1300 0350 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 1301 0352 052B     		cmp	r3, #5
 1302 0354 1FD0     		beq	.L67
 482:Src/mc_tasks_foc.c ****             {
 1303              		.loc 1 482 13 is_stmt 1 view .LVU337
 482:Src/mc_tasks_foc.c ****             {
 1304              		.loc 1 482 22 is_stmt 0 view .LVU338
 1305 0356 1748     		ldr	r0, .L70+12
 1306 0358 FFF7FEFF 		bl	SCC_DetectBemf
 1307              	.LVL121:
 482:Src/mc_tasks_foc.c ****             {
 1308              		.loc 1 482 16 view .LVU339
 1309 035c 0028     		cmp	r0, #0
 1310 035e 7FF465AE 		bne	.L31
 485:Src/mc_tasks_foc.c ****               STC_SetSpeedSensor(pSTC[M1], &VirtualSpeedSensorM1._Super);
 1311              		.loc 1 485 15 is_stmt 1 view .LVU340
 485:Src/mc_tasks_foc.c ****               STC_SetSpeedSensor(pSTC[M1], &VirtualSpeedSensorM1._Super);
 1312              		.loc 1 485 39 is_stmt 0 view .LVU341
ARM GAS  /tmp/cccnQOYj.s 			page 46


 1313 0362 154B     		ldr	r3, .L70+16
 1314 0364 0122     		movs	r2, #1
 1315 0366 83F82420 		strb	r2, [r3, #36]
 486:Src/mc_tasks_foc.c ****                STO_PLL_Clear(&STO_PLL_M1);
 1316              		.loc 1 486 15 is_stmt 1 view .LVU342
 1317 036a 0F49     		ldr	r1, .L70
 1318 036c 0F4B     		ldr	r3, .L70+4
 1319 036e 1868     		ldr	r0, [r3]
 1320 0370 FFF7FEFF 		bl	STC_SetSpeedSensor
 1321              	.LVL122:
 487:Src/mc_tasks_foc.c ****               FOC_Clear(M1);
 1322              		.loc 1 487 16 view .LVU343
 1323 0374 1148     		ldr	r0, .L70+20
 1324 0376 FFF7FEFF 		bl	STO_PLL_Clear
 1325              	.LVL123:
 488:Src/mc_tasks_foc.c ****               SCC_Start(&SCC);
 1326              		.loc 1 488 15 view .LVU344
 1327 037a 0020     		movs	r0, #0
 1328 037c FFF7FEFF 		bl	FOC_Clear
 1329              	.LVL124:
 489:Src/mc_tasks_foc.c ****               /* The generic function needs to be called here as the undelying
 1330              		.loc 1 489 15 view .LVU345
 1331 0380 0C48     		ldr	r0, .L70+12
 1332 0382 FFF7FEFF 		bl	SCC_Start
 1333              	.LVL125:
 494:Src/mc_tasks_foc.c ****               Mci[M1].State = START;
 1334              		.loc 1 494 15 view .LVU346
 1335 0386 0E4B     		ldr	r3, .L70+24
 1336 0388 1868     		ldr	r0, [r3]
 1337 038a FFF7FEFF 		bl	PWMC_SwitchOnPWM
 1338              	.LVL126:
 495:Src/mc_tasks_foc.c ****             }
 1339              		.loc 1 495 15 view .LVU347
 495:Src/mc_tasks_foc.c ****             }
 1340              		.loc 1 495 29 is_stmt 0 view .LVU348
 1341 038e 084B     		ldr	r3, .L70+8
 1342 0390 0422     		movs	r2, #4
 1343 0392 DA77     		strb	r2, [r3, #31]
 1344 0394 4AE6     		b	.L31
 1345              	.L67:
 478:Src/mc_tasks_foc.c ****           }
 1346              		.loc 1 478 13 is_stmt 1 view .LVU349
 1347 0396 0020     		movs	r0, #0
 1348 0398 FFF7FEFF 		bl	TSK_MF_StopProcessing
 1349              	.LVL127:
 1350 039c 46E6     		b	.L31
 1351              	.L30:
 511:Src/mc_tasks_foc.c ****     }
 1352              		.loc 1 511 7 view .LVU350
 511:Src/mc_tasks_foc.c ****     }
 1353              		.loc 1 511 21 is_stmt 0 view .LVU351
 1354 039e 044B     		ldr	r3, .L70+8
 1355 03a0 0B22     		movs	r2, #11
 1356 03a2 DA77     		strb	r2, [r3, #31]
 1357 03a4 42E6     		b	.L31
 1358              	.L71:
 1359 03a6 00BF     		.align	2
ARM GAS  /tmp/cccnQOYj.s 			page 47


 1360              	.L70:
 1361 03a8 00000000 		.word	VirtualSpeedSensorM1
 1362 03ac 00000000 		.word	pSTC
 1363 03b0 00000000 		.word	Mci
 1364 03b4 00000000 		.word	SCC
 1365 03b8 00000000 		.word	FOCVars
 1366 03bc 00000000 		.word	STO_PLL_M1
 1367 03c0 00000000 		.word	pwmcHandle
 1368              		.cfi_endproc
 1369              	.LFE1869:
 1371              		.section	.text.FOC_HighFrequencyTask,"ax",%progbits
 1372              		.align	1
 1373              		.weak	FOC_HighFrequencyTask
 1374              		.syntax unified
 1375              		.thumb
 1376              		.thumb_func
 1377              		.fpu fpv4-sp-d16
 1379              	FOC_HighFrequencyTask:
 1380              	.LVL128:
 1381              	.LFB1873:
 654:Src/mc_tasks_foc.c **** 
 655:Src/mc_tasks_foc.c **** #if defined (CCMRAM)
 656:Src/mc_tasks_foc.c **** #if defined (__ICCARM__)
 657:Src/mc_tasks_foc.c **** #pragma location = ".ccmram"
 658:Src/mc_tasks_foc.c **** #elif defined (__CC_ARM) || defined(__GNUC__)
 659:Src/mc_tasks_foc.c **** __attribute__((section (".ccmram")))
 660:Src/mc_tasks_foc.c **** #endif
 661:Src/mc_tasks_foc.c **** #endif
 662:Src/mc_tasks_foc.c **** /**
 663:Src/mc_tasks_foc.c ****   * @brief  Motor control profiler HF task
 664:Src/mc_tasks_foc.c ****   * @param  None
 665:Src/mc_tasks_foc.c ****   * @retval uint8_t It return always 0.
 666:Src/mc_tasks_foc.c ****   */
 667:Src/mc_tasks_foc.c **** __weak uint8_t FOC_HighFrequencyTask(uint8_t bMotorNbr)
 668:Src/mc_tasks_foc.c **** {
 1382              		.loc 1 668 1 is_stmt 1 view -0
 1383              		.cfi_startproc
 1384              		@ args = 0, pretend = 0, frame = 8
 1385              		@ frame_needed = 0, uses_anonymous_args = 0
 1386              		.loc 1 668 1 is_stmt 0 view .LVU353
 1387 0000 00B5     		push	{lr}
 1388              	.LCFI15:
 1389              		.cfi_def_cfa_offset 4
 1390              		.cfi_offset 14, -4
 1391 0002 83B0     		sub	sp, sp, #12
 1392              	.LCFI16:
 1393              		.cfi_def_cfa_offset 16
 669:Src/mc_tasks_foc.c ****   ab_t Iab;
 1394              		.loc 1 669 3 is_stmt 1 view .LVU354
 670:Src/mc_tasks_foc.c **** 
 671:Src/mc_tasks_foc.c ****   if (SWITCH_OVER == Mci[M1].State)
 1395              		.loc 1 671 3 view .LVU355
 1396              		.loc 1 671 29 is_stmt 0 view .LVU356
 1397 0004 114B     		ldr	r3, .L76
 1398              		.loc 1 671 6 view .LVU357
 1399 0006 DB7F     		ldrb	r3, [r3, #31]	@ zero_extendqisi2
 1400 0008 132B     		cmp	r3, #19
ARM GAS  /tmp/cccnQOYj.s 			page 48


 1401 000a 12D0     		beq	.L75
 1402              	.LVL129:
 1403              	.L73:
 672:Src/mc_tasks_foc.c ****   {
 673:Src/mc_tasks_foc.c ****     if (!REMNG_RampCompleted(pREMNG[M1]))
 674:Src/mc_tasks_foc.c ****     {
 675:Src/mc_tasks_foc.c ****       FOCVars[M1].Iqdref.q = (int16_t)REMNG_Calc(pREMNG[M1]);
 676:Src/mc_tasks_foc.c ****     }
 677:Src/mc_tasks_foc.c ****     else
 678:Src/mc_tasks_foc.c ****     {
 679:Src/mc_tasks_foc.c ****       /* Nothing to do */
 680:Src/mc_tasks_foc.c ****     }
 681:Src/mc_tasks_foc.c ****   }
 682:Src/mc_tasks_foc.c ****   else
 683:Src/mc_tasks_foc.c ****   {
 684:Src/mc_tasks_foc.c ****     /* Nothing to do */
 685:Src/mc_tasks_foc.c ****   }
 1404              		.loc 1 685 3 is_stmt 1 view .LVU358
 686:Src/mc_tasks_foc.c ****   RCM_ReadOngoingConv();
 1405              		.loc 1 686 3 view .LVU359
 1406 000c FFF7FEFF 		bl	RCM_ReadOngoingConv
 1407              	.LVL130:
 687:Src/mc_tasks_foc.c ****   RCM_ExecNextConv();
 1408              		.loc 1 687 3 view .LVU360
 1409 0010 FFF7FEFF 		bl	RCM_ExecNextConv
 1410              	.LVL131:
 688:Src/mc_tasks_foc.c ****   /* The generic function needs to be called here as the undelying
 689:Src/mc_tasks_foc.c ****    * implementation changes in time depending on the Profiler's state
 690:Src/mc_tasks_foc.c ****    * machine. Calling the generic function ensures that the correct
 691:Src/mc_tasks_foc.c ****    * implementation is invoked */
 692:Src/mc_tasks_foc.c ****   PWMC_GetPhaseCurrents(pwmcHandle[M1], &Iab);
 1411              		.loc 1 692 3 view .LVU361
 1412 0014 0E4B     		ldr	r3, .L76+4
 1413 0016 1868     		ldr	r0, [r3]
 1414              	.LVL132:
 1415              	.LBB31:
 1416              	.LBI31:
 1417              		.file 4 "Inc/pwm_curr_fdbk.h"
   1:Inc/pwm_curr_fdbk.h **** /**
   2:Inc/pwm_curr_fdbk.h ****   ******************************************************************************
   3:Inc/pwm_curr_fdbk.h ****   * @file    pwm_curr_fdbk.h
   4:Inc/pwm_curr_fdbk.h ****   * @author  Motor Control SDK Team, ST Microelectronics
   5:Inc/pwm_curr_fdbk.h ****   * @brief   This file contains all definitions and functions prototypes for the
   6:Inc/pwm_curr_fdbk.h ****   *          PWM & Current Feedback component of the Motor Control SDK.
   7:Inc/pwm_curr_fdbk.h ****   ******************************************************************************
   8:Inc/pwm_curr_fdbk.h ****   * @attention
   9:Inc/pwm_curr_fdbk.h ****   *
  10:Inc/pwm_curr_fdbk.h ****   * <h2><center>&copy; Copyright (c) 2024 STMicroelectronics.
  11:Inc/pwm_curr_fdbk.h ****   * All rights reserved.</center></h2>
  12:Inc/pwm_curr_fdbk.h ****   *
  13:Inc/pwm_curr_fdbk.h ****   * This software component is licensed by ST under Ultimate Liberty license
  14:Inc/pwm_curr_fdbk.h ****   * SLA0044, the "License"; You may not use this file except in compliance with
  15:Inc/pwm_curr_fdbk.h ****   * the License. You may obtain a copy of the License at:
  16:Inc/pwm_curr_fdbk.h ****   *                             www.st.com/SLA0044
  17:Inc/pwm_curr_fdbk.h ****   *
  18:Inc/pwm_curr_fdbk.h ****   ******************************************************************************
  19:Inc/pwm_curr_fdbk.h ****   * @ingroup pwm_curr_fdbk
ARM GAS  /tmp/cccnQOYj.s 			page 49


  20:Inc/pwm_curr_fdbk.h ****   */
  21:Inc/pwm_curr_fdbk.h **** 
  22:Inc/pwm_curr_fdbk.h **** /* Define to prevent recursive inclusion -------------------------------------*/
  23:Inc/pwm_curr_fdbk.h **** #ifndef PWMNCURRFDBK_H
  24:Inc/pwm_curr_fdbk.h **** #define PWMNCURRFDBK_H
  25:Inc/pwm_curr_fdbk.h **** 
  26:Inc/pwm_curr_fdbk.h **** #ifdef __cplusplus
  27:Inc/pwm_curr_fdbk.h **** extern "C" {
  28:Inc/pwm_curr_fdbk.h **** #endif /* __cplusplus */
  29:Inc/pwm_curr_fdbk.h **** 
  30:Inc/pwm_curr_fdbk.h **** /* Includes ------------------------------------------------------------------*/
  31:Inc/pwm_curr_fdbk.h **** #include "mc_type.h"
  32:Inc/pwm_curr_fdbk.h **** 
  33:Inc/pwm_curr_fdbk.h **** /* Exported defines ------------------------------------------------------------*/
  34:Inc/pwm_curr_fdbk.h **** 
  35:Inc/pwm_curr_fdbk.h **** #define SECTOR_1  0U
  36:Inc/pwm_curr_fdbk.h **** #define SECTOR_2  1U
  37:Inc/pwm_curr_fdbk.h **** #define SECTOR_3  2U
  38:Inc/pwm_curr_fdbk.h **** #define SECTOR_4  3U
  39:Inc/pwm_curr_fdbk.h **** #define SECTOR_5  4U
  40:Inc/pwm_curr_fdbk.h **** #define SECTOR_6  5U
  41:Inc/pwm_curr_fdbk.h **** /*  @brief Used in calculation of Ia, Ib and Ic
  42:Inc/pwm_curr_fdbk.h ****   *
  43:Inc/pwm_curr_fdbk.h ****   * See function PWMC_CalcPhaseCurrentsEst
  44:Inc/pwm_curr_fdbk.h ****   */
  45:Inc/pwm_curr_fdbk.h **** #define SQRT3FACTOR ((uint16_t)0xDDB4) /* = (16384 * 1.732051 * 2)*/
  46:Inc/pwm_curr_fdbk.h **** 
  47:Inc/pwm_curr_fdbk.h **** /** @addtogroup MCSDK
  48:Inc/pwm_curr_fdbk.h ****   * @{
  49:Inc/pwm_curr_fdbk.h ****   */
  50:Inc/pwm_curr_fdbk.h **** 
  51:Inc/pwm_curr_fdbk.h **** /** @addtogroup pwm_curr_fdbk
  52:Inc/pwm_curr_fdbk.h ****   * @{
  53:Inc/pwm_curr_fdbk.h ****   */
  54:Inc/pwm_curr_fdbk.h **** 
  55:Inc/pwm_curr_fdbk.h **** /* Exported types ------------------------------------------------------------*/
  56:Inc/pwm_curr_fdbk.h **** 
  57:Inc/pwm_curr_fdbk.h **** /** @brief PWM & Current Sensing component handle type */
  58:Inc/pwm_curr_fdbk.h **** typedef struct PWMC_Handle PWMC_Handle_t;
  59:Inc/pwm_curr_fdbk.h **** 
  60:Inc/pwm_curr_fdbk.h **** /**
  61:Inc/pwm_curr_fdbk.h ****   * @brief Pointer on callback functions used by PWMC components
  62:Inc/pwm_curr_fdbk.h ****   *
  63:Inc/pwm_curr_fdbk.h ****   * This type is needed because the actual functions to use can change at run-time.
  64:Inc/pwm_curr_fdbk.h ****   *
  65:Inc/pwm_curr_fdbk.h ****   * See the following items:
  66:Inc/pwm_curr_fdbk.h ****   * - PWMC_Handle::pFctSwitchOffPwm
  67:Inc/pwm_curr_fdbk.h ****   * - PWMC_Handle::pFctSwitchOnPwm
  68:Inc/pwm_curr_fdbk.h ****   * - PWMC_Handle::pFctCurrReadingCalib
  69:Inc/pwm_curr_fdbk.h ****   * - PWMC_Handle::pFctRLDetectionModeEnable
  70:Inc/pwm_curr_fdbk.h ****   * - PWMC_Handle::pFctRLDetectionModeDisable
  71:Inc/pwm_curr_fdbk.h ****   *
  72:Inc/pwm_curr_fdbk.h ****   *
  73:Inc/pwm_curr_fdbk.h ****   */
  74:Inc/pwm_curr_fdbk.h **** typedef void (*PWMC_Generic_Cb_t)(PWMC_Handle_t *pHandle);
  75:Inc/pwm_curr_fdbk.h **** 
  76:Inc/pwm_curr_fdbk.h **** /**
ARM GAS  /tmp/cccnQOYj.s 			page 50


  77:Inc/pwm_curr_fdbk.h ****   * @brief Pointer on the function provided by the PMWC component instance to get the phase current
  78:Inc/pwm_curr_fdbk.h ****   *
  79:Inc/pwm_curr_fdbk.h ****   * This type is needed because the actual function to use can change at run-time
  80:Inc/pwm_curr_fdbk.h ****   * (See PWMC_Handle::pFctGetPhaseCurrents).
  81:Inc/pwm_curr_fdbk.h ****   *
  82:Inc/pwm_curr_fdbk.h ****   */
  83:Inc/pwm_curr_fdbk.h **** typedef void (*PWMC_GetPhaseCurr_Cb_t)(PWMC_Handle_t *pHandle, ab_t *Iab);
  84:Inc/pwm_curr_fdbk.h **** 
  85:Inc/pwm_curr_fdbk.h **** /**
  86:Inc/pwm_curr_fdbk.h ****   * @brief Pointer on the function provided by the PMWC component instance to set low sides ON.
  87:Inc/pwm_curr_fdbk.h ****   *
  88:Inc/pwm_curr_fdbk.h ****   * This type is needed because the actual function to use can change at run-time
  89:Inc/pwm_curr_fdbk.h ****   * (See PWMC_Handle::pFctTurnOnLowSides).
  90:Inc/pwm_curr_fdbk.h ****   *
  91:Inc/pwm_curr_fdbk.h ****   */
  92:Inc/pwm_curr_fdbk.h **** typedef void (*PWMC_TurnOnLowSides_Cb_t)(PWMC_Handle_t *pHandle, const uint32_t ticks);
  93:Inc/pwm_curr_fdbk.h **** 
  94:Inc/pwm_curr_fdbk.h **** /**
  95:Inc/pwm_curr_fdbk.h ****   * @brief Pointer on the function provided by the PMWC component instance to set the reference
  96:Inc/pwm_curr_fdbk.h ****   *        voltage for the over current protection.
  97:Inc/pwm_curr_fdbk.h ****   *
  98:Inc/pwm_curr_fdbk.h ****   * This type is needed because the actual function to use can change at run-time
  99:Inc/pwm_curr_fdbk.h ****   * (See PWMC_Handle::pFctOCPSetReferenceVoltage).
 100:Inc/pwm_curr_fdbk.h ****   *
 101:Inc/pwm_curr_fdbk.h ****   */
 102:Inc/pwm_curr_fdbk.h **** typedef void (*PWMC_SetOcpRefVolt_Cb_t)(PWMC_Handle_t *pHandle, uint16_t hDACVref);
 103:Inc/pwm_curr_fdbk.h **** 
 104:Inc/pwm_curr_fdbk.h **** /**
 105:Inc/pwm_curr_fdbk.h ****   * @brief Pointer on the functions provided by the PMWC component instance to set the ADC sampling
 106:Inc/pwm_curr_fdbk.h ****   *        point for each sectors.
 107:Inc/pwm_curr_fdbk.h ****   *
 108:Inc/pwm_curr_fdbk.h ****   * This type is needed because the actual function to use can change at run-time. See:
 109:Inc/pwm_curr_fdbk.h ****   * - PWMC_Handle::pFctSetADCSampPointSect1
 110:Inc/pwm_curr_fdbk.h ****   * - PWMC_Handle::pFctSetADCSampPointSect2
 111:Inc/pwm_curr_fdbk.h ****   * - PWMC_Handle::pFctSetADCSampPointSect3
 112:Inc/pwm_curr_fdbk.h ****   * - PWMC_Handle::pFctSetADCSampPointSect4
 113:Inc/pwm_curr_fdbk.h ****   * - PWMC_Handle::pFctSetADCSampPointSect5
 114:Inc/pwm_curr_fdbk.h ****   * - PWMC_Handle::pFctSetADCSampPointSect6
 115:Inc/pwm_curr_fdbk.h ****   *
 116:Inc/pwm_curr_fdbk.h ****   */
 117:Inc/pwm_curr_fdbk.h **** typedef uint16_t (*PWMC_SetSampPointSectX_Cb_t)(PWMC_Handle_t *pHandle);
 118:Inc/pwm_curr_fdbk.h **** 
 119:Inc/pwm_curr_fdbk.h **** /**
 120:Inc/pwm_curr_fdbk.h ****   * @brief Pointer on the function provided by the PMWC component instance to set the PWM duty cycl
 121:Inc/pwm_curr_fdbk.h ****   *        in RL detection mode.
 122:Inc/pwm_curr_fdbk.h ****   *
 123:Inc/pwm_curr_fdbk.h ****   * This type is needed because the actual function to use can change at run-time
 124:Inc/pwm_curr_fdbk.h ****   * (See PWMC_Handle::pFctRLDetectionModeSetDuty).
 125:Inc/pwm_curr_fdbk.h ****   *
 126:Inc/pwm_curr_fdbk.h ****   */
 127:Inc/pwm_curr_fdbk.h **** typedef uint16_t (*PWMC_RLDetectSetDuty_Cb_t)(PWMC_Handle_t *pHandle, uint16_t hDuty);
 128:Inc/pwm_curr_fdbk.h **** 
 129:Inc/pwm_curr_fdbk.h **** /**
 130:Inc/pwm_curr_fdbk.h ****   * @brief Pointer on the function provided by the PMWC component instance to set the calibrated of
 131:Inc/pwm_curr_fdbk.h ****   *        in RL detection mode.
 132:Inc/pwm_curr_fdbk.h ****   *
 133:Inc/pwm_curr_fdbk.h ****   * This type is needed because the actual function to use can change at run-time
ARM GAS  /tmp/cccnQOYj.s 			page 51


 134:Inc/pwm_curr_fdbk.h ****   * (See PWMC_Handle::pFctSetOffsetCalib).
 135:Inc/pwm_curr_fdbk.h ****   *
 136:Inc/pwm_curr_fdbk.h ****   */
 137:Inc/pwm_curr_fdbk.h **** typedef void (*PWMC_SetOffsetCalib_Cb_t)(PWMC_Handle_t *pHandle, PolarizationOffsets_t *offsets);
 138:Inc/pwm_curr_fdbk.h **** 
 139:Inc/pwm_curr_fdbk.h **** /**
 140:Inc/pwm_curr_fdbk.h ****   * @brief Pointer on the function provided by the PMWC component instance to get the calibrated of
 141:Inc/pwm_curr_fdbk.h ****   *        in RL detection mode.
 142:Inc/pwm_curr_fdbk.h ****   *
 143:Inc/pwm_curr_fdbk.h ****   * This type is needed because the actual function to use can change at run-time
 144:Inc/pwm_curr_fdbk.h ****   */
 145:Inc/pwm_curr_fdbk.h **** typedef void (*PWMC_GetOffsetCalib_Cb_t)(PWMC_Handle_t *pHandle, PolarizationOffsets_t *offsets);
 146:Inc/pwm_curr_fdbk.h **** 
 147:Inc/pwm_curr_fdbk.h **** /**
 148:Inc/pwm_curr_fdbk.h ****   * @brief This structure is used to handle the data of an instance of the PWM & Current Feedback c
 149:Inc/pwm_curr_fdbk.h ****   *
 150:Inc/pwm_curr_fdbk.h ****   */
 151:Inc/pwm_curr_fdbk.h **** struct PWMC_Handle
 152:Inc/pwm_curr_fdbk.h **** {
 153:Inc/pwm_curr_fdbk.h ****   /** @{ */
 154:Inc/pwm_curr_fdbk.h ****   PWMC_GetPhaseCurr_Cb_t
 155:Inc/pwm_curr_fdbk.h ****   pFctGetPhaseCurrents;                      /**< Pointer on the function the component instance us
 156:Inc/pwm_curr_fdbk.h ****   PWMC_Generic_Cb_t
 157:Inc/pwm_curr_fdbk.h ****   pFctSwitchOffPwm;                          /**< Pointer on the function the component instance us
 158:Inc/pwm_curr_fdbk.h ****   PWMC_Generic_Cb_t
 159:Inc/pwm_curr_fdbk.h ****   pFctSwitchOnPwm;                           /**< Pointer on the function the component instance us
 160:Inc/pwm_curr_fdbk.h ****   PWMC_Generic_Cb_t
 161:Inc/pwm_curr_fdbk.h ****   pFctCurrReadingCalib;                      /**< Pointer on the fct the component instance uses to
 162:Inc/pwm_curr_fdbk.h ****   PWMC_TurnOnLowSides_Cb_t
 163:Inc/pwm_curr_fdbk.h ****   pFctTurnOnLowSides;                        /**< Pointer on the function the component instance us
 164:Inc/pwm_curr_fdbk.h ****   PWMC_SetSampPointSectX_Cb_t
 165:Inc/pwm_curr_fdbk.h ****   pFctSetADCSampPointSectX;                  /**< Pointer on the function the component instance us
 166:Inc/pwm_curr_fdbk.h ****   PWMC_SetOcpRefVolt_Cb_t
 167:Inc/pwm_curr_fdbk.h ****   pFctOCPSetReferenceVoltage;                /**< Pointer on the fct the component instance uses to
 168:Inc/pwm_curr_fdbk.h ****   PWMC_Generic_Cb_t
 169:Inc/pwm_curr_fdbk.h ****   pFctRLDetectionModeEnable;                 /**< Pointer on the function the component instance us
 170:Inc/pwm_curr_fdbk.h ****   PWMC_Generic_Cb_t
 171:Inc/pwm_curr_fdbk.h ****   pFctRLDetectionModeDisable;                /**< Pointer on the function the component instance us
 172:Inc/pwm_curr_fdbk.h ****   PWMC_RLDetectSetDuty_Cb_t
 173:Inc/pwm_curr_fdbk.h ****   pFctRLDetectionModeSetDuty;                /**< Pointer on the fct the component instance uses to
 174:Inc/pwm_curr_fdbk.h ****                                                   detection mode. */
 175:Inc/pwm_curr_fdbk.h ****   PWMC_Generic_Cb_t
 176:Inc/pwm_curr_fdbk.h ****   pFctRLTurnOnLowSidesAndStart;              /**< Pointer on the function the component instance us
 177:Inc/pwm_curr_fdbk.h ****   PWMC_SetOffsetCalib_Cb_t
 178:Inc/pwm_curr_fdbk.h ****   pFctSetOffsetCalib;                        /**< Pointer on the fct the component instance uses to
 179:Inc/pwm_curr_fdbk.h ****   PWMC_GetOffsetCalib_Cb_t
 180:Inc/pwm_curr_fdbk.h ****   pFctGetOffsetCalib;                        /**< Pointer on the fct the component instance uses to
 181:Inc/pwm_curr_fdbk.h ****   /** @} */
 182:Inc/pwm_curr_fdbk.h ****   int32_t   LPFIqBuf;                        /**< Low Pass Filter buffer used for averaged @f$ I_q 
 183:Inc/pwm_curr_fdbk.h ****   int32_t   LPFIdBuf;                        /**< Low Pass Filter Buffer used for averaged @f$ I_d 
 184:Inc/pwm_curr_fdbk.h ****   GPIO_TypeDef * pwm_en_u_port;                        /*!< Channel 1N (low side) GPIO output */
 185:Inc/pwm_curr_fdbk.h ****   GPIO_TypeDef * pwm_en_v_port;                        /*!< Channel 2N (low side) GPIO output*/
 186:Inc/pwm_curr_fdbk.h ****   GPIO_TypeDef * pwm_en_w_port;                        /*!< Channel 3N (low side)  GPIO output */
 187:Inc/pwm_curr_fdbk.h ****   uint16_t pwm_en_u_pin;                               /*!< Channel 1N (low side) GPIO output pin. 
 188:Inc/pwm_curr_fdbk.h ****   uint16_t pwm_en_v_pin;                               /*!< Channel 2N (low side) GPIO output pin. 
 189:Inc/pwm_curr_fdbk.h ****   uint16_t pwm_en_w_pin;                               /*!< Channel 3N (low side)  GPIO output pin.
 190:Inc/pwm_curr_fdbk.h ****   uint16_t  hT_Sqrt3;                                  /**< Constant used by PWM algorithm (@f$\sqr
ARM GAS  /tmp/cccnQOYj.s 			page 52


 191:Inc/pwm_curr_fdbk.h ****   uint16_t  CntPhA;                                    /**< PWM Duty cycle for phase A. */
 192:Inc/pwm_curr_fdbk.h ****   uint16_t  CntPhB;                                    /**< PWM Duty cycle for phase B. */
 193:Inc/pwm_curr_fdbk.h ****   uint16_t  CntPhC;                                    /**< PWM Duty cycle for phase C. */
 194:Inc/pwm_curr_fdbk.h ****   uint16_t  SWerror;                                   /**< Contains status about SW error. */
 195:Inc/pwm_curr_fdbk.h ****   uint16_t  lowDuty;
 196:Inc/pwm_curr_fdbk.h ****   uint16_t  midDuty;
 197:Inc/pwm_curr_fdbk.h ****   uint16_t  highDuty;
 198:Inc/pwm_curr_fdbk.h ****   uint16_t  HighDutyStored;                            /**< Discontinuous PWM Store current Highest
 199:Inc/pwm_curr_fdbk.h ****   uint16_t  OffCalibrWaitTimeCounter;                  /**< Counter to wait fixed time before motor
 200:Inc/pwm_curr_fdbk.h ****                                                             current measurement offset calibration.
 201:Inc/pwm_curr_fdbk.h ****   int16_t   Ia;                                        /**< Last @f$I_{a}@f$ measurement. */
 202:Inc/pwm_curr_fdbk.h ****   int16_t   Ib;                                        /**< Last @f$I_{b}@f$ measurement. */
 203:Inc/pwm_curr_fdbk.h ****   int16_t   Ic;                                        /**< Last @f$I_{c}@f$ measurement. */
 204:Inc/pwm_curr_fdbk.h ****   int16_t   IaEst;                           /**< Estimated @f$I_{a}@f$ based on averaged @f$ I_q @
 205:Inc/pwm_curr_fdbk.h ****   int16_t   IbEst;                           /**< Estimated @f$I_{b}@f$ based on averaged @f$ I_q @
 206:Inc/pwm_curr_fdbk.h ****   int16_t   IcEst;                           /**< Estimated @f$I_{c}@f$ based on averaged @f$ I_q @
 207:Inc/pwm_curr_fdbk.h ****   int16_t   LPFIqd_const;                              /**< Low pass filter constant (averaging coe
 208:Inc/pwm_curr_fdbk.h ****   uint16_t PWMperiod;                                  /**< PWM period expressed in timer clock cyc
 209:Inc/pwm_curr_fdbk.h ****                                                          *  @f$hPWMPeriod = TimerFreq_{CLK} / F_{PW
 210:Inc/pwm_curr_fdbk.h ****   uint16_t DTCompCnt;                                  /**< Half of Dead time expressed
 211:Inc/pwm_curr_fdbk.h ****                                                           *  in timer clock cycles unit:
 212:Inc/pwm_curr_fdbk.h ****                                                           *  @f$hDTCompCnt = (DT_s \cdot TimerFreq_
 213:Inc/pwm_curr_fdbk.h ****   uint16_t  Ton;                                       /**< Reserved. */
 214:Inc/pwm_curr_fdbk.h ****   uint16_t  Toff;                                      /**< Reserved. */
 215:Inc/pwm_curr_fdbk.h ****   uint8_t   Motor;                                     /**< Motor reference number. */
 216:Inc/pwm_curr_fdbk.h ****   uint8_t   AlignFlag;                                 /**< Phase current 0 is reliable, 1 is not. 
 217:Inc/pwm_curr_fdbk.h ****   uint8_t   Sector;                                    /**< Space vector sector number. */
 218:Inc/pwm_curr_fdbk.h ****   LowSideOutputsFunction_t LowSideOutputs;             /*!< Low side or enabling signals generation
 219:Inc/pwm_curr_fdbk.h ****   bool TurnOnLowSidesAction;                           /**< True if TurnOnLowSides action is active
 220:Inc/pwm_curr_fdbk.h ****                                                             false otherwise. */
 221:Inc/pwm_curr_fdbk.h ****   bool      DPWM_Mode;                                 /**< Discontinuous PWM mode activation. */
 222:Inc/pwm_curr_fdbk.h ****   bool      RLDetectionMode;                           /**< True if enabled, false if disabled. */
 223:Inc/pwm_curr_fdbk.h ****   bool offsetCalibStatus;                              /**< True if offset calibration completed, f
 224:Inc/pwm_curr_fdbk.h ****   bool OverCurrentFlag;         /* This flag is set when an overcurrent occurs.*/
 225:Inc/pwm_curr_fdbk.h ****   bool OverVoltageFlag;         /* This flag is set when an overvoltage occurs.*/
 226:Inc/pwm_curr_fdbk.h ****   bool driverProtectionFlag;     /* This flag is set when a driver protection occurs.*/
 227:Inc/pwm_curr_fdbk.h ****   bool BrakeActionLock;         /* This flag is set to avoid that brake action is interrupted.*/
 228:Inc/pwm_curr_fdbk.h ****   volatile  bool      useEstCurrent;                   /**< Estimated current flag. */
 229:Inc/pwm_curr_fdbk.h **** 
 230:Inc/pwm_curr_fdbk.h ****   bool SingleShuntTopology;                            /*!< This flag is set when Single Shunt topo
 231:Inc/pwm_curr_fdbk.h **** };
 232:Inc/pwm_curr_fdbk.h **** 
 233:Inc/pwm_curr_fdbk.h **** /**
 234:Inc/pwm_curr_fdbk.h ****   * @brief  Current reading calibration definition.
 235:Inc/pwm_curr_fdbk.h ****   */
 236:Inc/pwm_curr_fdbk.h **** typedef enum
 237:Inc/pwm_curr_fdbk.h **** {
 238:Inc/pwm_curr_fdbk.h ****   CRC_START, /**< Initializes the current reading calibration. */
 239:Inc/pwm_curr_fdbk.h ****   CRC_EXEC   /**< Executes the current reading calibration. */
 240:Inc/pwm_curr_fdbk.h **** } CRCAction_t;
 241:Inc/pwm_curr_fdbk.h **** 
 242:Inc/pwm_curr_fdbk.h **** /* Converts input voltages @f$ V_{\alpha} @f$ and @f$ V_{\beta} @f$ into PWM duty cycles
 243:Inc/pwm_curr_fdbk.h ****  * and feed them to the inverter. */
 244:Inc/pwm_curr_fdbk.h **** uint16_t PWMC_SetPhaseVoltage(PWMC_Handle_t *pHandle, alphabeta_t Valfa_beta);
 245:Inc/pwm_curr_fdbk.h **** 
 246:Inc/pwm_curr_fdbk.h **** /* Switches PWM generation off, inactivating the outputs. */
 247:Inc/pwm_curr_fdbk.h **** void PWMC_SwitchOffPWM(PWMC_Handle_t *pHandle);
ARM GAS  /tmp/cccnQOYj.s 			page 53


 248:Inc/pwm_curr_fdbk.h **** 
 249:Inc/pwm_curr_fdbk.h **** /* Enables PWM generation on the proper Timer peripheral. */
 250:Inc/pwm_curr_fdbk.h **** void PWMC_SwitchOnPWM(PWMC_Handle_t *pHandle);
 251:Inc/pwm_curr_fdbk.h **** 
 252:Inc/pwm_curr_fdbk.h **** /* Calibrates ADC current conversions by reading the offset voltage
 253:Inc/pwm_curr_fdbk.h ****  * present on ADC pins when no motor current is flowing in. */
 254:Inc/pwm_curr_fdbk.h **** bool PWMC_CurrentReadingCalibr(PWMC_Handle_t *pHandle, CRCAction_t action);
 255:Inc/pwm_curr_fdbk.h **** 
 256:Inc/pwm_curr_fdbk.h **** /* Switches power stage Low Sides transistors on. */
 257:Inc/pwm_curr_fdbk.h **** void PWMC_TurnOnLowSides(PWMC_Handle_t *pHandle, uint32_t ticks);
 258:Inc/pwm_curr_fdbk.h **** 
 259:Inc/pwm_curr_fdbk.h **** /* Sets the calibrated @p offsets for each of the phases in the @p pHandle handler. In case
 260:Inc/pwm_curr_fdbk.h ****  * of single shunt only phase A is relevant. */
 261:Inc/pwm_curr_fdbk.h **** void PWMC_SetOffsetCalib(PWMC_Handle_t *pHandle, PolarizationOffsets_t *offsets);
 262:Inc/pwm_curr_fdbk.h **** 
 263:Inc/pwm_curr_fdbk.h **** /* Gets the calibrated @p offsets for each of the phases in the @p pHandle handler. In case
 264:Inc/pwm_curr_fdbk.h ****  * of single shunt only phase A is relevant. */
 265:Inc/pwm_curr_fdbk.h **** void PWMC_GetOffsetCalib(PWMC_Handle_t *pHandle, PolarizationOffsets_t *offsets);
 266:Inc/pwm_curr_fdbk.h **** 
 267:Inc/pwm_curr_fdbk.h **** /* Manages HW overcurrent protection. */
 268:Inc/pwm_curr_fdbk.h **** void *PWMC_OCP_Handler(PWMC_Handle_t *pHandle);
 269:Inc/pwm_curr_fdbk.h **** 
 270:Inc/pwm_curr_fdbk.h **** /* Manages driver protection. */
 271:Inc/pwm_curr_fdbk.h **** void *PWMC_DP_Handler(PWMC_Handle_t *pHandle);
 272:Inc/pwm_curr_fdbk.h **** 
 273:Inc/pwm_curr_fdbk.h **** /* Manages HW overvoltage protection. */
 274:Inc/pwm_curr_fdbk.h **** void *PWMC_OVP_Handler(PWMC_Handle_t *pHandle, TIM_TypeDef *TIMx);
 275:Inc/pwm_curr_fdbk.h **** 
 276:Inc/pwm_curr_fdbk.h **** /* Checks if a fault (OCP, DP or OVP) occurred since last call. */
 277:Inc/pwm_curr_fdbk.h **** uint16_t PWMC_IsFaultOccurred(PWMC_Handle_t *pHandle);
 278:Inc/pwm_curr_fdbk.h **** 
 279:Inc/pwm_curr_fdbk.h **** /* Sets the over current threshold through the DAC reference voltage. */
 280:Inc/pwm_curr_fdbk.h **** void PWMC_OCPSetReferenceVoltage(PWMC_Handle_t *pHandle, uint16_t hDACVref);
 281:Inc/pwm_curr_fdbk.h **** 
 282:Inc/pwm_curr_fdbk.h **** /* Enables Discontinuous PWM mode using the @p pHandle PWMC component. */
 283:Inc/pwm_curr_fdbk.h **** void PWMC_DPWM_ModeEnable(PWMC_Handle_t *pHandle);
 284:Inc/pwm_curr_fdbk.h **** 
 285:Inc/pwm_curr_fdbk.h **** /* Disables Discontinuous PWM mode using the @p pHandle PWMC component. */
 286:Inc/pwm_curr_fdbk.h **** void PWMC_DPWM_ModeDisable(PWMC_Handle_t *pHandle);
 287:Inc/pwm_curr_fdbk.h **** 
 288:Inc/pwm_curr_fdbk.h **** /* Returns the status of the Discontinuous PWM Mode stored in the @p pHandle PWMC component. */
 289:Inc/pwm_curr_fdbk.h **** bool PWMC_GetDPWM_Mode(PWMC_Handle_t *pHandle);
 290:Inc/pwm_curr_fdbk.h **** 
 291:Inc/pwm_curr_fdbk.h **** /* Enables the RL detection mode by calling the function in @p pHandle PWMC component. */
 292:Inc/pwm_curr_fdbk.h **** void PWMC_RLDetectionModeEnable(PWMC_Handle_t *pHandle);
 293:Inc/pwm_curr_fdbk.h **** 
 294:Inc/pwm_curr_fdbk.h **** /* Disables the RL detection mode by calling the function in @p pHandle PWMC component. */
 295:Inc/pwm_curr_fdbk.h **** void PWMC_RLDetectionModeDisable(PWMC_Handle_t *pHandle);
 296:Inc/pwm_curr_fdbk.h **** 
 297:Inc/pwm_curr_fdbk.h **** /* Sets the PWM duty cycle to apply in the RL Detection mode. */
 298:Inc/pwm_curr_fdbk.h **** uint16_t PWMC_RLDetectionModeSetDuty(PWMC_Handle_t *pHandle, uint16_t hDuty);
 299:Inc/pwm_curr_fdbk.h **** 
 300:Inc/pwm_curr_fdbk.h **** /* Turns on low sides switches and starts ADC triggerin. */
 301:Inc/pwm_curr_fdbk.h **** void PWMC_RLTurnOnLowSidesAndStart(PWMC_Handle_t *pHandle);
 302:Inc/pwm_curr_fdbk.h **** 
 303:Inc/pwm_curr_fdbk.h **** /* Sets the Callback that the PWMC component shall invoke to get phases current. */
 304:Inc/pwm_curr_fdbk.h **** void PWMC_RegisterGetPhaseCurrentsCallBack(PWMC_GetPhaseCurr_Cb_t pCallBack, PWMC_Handle_t *pHandle
ARM GAS  /tmp/cccnQOYj.s 			page 54


 305:Inc/pwm_curr_fdbk.h **** 
 306:Inc/pwm_curr_fdbk.h **** /* Sets the Callback that the PWMC component shall invoke to switch PWM generation off. */
 307:Inc/pwm_curr_fdbk.h **** void PWMC_RegisterSwitchOffPwmCallBack(PWMC_Generic_Cb_t pCallBack, PWMC_Handle_t *pHandle);
 308:Inc/pwm_curr_fdbk.h **** 
 309:Inc/pwm_curr_fdbk.h **** /* Sets the Callback that the PWMC component shall invoke to switch PWM generation on. */
 310:Inc/pwm_curr_fdbk.h **** void PWMC_RegisterSwitchonPwmCallBack(PWMC_Generic_Cb_t pCallBack, PWMC_Handle_t *pHandle);
 311:Inc/pwm_curr_fdbk.h **** 
 312:Inc/pwm_curr_fdbk.h **** /* Sets the Callback that the PWMC component shall invoke to execute a calibration of the current s
 313:Inc/pwm_curr_fdbk.h **** void PWMC_RegisterReadingCalibrationCallBack(PWMC_Generic_Cb_t pCallBack, PWMC_Handle_t *pHandle);
 314:Inc/pwm_curr_fdbk.h **** 
 315:Inc/pwm_curr_fdbk.h **** /* Sets the Callback that the PWMC component shall invoke to turn low sides on. */
 316:Inc/pwm_curr_fdbk.h **** void PWMC_RegisterTurnOnLowSidesCallBack(PWMC_TurnOnLowSides_Cb_t pCallBack, PWMC_Handle_t *pHandle
 317:Inc/pwm_curr_fdbk.h **** 
 318:Inc/pwm_curr_fdbk.h **** /* Sets the Callback that the PWMC component shall invoke to compute ADC sampling point. */
 319:Inc/pwm_curr_fdbk.h **** void PWMC_RegisterSampPointSectXCallBack(PWMC_SetSampPointSectX_Cb_t pCallBack, PWMC_Handle_t *pHan
 320:Inc/pwm_curr_fdbk.h **** 
 321:Inc/pwm_curr_fdbk.h **** /* Sets the Callback that the PWMC component shall invoke to set the reference voltage for the over
 322:Inc/pwm_curr_fdbk.h ****   * protection. */
 323:Inc/pwm_curr_fdbk.h **** void PWMC_RegisterOCPSetRefVoltageCallBack(PWMC_SetOcpRefVolt_Cb_t pCallBack, PWMC_Handle_t *pHandl
 324:Inc/pwm_curr_fdbk.h **** 
 325:Inc/pwm_curr_fdbk.h **** /* Sets the Callback that the PWMC component shall invoke to enable the R/L detection mode. */
 326:Inc/pwm_curr_fdbk.h **** void PWMC_RegisterRLDetectionModeEnableCallBack(PWMC_Generic_Cb_t pCallBack, PWMC_Handle_t *pHandle
 327:Inc/pwm_curr_fdbk.h **** 
 328:Inc/pwm_curr_fdbk.h **** /* Sets the Callback that the PWMC component shall invoke to disable the R/L detection mode. */
 329:Inc/pwm_curr_fdbk.h **** void PWMC_RegisterRLDetectionModeDisableCallBack(PWMC_Generic_Cb_t pCallBack, PWMC_Handle_t *pHandl
 330:Inc/pwm_curr_fdbk.h **** 
 331:Inc/pwm_curr_fdbk.h **** /* Sets the Callback that the PWMC component shall invoke to set the duty cycle for the R/L detecti
 332:Inc/pwm_curr_fdbk.h **** void PWMC_RegisterRLDetectionModeSetDutyCallBack(PWMC_RLDetectSetDuty_Cb_t pCallBack, PWMC_Handle_t
 333:Inc/pwm_curr_fdbk.h **** 
 334:Inc/pwm_curr_fdbk.h **** /* Used to clear variables in CPWMC. */
 335:Inc/pwm_curr_fdbk.h **** void PWMC_Clear(PWMC_Handle_t *pHandle);
 336:Inc/pwm_curr_fdbk.h **** 
 337:Inc/pwm_curr_fdbk.h **** /* Converts input currents components Iqd into estimated currents Ia, Ib and Ic. */
 338:Inc/pwm_curr_fdbk.h **** void PWMC_CalcPhaseCurrentsEst(PWMC_Handle_t *pHandle, qd_t Iqd, int16_t hElAngledpp);
 339:Inc/pwm_curr_fdbk.h **** 
 340:Inc/pwm_curr_fdbk.h **** /* Converts input voltage components @f$ V_{\alpha} @f$ and @f$ V_{\beta} @f$ into duty cycles
 341:Inc/pwm_curr_fdbk.h ****  * and feed them to the inverter with overmodulation function. */
 342:Inc/pwm_curr_fdbk.h **** uint16_t PWMC_SetPhaseVoltage_OVM(PWMC_Handle_t *pHandle, alphabeta_t Valfa_beta);
 343:Inc/pwm_curr_fdbk.h **** 
 344:Inc/pwm_curr_fdbk.h **** /**
 345:Inc/pwm_curr_fdbk.h ****   * @brief Returns the phase current of the motor as read by the ADC (in s16A unit).
 346:Inc/pwm_curr_fdbk.h ****   *
 347:Inc/pwm_curr_fdbk.h ****   * Returns the current values of phases A & B. Phase C current
 348:Inc/pwm_curr_fdbk.h ****   * can be deduced thanks to the formula:
 349:Inc/pwm_curr_fdbk.h ****   *
 350:Inc/pwm_curr_fdbk.h ****   * @f[
 351:Inc/pwm_curr_fdbk.h ****   * I_{C} = -I_{A} - I_{B}
 352:Inc/pwm_curr_fdbk.h ****   * @f]
 353:Inc/pwm_curr_fdbk.h ****   *
 354:Inc/pwm_curr_fdbk.h ****   * @param  pHandle: Handler of the current instance of the PWM component.
 355:Inc/pwm_curr_fdbk.h ****   * @param  Iab: Pointer to the structure that will receive motor current
 356:Inc/pwm_curr_fdbk.h ****   *         of phases A & B in ElectricalValue format.
 357:Inc/pwm_curr_fdbk.h ****   */
 358:Inc/pwm_curr_fdbk.h **** //cstat !MISRAC2012-Rule-8.13 !RED-func-no-effect
 359:Inc/pwm_curr_fdbk.h **** static inline void PWMC_GetPhaseCurrents(PWMC_Handle_t *pHandle, ab_t *Iab)
 1418              		.loc 4 359 20 view .LVU362
 1419              	.LBB32:
ARM GAS  /tmp/cccnQOYj.s 			page 55


 360:Inc/pwm_curr_fdbk.h **** {
 361:Inc/pwm_curr_fdbk.h **** #ifdef NULL_PTR_CHECK_PWR_CUR_FDB
 362:Inc/pwm_curr_fdbk.h ****   if (MC_NULL == pHandle)
 363:Inc/pwm_curr_fdbk.h ****   {
 364:Inc/pwm_curr_fdbk.h ****     /* Nothing to do */
 365:Inc/pwm_curr_fdbk.h ****   }
 366:Inc/pwm_curr_fdbk.h ****   else
 367:Inc/pwm_curr_fdbk.h ****   {
 368:Inc/pwm_curr_fdbk.h **** #endif
 369:Inc/pwm_curr_fdbk.h ****     pHandle->pFctGetPhaseCurrents(pHandle, Iab);
 1420              		.loc 4 369 5 view .LVU363
 1421 0018 0368     		ldr	r3, [r0]
 1422 001a 01A9     		add	r1, sp, #4
 1423              	.LVL133:
 1424              		.loc 4 369 5 is_stmt 0 view .LVU364
 1425 001c 9847     		blx	r3
 1426              	.LVL134:
 1427              		.loc 4 369 5 view .LVU365
 1428              	.LBE32:
 1429              	.LBE31:
 693:Src/mc_tasks_foc.c ****   FOCVars[M1].Iab = Iab;
 1430              		.loc 1 693 3 is_stmt 1 view .LVU366
 1431              		.loc 1 693 19 is_stmt 0 view .LVU367
 1432 001e 0198     		ldr	r0, [sp, #4]
 1433 0020 0C4B     		ldr	r3, .L76+8
 1434 0022 1860     		str	r0, [r3]	@ unaligned
 694:Src/mc_tasks_foc.c ****   SCC_SetPhaseVoltage(&SCC);
 1435              		.loc 1 694 3 is_stmt 1 view .LVU368
 1436 0024 0C48     		ldr	r0, .L76+12
 1437 0026 FFF7FEFF 		bl	SCC_SetPhaseVoltage
 1438              	.LVL135:
 695:Src/mc_tasks_foc.c **** 
 696:Src/mc_tasks_foc.c ****   return (0); /* Single motor only */
 1439              		.loc 1 696 3 view .LVU369
 697:Src/mc_tasks_foc.c **** }
 1440              		.loc 1 697 1 is_stmt 0 view .LVU370
 1441 002a 0020     		movs	r0, #0
 1442 002c 03B0     		add	sp, sp, #12
 1443              	.LCFI17:
 1444              		.cfi_remember_state
 1445              		.cfi_def_cfa_offset 4
 1446              		@ sp needed
 1447 002e 5DF804FB 		ldr	pc, [sp], #4
 1448              	.LVL136:
 1449              	.L75:
 1450              	.LCFI18:
 1451              		.cfi_restore_state
 673:Src/mc_tasks_foc.c ****     {
 1452              		.loc 1 673 5 is_stmt 1 view .LVU371
 673:Src/mc_tasks_foc.c ****     {
 1453              		.loc 1 673 10 is_stmt 0 view .LVU372
 1454 0032 0A4B     		ldr	r3, .L76+16
 1455 0034 1868     		ldr	r0, [r3]
 1456              	.LVL137:
 673:Src/mc_tasks_foc.c ****     {
 1457              		.loc 1 673 10 view .LVU373
 1458 0036 FFF7FEFF 		bl	REMNG_RampCompleted
ARM GAS  /tmp/cccnQOYj.s 			page 56


 1459              	.LVL138:
 673:Src/mc_tasks_foc.c ****     {
 1460              		.loc 1 673 8 view .LVU374
 1461 003a 0028     		cmp	r0, #0
 1462 003c E6D1     		bne	.L73
 675:Src/mc_tasks_foc.c ****     }
 1463              		.loc 1 675 7 is_stmt 1 view .LVU375
 675:Src/mc_tasks_foc.c ****     }
 1464              		.loc 1 675 39 is_stmt 0 view .LVU376
 1465 003e 074B     		ldr	r3, .L76+16
 1466 0040 1868     		ldr	r0, [r3]
 1467 0042 FFF7FEFF 		bl	REMNG_Calc
 1468              	.LVL139:
 675:Src/mc_tasks_foc.c ****     }
 1469              		.loc 1 675 28 view .LVU377
 1470 0046 034B     		ldr	r3, .L76+8
 675:Src/mc_tasks_foc.c ****     }
 1471              		.loc 1 675 30 view .LVU378
 1472 0048 1882     		strh	r0, [r3, #16]	@ movhi
 1473 004a DFE7     		b	.L73
 1474              	.L77:
 1475              		.align	2
 1476              	.L76:
 1477 004c 00000000 		.word	Mci
 1478 0050 00000000 		.word	pwmcHandle
 1479 0054 00000000 		.word	FOCVars
 1480 0058 00000000 		.word	SCC
 1481 005c 00000000 		.word	pREMNG
 1482              		.cfi_endproc
 1483              	.LFE1873:
 1485              		.section	.bss.hBootCapDelayCounterM1,"aw",%nobits
 1486              		.align	1
 1489              	hBootCapDelayCounterM1:
 1490 0000 0000     		.space	2
 1491              		.section	.bss.hStopPermanencyCounterM1,"aw",%nobits
 1492              		.align	1
 1495              	hStopPermanencyCounterM1:
 1496 0000 0000     		.space	2
 1497              		.weak	STO_SetDirection
 1498              		.text
 1499              	.Letext0:
 1500              		.file 5 "/usr/share/gcc-arm-none-eabi-10-2020-q4-major/arm-none-eabi/include/machine/_default_type
 1501              		.file 6 "/usr/share/gcc-arm-none-eabi-10-2020-q4-major/arm-none-eabi/include/sys/_stdint.h"
 1502              		.file 7 "Drivers/CMSIS/Device/ST/STM32G4xx/Include/stm32g431xx.h"
 1503              		.file 8 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_tim.h"
 1504              		.file 9 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_usart.h"
 1505              		.file 10 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_dma.h"
 1506              		.file 11 "Inc/mc_type.h"
 1507              		.file 12 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/pid_regulator.h"
 1508              		.file 13 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h"
 1509              		.file 14 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/virtual_speed_sensor.h"
 1510              		.file 15 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/sto_speed_pos_fdbk.h"
 1511              		.file 16 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/revup_ctrl.h"
 1512              		.file 17 "Inc/mc_perf.h"
 1513              		.file 18 "Inc/mc_interface.h"
 1514              		.file 19 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/bus_voltage_sensor.h"
 1515              		.file 20 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/r_divider_bus_voltage_sensor.h"
ARM GAS  /tmp/cccnQOYj.s 			page 57


 1516              		.file 21 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/sto_pll_speed_pos_fdbk.h"
 1517              		.file 22 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/ramp_ext_mngr.h"
 1518              		.file 23 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/mp_one_touch_tuning.h"
 1519              		.file 24 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/circle_limitation.h"
 1520              		.file 25 "Inc/hall_speed_pos_fdbk.h"
 1521              		.file 26 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/mp_hall_tuning.h"
 1522              		.file 27 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/mp_self_com_ctrl.h"
 1523              		.file 28 "Inc/mc_config_common.h"
 1524              		.file 29 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/feed_forward_ctrl.h"
 1525              		.file 30 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/pqd_motor_power_measurement.h"
 1526              		.file 31 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/G4xx/Inc/r3_2_g4xx_pwm_curr_fdbk.h"
 1527              		.file 32 "Inc/mc_config.h"
 1528              		.file 33 "Inc/regular_conversion_manager.h"
 1529              		.file 34 "Inc/mc_math.h"
 1530              		.file 35 "Inc/mc_tasks.h"
 1531              		.file 36 "Inc/pwm_common.h"
ARM GAS  /tmp/cccnQOYj.s 			page 58


DEFINED SYMBOLS
                            *ABS*:0000000000000000 mc_tasks_foc.c
     /tmp/cccnQOYj.s:18     .text.FOC_Clear:0000000000000000 $t
     /tmp/cccnQOYj.s:26     .text.FOC_Clear:0000000000000000 FOC_Clear
     /tmp/cccnQOYj.s:126    .text.FOC_Clear:0000000000000070 $d
     /tmp/cccnQOYj.s:137    .text.FOC_Init:0000000000000000 $t
     /tmp/cccnQOYj.s:144    .text.FOC_Init:0000000000000000 FOC_Init
     /tmp/cccnQOYj.s:352    .text.FOC_Init:0000000000000124 $d
     /tmp/cccnQOYj.s:379    .text.TSK_MF_StopProcessing:0000000000000000 $t
     /tmp/cccnQOYj.s:386    .text.TSK_MF_StopProcessing:0000000000000000 TSK_MF_StopProcessing
     /tmp/cccnQOYj.s:435    .text.TSK_MF_StopProcessing:0000000000000038 $d
     /tmp/cccnQOYj.s:443    .text.FOC_InitAdditionalMethods:0000000000000000 $t
     /tmp/cccnQOYj.s:450    .text.FOC_InitAdditionalMethods:0000000000000000 FOC_InitAdditionalMethods
     /tmp/cccnQOYj.s:491    .text.FOC_InitAdditionalMethods:0000000000000018 $d
     /tmp/cccnQOYj.s:496    .text.FOC_CalcCurrRef:0000000000000000 $t
     /tmp/cccnQOYj.s:503    .text.FOC_CalcCurrRef:0000000000000000 FOC_CalcCurrRef
     /tmp/cccnQOYj.s:652    .text.FOC_CalcCurrRef:000000000000006c $d
     /tmp/cccnQOYj.s:659    .text.TSK_MediumFrequencyTaskM1:0000000000000000 $t
     /tmp/cccnQOYj.s:666    .text.TSK_MediumFrequencyTaskM1:0000000000000000 TSK_MediumFrequencyTaskM1
     /tmp/cccnQOYj.s:746    .text.TSK_MediumFrequencyTaskM1:0000000000000050 $d
     /tmp/cccnQOYj.s:767    .text.TSK_MediumFrequencyTaskM1:00000000000000a4 $t
     /tmp/cccnQOYj.s:1227   .text.TSK_MediumFrequencyTaskM1:00000000000002dc $d
     /tmp/cccnQOYj.s:1242   .text.TSK_MediumFrequencyTaskM1:000000000000030c $t
     /tmp/cccnQOYj.s:1361   .text.TSK_MediumFrequencyTaskM1:00000000000003a8 $d
     /tmp/cccnQOYj.s:1372   .text.FOC_HighFrequencyTask:0000000000000000 $t
     /tmp/cccnQOYj.s:1379   .text.FOC_HighFrequencyTask:0000000000000000 FOC_HighFrequencyTask
     /tmp/cccnQOYj.s:1477   .text.FOC_HighFrequencyTask:000000000000004c $d
     /tmp/cccnQOYj.s:1486   .bss.hBootCapDelayCounterM1:0000000000000000 $d
     /tmp/cccnQOYj.s:1489   .bss.hBootCapDelayCounterM1:0000000000000000 hBootCapDelayCounterM1
     /tmp/cccnQOYj.s:1492   .bss.hStopPermanencyCounterM1:0000000000000000 $d
     /tmp/cccnQOYj.s:1495   .bss.hStopPermanencyCounterM1:0000000000000000 hStopPermanencyCounterM1

UNDEFINED SYMBOLS
PID_SetIntegralTerm
STC_Clear
PWMC_SwitchOffPWM
FF_Clear
MC_Perf_Clear
FOCVars
pPIDIq
pPIDId
pSTC
pwmcHandle
pFF
PerfTraces
R3_2_Init
startTimers
PID_HandleInit
STO_PLL_Init
STC_Init
RUC_Init
FF_Init
REMNG_Init
SCC_Init
OTT_Init
STC_GetDefaultIqdref
MCI_ExecTorqueRamp
ARM GAS  /tmp/cccnQOYj.s 			page 59


PWM_Handle_M1
PIDSpeedHandle_M1
STO_PLL_M1
STO_M1
VirtualSpeedSensorM1
RevUpControlM1
PIDIqHandle_M1
PIDIdHandle_M1
pMPM
RampExtMngrHFParamsM1
pREMNG
SCC
CircleLimitationM1
BusVoltageSensor_M1
Mci
SpeednTorqCtrlM1
OTT
R3_2_SwitchOffPWM
SCC_Stop
OTT_Stop
TSK_SetStopPermanencyTimeM1
FF_InitFOCAdditionalMethods
STC_CalcTorqueReference
FF_VqdffComputation
STO_PLL_CalcAvrgMecSpeedUnit
PQD_CalcElMotorPower
MCI_GetCurrentFaults
SCC_MF
MCI_GetOccurredFaults
MCI_GetImposedMotorDirection
RUC_Clear
PWMC_CurrentReadingCalibr
OTT_Clear
R3_2_TurnOnLowSides
TSK_SetChargeBootCapDelayM1
TSK_ChargeBootCapDelayHasElapsedM1
STC_SetSpeedSensor
STO_PLL_Clear
PWMC_Clear
SCC_Start
PWMC_SwitchOnPWM
RUC_Exec
VSS_CalcAvrgMecSpeedUnit
STO_PLL_IsObserverConverged
STO_SetDirection
VSS_SetStartTransition
MCM_Park
REMNG_ExecRamp
VSS_TransitionEnded
PID_GetKIDivisor
OTT_SR
STC_ForceSpeedReferenceToCurrentSpeed
MCI_ExecBufferedCommands
OTT_MF
MCI_FaultProcessing
TSK_StopPermanencyTimeHasElapsedM1
VSS_Clear
ARM GAS  /tmp/cccnQOYj.s 			page 60


SCC_DetectBemf
RCM_ReadOngoingConv
RCM_ExecNextConv
SCC_SetPhaseVoltage
REMNG_RampCompleted
REMNG_Calc
