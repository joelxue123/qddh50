ARM GAS  /tmp/ccbl8B2o.s 			page 1


   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 2
  13              		.file	"nvm.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.erase,"ax",%progbits
  18              		.align	1
  19              		.global	erase
  20              		.arch armv7e-m
  21              		.syntax unified
  22              		.thumb
  23              		.thumb_func
  24              		.fpu fpv4-sp-d16
  26              	erase:
  27              	.LVL0:
  28              	.LFB132:
  29              		.file 1 "Src/nvm.c"
   1:Src/nvm.c     **** /*
   2:Src/nvm.c     **** * Flash-based Non-Volatile Memory (NVM)
   3:Src/nvm.c     **** * 
   4:Src/nvm.c     **** * This file supports storing and loading persistent configuration based on
   5:Src/nvm.c     **** * the STM32 builtin flash memory.
   6:Src/nvm.c     **** *
   7:Src/nvm.c     **** * The STM32F405xx has 12 flash sectors of heterogeneous size. We use the last
   8:Src/nvm.c     **** * two sectors for configuration data. These pages have a size of 128kB each.
   9:Src/nvm.c     **** * Setting any bit in these sectors to 0 is always possible, but setting them
  10:Src/nvm.c     **** * to 1 requires erasing the whole sector.
  11:Src/nvm.c     **** *
  12:Src/nvm.c     **** * We consider each sector as an array of 64-bit fields except the first N bytes, which we
  13:Src/nvm.c     **** * instead use as an allocation block. The allocation block is a compact bit-field (2 bit per entry)
  14:Src/nvm.c     **** * that keeps track of the state of each field (erased, invalid, valid).
  15:Src/nvm.c     **** *
  16:Src/nvm.c     **** * One sector is always considered the valid (read) sector and the other one is the
  17:Src/nvm.c     **** * target for the next write access: they can be considered to be ping-pong or double buffred.
  18:Src/nvm.c     **** *
  19:Src/nvm.c     **** * When writing a block of data, instead of always erasing the whole writable sector the
  20:Src/nvm.c     **** * new data is appended in the erased area. This presumably increases flash life span.
  21:Src/nvm.c     **** * The writable sector is only erased if there is not enough space for the new data.
  22:Src/nvm.c     **** *
  23:Src/nvm.c     **** * On startup, if there is exactly one sector
  24:Src/nvm.c     **** * whose last non-erased value has the state "valid" that sector is considered
  25:Src/nvm.c     **** * the valid sector. In any other case the selection is undefined.
  26:Src/nvm.c     **** *
  27:Src/nvm.c     **** *
  28:Src/nvm.c     **** * To write a new block of data atomically we first mark all associated fields
  29:Src/nvm.c     **** * as "invalid" (in the allocation table) then write the data and then mark the
ARM GAS  /tmp/ccbl8B2o.s 			page 2


  30:Src/nvm.c     **** * fields as "valid" (in the direction of increasing address).
  31:Src/nvm.c     **** */
  32:Src/nvm.c     **** 
  33:Src/nvm.c     **** #include "nvm.h"
  34:Src/nvm.c     **** 
  35:Src/nvm.c     **** #include "stm32g4xx_hal.h"
  36:Src/nvm.c     **** 
  37:Src/nvm.c     **** #include <string.h>
  38:Src/nvm.c     **** #if defined(STM32G431xx)
  39:Src/nvm.c     **** // STM32G431 has 128KB flash organized as 64 pages of 2KB each
  40:Src/nvm.c     **** // Using last two pages (63 and 62) for configuration
  41:Src/nvm.c     **** // Refer to RM0440 Rev 7 Section 3.3.1
  42:Src/nvm.c     **** 
  43:Src/nvm.c     **** #define FLASH_PAGE_SIZE          0x800U    // 2KB per page
  44:Src/nvm.c     **** #define FLASH_PAGE_62           62U        // Second to last page
  45:Src/nvm.c     **** #define FLASH_PAGE_63           63U        // Last page
  46:Src/nvm.c     **** #define FLASH_BASE_ADDR         0x08000000U
  47:Src/nvm.c     **** 
  48:Src/nvm.c     **** #define FLASH_SECTOR_10_BASE    (const volatile uint8_t*)(FLASH_BASE_ADDR + (FLASH_PAGE_62 * FLASH_
  49:Src/nvm.c     **** #define FLASH_SECTOR_10_SIZE    FLASH_PAGE_SIZE
  50:Src/nvm.c     **** #define FLASH_SECTOR_11_BASE    (const volatile uint8_t*)(FLASH_BASE_ADDR + (FLASH_PAGE_63 * FLASH_
  51:Src/nvm.c     **** #define FLASH_SECTOR_11_SIZE    FLASH_PAGE_SIZE
  52:Src/nvm.c     **** 
  53:Src/nvm.c     **** // Update error flags for STM32G4
  54:Src/nvm.c     **** #define HAL_FLASH_ClearError() __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS)
  55:Src/nvm.c     **** 
  56:Src/nvm.c     **** #else
  57:Src/nvm.c     **** #error "Unsupported STM32 device"
  58:Src/nvm.c     **** #endif
  59:Src/nvm.c     **** 
  60:Src/nvm.c     **** 
  61:Src/nvm.c     **** typedef enum {
  62:Src/nvm.c     ****     VALID = 0,
  63:Src/nvm.c     ****     INVALID = 1,
  64:Src/nvm.c     ****     ERASED = 3
  65:Src/nvm.c     **** } field_state_t;
  66:Src/nvm.c     **** 
  67:Src/nvm.c     **** typedef struct {
  68:Src/nvm.c     ****     size_t index;               //!< next field to be written to (can be equal to n_data)
  69:Src/nvm.c     ****     const uint32_t sector_id;   //!< HAL ID of this sector
  70:Src/nvm.c     ****     const size_t n_data;        //!< number of 64-bit fields in this sector
  71:Src/nvm.c     ****     const size_t n_reserved;    //!< number of 64-bit fields in this sector that are reserved for t
  72:Src/nvm.c     ****     const volatile uint8_t* const alloc_table;
  73:Src/nvm.c     ****     const volatile uint64_t* const data;
  74:Src/nvm.c     **** } sector_t;
  75:Src/nvm.c     **** 
  76:Src/nvm.c     **** sector_t sectors[] = { {
  77:Src/nvm.c     ****     .sector_id = FLASH_PAGE_62,
  78:Src/nvm.c     ****     .n_data = FLASH_SECTOR_10_SIZE >> 3,
  79:Src/nvm.c     ****     .n_reserved = (FLASH_SECTOR_10_SIZE >> 3) >> 5,
  80:Src/nvm.c     ****     .alloc_table = FLASH_SECTOR_10_BASE,
  81:Src/nvm.c     ****     .data = (uint64_t *)FLASH_SECTOR_10_BASE
  82:Src/nvm.c     **** }, {
  83:Src/nvm.c     ****     .sector_id = FLASH_PAGE_63,
  84:Src/nvm.c     ****     .n_data = FLASH_SECTOR_11_SIZE >> 3,
  85:Src/nvm.c     ****     .n_reserved = (FLASH_SECTOR_11_SIZE >> 3) >> 5,
  86:Src/nvm.c     ****     .alloc_table = FLASH_SECTOR_11_BASE,
ARM GAS  /tmp/ccbl8B2o.s 			page 3


  87:Src/nvm.c     ****     .data = (uint64_t *)FLASH_SECTOR_11_BASE
  88:Src/nvm.c     **** }};
  89:Src/nvm.c     **** 
  90:Src/nvm.c     **** uint8_t read_sector_; // 0 or 1 to indicate which sector to read from and which to write to
  91:Src/nvm.c     **** size_t n_staging_area_; // number of 64-bit values that were reserved using NVM_start_write
  92:Src/nvm.c     **** size_t n_valid_; // number of 64-bit fields that can be read
  93:Src/nvm.c     **** 
  94:Src/nvm.c     **** // @brief Erases a flash sector. This sets all bits in the sector to 1.
  95:Src/nvm.c     **** // The sector's current index is reset to the minimum value (n_reserved).
  96:Src/nvm.c     **** // @returns 0 on success or a non-zero error code otherwise
  97:Src/nvm.c     **** // Update erase function for STM32G4
  98:Src/nvm.c     **** int erase(sector_t *sector) {
  30              		.loc 1 98 29 view -0
  31              		.cfi_startproc
  32              		@ args = 0, pretend = 0, frame = 24
  33              		@ frame_needed = 0, uses_anonymous_args = 0
  34              		.loc 1 98 29 is_stmt 0 view .LVU1
  35 0000 10B5     		push	{r4, lr}
  36              	.LCFI0:
  37              		.cfi_def_cfa_offset 8
  38              		.cfi_offset 4, -8
  39              		.cfi_offset 14, -4
  40 0002 86B0     		sub	sp, sp, #24
  41              	.LCFI1:
  42              		.cfi_def_cfa_offset 32
  43 0004 0446     		mov	r4, r0
  99:Src/nvm.c     ****     FLASH_EraseInitTypeDef erase_struct = {
  44              		.loc 1 99 5 is_stmt 1 view .LVU2
  45              		.loc 1 99 28 is_stmt 0 view .LVU3
  46 0006 0023     		movs	r3, #0
  47 0008 0293     		str	r3, [sp, #8]
  48 000a 0123     		movs	r3, #1
  49 000c 0393     		str	r3, [sp, #12]
  50 000e 4268     		ldr	r2, [r0, #4]
  51 0010 0492     		str	r2, [sp, #16]
  52 0012 0593     		str	r3, [sp, #20]
 100:Src/nvm.c     ****         .TypeErase = FLASH_TYPEERASE_PAGES,    // Changed from SECTORS to PAGES
 101:Src/nvm.c     ****         .Page = sector->sector_id,             // Using page number instead of sector
 102:Src/nvm.c     ****         .NbPages = 1,                          // Erase one page
 103:Src/nvm.c     ****         .Banks = FLASH_BANK_1                  // Always Bank 1 for G431
 104:Src/nvm.c     ****     };
 105:Src/nvm.c     ****     
 106:Src/nvm.c     ****     HAL_FLASH_Unlock();
  53              		.loc 1 106 5 is_stmt 1 view .LVU4
  54 0014 FFF7FEFF 		bl	HAL_FLASH_Unlock
  55              	.LVL1:
 107:Src/nvm.c     ****     HAL_FLASH_ClearError();
  56              		.loc 1 107 5 view .LVU5
  57              		.loc 1 107 5 view .LVU6
  58              		.loc 1 107 5 view .LVU7
  59 0018 0C4B     		ldr	r3, .L6
  60 001a 9A69     		ldr	r2, [r3, #24]
  61 001c 42F04042 		orr	r2, r2, #-1073741824
  62 0020 9A61     		str	r2, [r3, #24]
  63              		.loc 1 107 5 view .LVU8
  64              		.loc 1 107 5 view .LVU9
  65 0022 4CF2FA32 		movw	r2, #50170
ARM GAS  /tmp/ccbl8B2o.s 			page 4


  66 0026 1A61     		str	r2, [r3, #16]
  67              		.loc 1 107 5 view .LVU10
 108:Src/nvm.c     ****     uint32_t page_error;
  68              		.loc 1 108 5 view .LVU11
 109:Src/nvm.c     ****     if (HAL_FLASHEx_Erase(&erase_struct, &page_error) != HAL_OK)
  69              		.loc 1 109 5 view .LVU12
  70              		.loc 1 109 9 is_stmt 0 view .LVU13
  71 0028 01A9     		add	r1, sp, #4
  72 002a 02A8     		add	r0, sp, #8
  73 002c FFF7FEFF 		bl	HAL_FLASHEx_Erase
  74              	.LVL2:
  75              		.loc 1 109 8 view .LVU14
  76 0030 30B9     		cbnz	r0, .L5
 110:Src/nvm.c     ****         goto fail;
 111:Src/nvm.c     ****     sector->index = sector->n_reserved;
  77              		.loc 1 111 5 is_stmt 1 view .LVU15
  78              		.loc 1 111 19 is_stmt 0 view .LVU16
  79 0032 E368     		ldr	r3, [r4, #12]
  80 0034 2360     		str	r3, [r4]
 112:Src/nvm.c     **** 
 113:Src/nvm.c     ****     HAL_FLASH_Lock();
  81              		.loc 1 113 5 is_stmt 1 view .LVU17
  82 0036 FFF7FEFF 		bl	HAL_FLASH_Lock
  83              	.LVL3:
 114:Src/nvm.c     ****     return 0;
  84              		.loc 1 114 5 view .LVU18
  85              		.loc 1 114 12 is_stmt 0 view .LVU19
  86 003a 0020     		movs	r0, #0
  87              	.L1:
 115:Src/nvm.c     **** fail:
 116:Src/nvm.c     ****     HAL_FLASH_Lock();
 117:Src/nvm.c     ****     return HAL_FLASH_GetError();
 118:Src/nvm.c     **** }
  88              		.loc 1 118 1 view .LVU20
  89 003c 06B0     		add	sp, sp, #24
  90              	.LCFI2:
  91              		.cfi_remember_state
  92              		.cfi_def_cfa_offset 8
  93              		@ sp needed
  94 003e 10BD     		pop	{r4, pc}
  95              	.LVL4:
  96              	.L5:
  97              	.LCFI3:
  98              		.cfi_restore_state
 110:Src/nvm.c     ****     sector->index = sector->n_reserved;
  99              		.loc 1 110 9 is_stmt 1 view .LVU21
 100              	.LDL1:
 116:Src/nvm.c     ****     return HAL_FLASH_GetError();
 101              		.loc 1 116 5 view .LVU22
 102 0040 FFF7FEFF 		bl	HAL_FLASH_Lock
 103              	.LVL5:
 117:Src/nvm.c     **** }
 104              		.loc 1 117 5 view .LVU23
 117:Src/nvm.c     **** }
 105              		.loc 1 117 12 is_stmt 0 view .LVU24
 106 0044 FFF7FEFF 		bl	HAL_FLASH_GetError
 107              	.LVL6:
ARM GAS  /tmp/ccbl8B2o.s 			page 5


 108 0048 F8E7     		b	.L1
 109              	.L7:
 110 004a 00BF     		.align	2
 111              	.L6:
 112 004c 00200240 		.word	1073881088
 113              		.cfi_endproc
 114              	.LFE132:
 116              		.section	.text.set_allocation_state,"ax",%progbits
 117              		.align	1
 118              		.global	set_allocation_state
 119              		.syntax unified
 120              		.thumb
 121              		.thumb_func
 122              		.fpu fpv4-sp-d16
 124              	set_allocation_state:
 125              	.LVL7:
 126              	.LFB133:
 119:Src/nvm.c     **** 
 120:Src/nvm.c     **** // @brief Writes states into the allocation table.
 121:Src/nvm.c     **** // The write operation goes in the direction of increasing indices.
 122:Src/nvm.c     **** // @param state: 11: erased, 10: writing, 00: valid data
 123:Src/nvm.c     **** // @returns 0 on success or a non-zero error code otherwise
 124:Src/nvm.c     **** int set_allocation_state(sector_t *sector, size_t index, size_t count, field_state_t state) {
 127              		.loc 1 124 93 is_stmt 1 view -0
 128              		.cfi_startproc
 129              		@ args = 0, pretend = 0, frame = 0
 130              		@ frame_needed = 0, uses_anonymous_args = 0
 131              		.loc 1 124 93 is_stmt 0 view .LVU26
 132 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 133              	.LCFI4:
 134              		.cfi_def_cfa_offset 32
 135              		.cfi_offset 3, -32
 136              		.cfi_offset 4, -28
 137              		.cfi_offset 5, -24
 138              		.cfi_offset 6, -20
 139              		.cfi_offset 7, -16
 140              		.cfi_offset 8, -12
 141              		.cfi_offset 9, -8
 142              		.cfi_offset 14, -4
 143 0004 8046     		mov	r8, r0
 125:Src/nvm.c     ****     if (index < sector->n_reserved)
 144              		.loc 1 125 5 is_stmt 1 view .LVU27
 145              		.loc 1 125 8 is_stmt 0 view .LVU28
 146 0006 C068     		ldr	r0, [r0, #12]
 147              	.LVL8:
 148              		.loc 1 125 8 view .LVU29
 149 0008 8842     		cmp	r0, r1
 150 000a 67D8     		bhi	.L14
 126:Src/nvm.c     ****         return -1;
 127:Src/nvm.c     ****     if (index + count >= sector->n_data)
 151              		.loc 1 127 5 is_stmt 1 view .LVU30
 152              		.loc 1 127 15 is_stmt 0 view .LVU31
 153 000c 8818     		adds	r0, r1, r2
 154              		.loc 1 127 8 view .LVU32
 155 000e D8F80840 		ldr	r4, [r8, #8]
 156 0012 A042     		cmp	r0, r4
 157 0014 65D2     		bcs	.L15
ARM GAS  /tmp/ccbl8B2o.s 			page 6


 128:Src/nvm.c     ****         return -1;
 129:Src/nvm.c     **** 
 130:Src/nvm.c     ****     // expand state to state for 4 values
 131:Src/nvm.c     ****     const uint8_t states = (state << 0) | (state << 2) | (state << 4) | (state << 6);
 158              		.loc 1 131 5 is_stmt 1 view .LVU33
 159              		.loc 1 131 65 is_stmt 0 view .LVU34
 160 0016 1F01     		lsls	r7, r3, #4
 161              		.loc 1 131 56 view .LVU35
 162 0018 47EA8307 		orr	r7, r7, r3, lsl #2
 163 001c 1F43     		orrs	r7, r7, r3
 164              		.loc 1 131 71 view .LVU36
 165 001e 47EA8317 		orr	r7, r7, r3, lsl #6
 166              		.loc 1 131 19 view .LVU37
 167 0022 FFB2     		uxtb	r7, r7
 168              	.LVL9:
 132:Src/nvm.c     ****     
 133:Src/nvm.c     ****     // handle unaligned start
 134:Src/nvm.c     ****     uint8_t mask = ~(0xff << ((index & 0x3) << 1));
 169              		.loc 1 134 5 is_stmt 1 view .LVU38
 170              		.loc 1 134 45 is_stmt 0 view .LVU39
 171 0024 4C00     		lsls	r4, r1, #1
 172 0026 04F00603 		and	r3, r4, #6
 173              	.LVL10:
 174              		.loc 1 134 27 view .LVU40
 175 002a FF24     		movs	r4, #255
 176 002c 9C40     		lsls	r4, r4, r3
 177              		.loc 1 134 13 view .LVU41
 178 002e E443     		mvns	r4, r4
 179 0030 E4B2     		uxtb	r4, r4
 180              	.LVL11:
 135:Src/nvm.c     ****     count += index & 0x3;
 181              		.loc 1 135 5 is_stmt 1 view .LVU42
 182              		.loc 1 135 20 is_stmt 0 view .LVU43
 183 0032 01F00306 		and	r6, r1, #3
 184              		.loc 1 135 11 view .LVU44
 185 0036 1644     		add	r6, r6, r2
 186              	.LVL12:
 136:Src/nvm.c     ****     index -= index & 0x3;
 187              		.loc 1 136 5 is_stmt 1 view .LVU45
 188              		.loc 1 136 11 is_stmt 0 view .LVU46
 189 0038 21F00305 		bic	r5, r1, #3
 190              	.LVL13:
 137:Src/nvm.c     **** 
 138:Src/nvm.c     ****     HAL_FLASH_Unlock();
 191              		.loc 1 138 5 is_stmt 1 view .LVU47
 192 003c FFF7FEFF 		bl	HAL_FLASH_Unlock
 193              	.LVL14:
 139:Src/nvm.c     ****     HAL_FLASH_ClearError();
 194              		.loc 1 139 5 view .LVU48
 195              		.loc 1 139 5 view .LVU49
 196              		.loc 1 139 5 view .LVU50
 197 0040 294B     		ldr	r3, .L18
 198 0042 9A69     		ldr	r2, [r3, #24]
 199 0044 42F04042 		orr	r2, r2, #-1073741824
 200 0048 9A61     		str	r2, [r3, #24]
 201              		.loc 1 139 5 view .LVU51
 202              		.loc 1 139 5 view .LVU52
ARM GAS  /tmp/ccbl8B2o.s 			page 7


 203 004a 4CF2FA32 		movw	r2, #50170
 204 004e 1A61     		str	r2, [r3, #16]
 140:Src/nvm.c     **** 
 141:Src/nvm.c     ****     uint64_t dword_data;
 142:Src/nvm.c     ****     
 143:Src/nvm.c     ****     // write states
 144:Src/nvm.c     ****     for (; count >= 4; count -= 4, index += 4) {
 205              		.loc 1 144 12 view .LVU53
 206              		.loc 1 144 5 is_stmt 0 view .LVU54
 207 0050 032E     		cmp	r6, #3
 208 0052 1CD9     		bls	.L10
 145:Src/nvm.c     ****         dword_data = ((uint64_t)(states | mask) << 56) | 
 209              		.loc 1 145 23 view .LVU55
 210 0054 4FF00009 		mov	r9, #0
 211              	.LVL15:
 212              	.L12:
 213              		.loc 1 145 9 is_stmt 1 view .LVU56
 214              		.loc 1 145 23 is_stmt 0 view .LVU57
 215 0058 47EA0402 		orr	r2, r7, r4
 216 005c D0B2     		uxtb	r0, r2
 217              	.LVL16:
 146:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 48) |
 147:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 40) |
 148:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 32) |
 149:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 24) |
 150:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 16) |
 151:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 8) |
 152:Src/nvm.c     ****                     (uint64_t)(states | mask);
 153:Src/nvm.c     ****         
 154:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, 
 218              		.loc 1 154 9 is_stmt 1 view .LVU58
 146:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 48) |
 219              		.loc 1 146 48 is_stmt 0 view .LVU59
 220 005e 0104     		lsls	r1, r0, #16
 145:Src/nvm.c     ****         dword_data = ((uint64_t)(states | mask) << 56) | 
 221              		.loc 1 145 56 view .LVU60
 222 0060 41EA0263 		orr	r3, r1, r2, lsl #24
 145:Src/nvm.c     ****         dword_data = ((uint64_t)(states | mask) << 56) | 
 223              		.loc 1 145 20 view .LVU61
 224 0064 43EA0023 		orr	r3, r3, r0, lsl #8
 225 0068 40EA0262 		orr	r2, r0, r2, lsl #24
 226 006c 0A43     		orrs	r2, r2, r1
 155:Src/nvm.c     ****                 (uintptr_t)&sector->alloc_table[index >> 2], 
 227              		.loc 1 155 28 view .LVU62
 228 006e D8F81010 		ldr	r1, [r8, #16]
 154:Src/nvm.c     ****                 (uintptr_t)&sector->alloc_table[index >> 2], 
 229              		.loc 1 154 13 view .LVU63
 230 0072 42EA0022 		orr	r2, r2, r0, lsl #8
 231 0076 0343     		orrs	r3, r3, r0
 232 0078 01EB9501 		add	r1, r1, r5, lsr #2
 233 007c 4846     		mov	r0, r9
 234              	.LVL17:
 154:Src/nvm.c     ****                 (uintptr_t)&sector->alloc_table[index >> 2], 
 235              		.loc 1 154 13 view .LVU64
 236 007e FFF7FEFF 		bl	HAL_FLASH_Program
 237              	.LVL18:
 154:Src/nvm.c     ****                 (uintptr_t)&sector->alloc_table[index >> 2], 
ARM GAS  /tmp/ccbl8B2o.s 			page 8


 238              		.loc 1 154 12 view .LVU65
 239 0082 0446     		mov	r4, r0
 240              	.LVL19:
 154:Src/nvm.c     ****                 (uintptr_t)&sector->alloc_table[index >> 2], 
 241              		.loc 1 154 12 view .LVU66
 242 0084 20BB     		cbnz	r0, .L11
 156:Src/nvm.c     ****                 dword_data) != HAL_OK)
 157:Src/nvm.c     ****             goto fail;
 158:Src/nvm.c     ****         mask = 0;
 243              		.loc 1 158 9 is_stmt 1 view .LVU67
 244              	.LVL20:
 144:Src/nvm.c     ****         dword_data = ((uint64_t)(states | mask) << 56) | 
 245              		.loc 1 144 24 view .LVU68
 144:Src/nvm.c     ****         dword_data = ((uint64_t)(states | mask) << 56) | 
 246              		.loc 1 144 30 is_stmt 0 view .LVU69
 247 0086 043E     		subs	r6, r6, #4
 248              	.LVL21:
 144:Src/nvm.c     ****         dword_data = ((uint64_t)(states | mask) << 56) | 
 249              		.loc 1 144 42 view .LVU70
 250 0088 0435     		adds	r5, r5, #4
 251              	.LVL22:
 144:Src/nvm.c     ****         dword_data = ((uint64_t)(states | mask) << 56) | 
 252              		.loc 1 144 12 is_stmt 1 view .LVU71
 144:Src/nvm.c     ****         dword_data = ((uint64_t)(states | mask) << 56) | 
 253              		.loc 1 144 5 is_stmt 0 view .LVU72
 254 008a 032E     		cmp	r6, #3
 255 008c E4D8     		bhi	.L12
 256              	.LVL23:
 257              	.L10:
 159:Src/nvm.c     ****     }
 160:Src/nvm.c     **** 
 161:Src/nvm.c     ****     // handle unaligned end
 162:Src/nvm.c     ****     if (count) {
 258              		.loc 1 162 5 is_stmt 1 view .LVU73
 259              		.loc 1 162 8 is_stmt 0 view .LVU74
 260 008e DEB1     		cbz	r6, .L13
 163:Src/nvm.c     ****         mask |= ~(0xff >> ((4 - count) << 1));
 261              		.loc 1 163 9 is_stmt 1 view .LVU75
 262              		.loc 1 163 31 is_stmt 0 view .LVU76
 263 0090 C6F10406 		rsb	r6, r6, #4
 264              	.LVL24:
 265              		.loc 1 163 40 view .LVU77
 266 0094 7600     		lsls	r6, r6, #1
 267              		.loc 1 163 24 view .LVU78
 268 0096 FF23     		movs	r3, #255
 269 0098 3341     		asrs	r3, r3, r6
 270              		.loc 1 163 14 view .LVU79
 271 009a 64EA0303 		orn	r3, r4, r3
 272              	.LVL25:
 164:Src/nvm.c     ****         dword_data = ((uint64_t)(states | mask) << 56) |
 273              		.loc 1 164 9 is_stmt 1 view .LVU80
 274              		.loc 1 164 23 is_stmt 0 view .LVU81
 275 009e DBB2     		uxtb	r3, r3
 276              		.loc 1 164 23 view .LVU82
 277 00a0 1F43     		orrs	r7, r7, r3
 278              	.LVL26:
 165:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 48) |
ARM GAS  /tmp/ccbl8B2o.s 			page 9


 166:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 40) |
 167:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 32) |
 168:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 24) |
 169:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 16) |
 170:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 8) |
 171:Src/nvm.c     ****                     (uint64_t)(states | mask);
 172:Src/nvm.c     ****                     
 173:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, 
 279              		.loc 1 173 9 is_stmt 1 view .LVU83
 165:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 48) |
 280              		.loc 1 165 48 is_stmt 0 view .LVU84
 281 00a2 3904     		lsls	r1, r7, #16
 164:Src/nvm.c     ****         dword_data = ((uint64_t)(states | mask) << 56) |
 282              		.loc 1 164 56 view .LVU85
 283 00a4 41EA0763 		orr	r3, r1, r7, lsl #24
 284              	.LVL27:
 164:Src/nvm.c     ****         dword_data = ((uint64_t)(states | mask) << 56) |
 285              		.loc 1 164 20 view .LVU86
 286 00a8 43EA0723 		orr	r3, r3, r7, lsl #8
 287 00ac 47EA0762 		orr	r2, r7, r7, lsl #24
 288 00b0 0A43     		orrs	r2, r2, r1
 174:Src/nvm.c     ****                 (uintptr_t)&sector->alloc_table[index >> 2], 
 289              		.loc 1 174 28 view .LVU87
 290 00b2 D8F81010 		ldr	r1, [r8, #16]
 173:Src/nvm.c     ****                 (uintptr_t)&sector->alloc_table[index >> 2], 
 291              		.loc 1 173 13 view .LVU88
 292 00b6 42EA0722 		orr	r2, r2, r7, lsl #8
 293 00ba 3B43     		orrs	r3, r3, r7
 294 00bc 01EB9501 		add	r1, r1, r5, lsr #2
 295 00c0 0020     		movs	r0, #0
 296 00c2 FFF7FEFF 		bl	HAL_FLASH_Program
 297              	.LVL28:
 173:Src/nvm.c     ****                 (uintptr_t)&sector->alloc_table[index >> 2], 
 298              		.loc 1 173 12 view .LVU89
 299 00c6 18B9     		cbnz	r0, .L11
 300              	.LVL29:
 301              	.L13:
 175:Src/nvm.c     ****                 dword_data) != HAL_OK)
 176:Src/nvm.c     ****             goto fail;
 177:Src/nvm.c     ****     }
 178:Src/nvm.c     ****     
 179:Src/nvm.c     ****     HAL_FLASH_Lock();
 302              		.loc 1 179 5 is_stmt 1 view .LVU90
 303 00c8 FFF7FEFF 		bl	HAL_FLASH_Lock
 304              	.LVL30:
 180:Src/nvm.c     ****     return 0;
 305              		.loc 1 180 5 view .LVU91
 306              		.loc 1 180 12 is_stmt 0 view .LVU92
 307 00cc 0020     		movs	r0, #0
 308 00ce 03E0     		b	.L8
 309              	.L11:
 181:Src/nvm.c     **** fail:
 182:Src/nvm.c     ****     HAL_FLASH_Lock();
 310              		.loc 1 182 5 is_stmt 1 view .LVU93
 311 00d0 FFF7FEFF 		bl	HAL_FLASH_Lock
 312              	.LVL31:
 183:Src/nvm.c     ****     return HAL_FLASH_GetError(); // non-zero
ARM GAS  /tmp/ccbl8B2o.s 			page 10


 313              		.loc 1 183 5 view .LVU94
 314              		.loc 1 183 12 is_stmt 0 view .LVU95
 315 00d4 FFF7FEFF 		bl	HAL_FLASH_GetError
 316              	.LVL32:
 317              	.L8:
 184:Src/nvm.c     **** }
 318              		.loc 1 184 1 view .LVU96
 319 00d8 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 320              	.LVL33:
 321              	.L14:
 126:Src/nvm.c     ****     if (index + count >= sector->n_data)
 322              		.loc 1 126 16 view .LVU97
 323 00dc 4FF0FF30 		mov	r0, #-1
 324 00e0 FAE7     		b	.L8
 325              	.L15:
 128:Src/nvm.c     **** 
 326              		.loc 1 128 16 view .LVU98
 327 00e2 4FF0FF30 		mov	r0, #-1
 328 00e6 F7E7     		b	.L8
 329              	.L19:
 330              		.align	2
 331              	.L18:
 332 00e8 00200240 		.word	1073881088
 333              		.cfi_endproc
 334              	.LFE133:
 336              		.section	.text.scan_allocation_table,"ax",%progbits
 337              		.align	1
 338              		.global	scan_allocation_table
 339              		.syntax unified
 340              		.thumb
 341              		.thumb_func
 342              		.fpu fpv4-sp-d16
 344              	scan_allocation_table:
 345              	.LVL34:
 346              	.LFB134:
 185:Src/nvm.c     **** 
 186:Src/nvm.c     **** // @brief Reads the allocation table from behind to determine how many fields match the
 187:Src/nvm.c     **** // reference state.
 188:Src/nvm.c     **** // @param sector: The sector on which to perform the search
 189:Src/nvm.c     **** // @param max_index: The maximum index that should be considered
 190:Src/nvm.c     **** // @param ref_state: The reference state
 191:Src/nvm.c     **** // @param state: Set to the first encountered state that is unequal to ref_state.
 192:Src/nvm.c     **** //               Set to ref_state if all encountered states are equal to ref_state.
 193:Src/nvm.c     **** // @returns The smallest index that points to a field with ref_state.
 194:Src/nvm.c     **** //          This value is at least sector->n_reserved and at most max_index.
 195:Src/nvm.c     **** size_t scan_allocation_table(sector_t *sector, size_t max_index, field_state_t ref_state, field_sta
 347              		.loc 1 195 113 is_stmt 1 view -0
 348              		.cfi_startproc
 349              		@ args = 0, pretend = 0, frame = 0
 350              		@ frame_needed = 0, uses_anonymous_args = 0
 351              		.loc 1 195 113 is_stmt 0 view .LVU100
 352 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 353              	.LCFI5:
 354              		.cfi_def_cfa_offset 20
 355              		.cfi_offset 4, -20
 356              		.cfi_offset 5, -16
 357              		.cfi_offset 6, -12
ARM GAS  /tmp/ccbl8B2o.s 			page 11


 358              		.cfi_offset 7, -8
 359              		.cfi_offset 14, -4
 360 0002 0546     		mov	r5, r0
 196:Src/nvm.c     ****     const uint8_t ref_states = (ref_state << 0) | (ref_state << 2) | (ref_state << 4) | (ref_state 
 361              		.loc 1 196 5 is_stmt 1 view .LVU101
 362              		.loc 1 196 81 is_stmt 0 view .LVU102
 363 0004 1401     		lsls	r4, r2, #4
 364              		.loc 1 196 68 view .LVU103
 365 0006 44EA8204 		orr	r4, r4, r2, lsl #2
 366 000a 1443     		orrs	r4, r4, r2
 367              		.loc 1 196 87 view .LVU104
 368 000c 44EA8212 		orr	r2, r4, r2, lsl #6
 369              	.LVL35:
 370              		.loc 1 196 19 view .LVU105
 371 0010 D2B2     		uxtb	r2, r2
 372              	.LVL36:
 197:Src/nvm.c     ****     size_t index = (((max_index + 3) >> 2) << 2); // start at the max index but round up to a multi
 373              		.loc 1 197 5 is_stmt 1 view .LVU106
 374              		.loc 1 197 33 is_stmt 0 view .LVU107
 375 0012 C81C     		adds	r0, r1, #3
 376              	.LVL37:
 377              		.loc 1 197 12 view .LVU108
 378 0014 20F00300 		bic	r0, r0, #3
 379              	.LVL38:
 198:Src/nvm.c     ****     size_t ignore = index - max_index;
 380              		.loc 1 198 5 is_stmt 1 view .LVU109
 381              		.loc 1 198 12 is_stmt 0 view .LVU110
 382 0018 411A     		subs	r1, r0, r1
 383              	.LVL39:
 199:Src/nvm.c     ****     uint8_t states = ref_states;
 384              		.loc 1 199 5 is_stmt 1 view .LVU111
 200:Src/nvm.c     **** 
 201:Src/nvm.c     ****     //printf("scan from %08x to %08x for %02x\r\n", index, sector->n_reserved, ref_states); osDelay
 202:Src/nvm.c     **** 
 203:Src/nvm.c     ****     // read 4 states at a time
 204:Src/nvm.c     ****     for (; index >= (sector->n_reserved + 4); index -= 4) {
 385              		.loc 1 204 5 view .LVU112
 386              		.loc 1 204 12 view .LVU113
 387              		.loc 1 204 28 is_stmt 0 view .LVU114
 388 001a EC68     		ldr	r4, [r5, #12]
 389              		.loc 1 204 41 view .LVU115
 390 001c 04F1040C 		add	ip, r4, #4
 391              		.loc 1 204 5 view .LVU116
 392 0020 6045     		cmp	r0, ip
 393 0022 1AD3     		bcc	.L27
 205:Src/nvm.c     ****         states = sector->alloc_table[(index - 1) >> 2];
 394              		.loc 1 205 24 view .LVU117
 395 0024 2D69     		ldr	r5, [r5, #16]
 396              	.LVL40:
 397              	.LBB2:
 206:Src/nvm.c     ****         if (ignore) { // ignore the upper 1, 2 or 3 states if max_index was unaligned
 207:Src/nvm.c     ****             uint8_t ignore_mask = ~(0xff >> (ignore << 1));
 398              		.loc 1 207 42 view .LVU118
 399 0026 FF26     		movs	r6, #255
 400 0028 4FF0000E 		mov	lr, #0
 401 002c 05E0     		b	.L26
 402              	.LVL41:
ARM GAS  /tmp/ccbl8B2o.s 			page 12


 403              	.L22:
 404              		.loc 1 207 42 view .LVU119
 405              	.LBE2:
 208:Src/nvm.c     ****             states = (states & ~ignore_mask) | (ref_states & ignore_mask);
 209:Src/nvm.c     ****             ignore = 0;
 210:Src/nvm.c     ****         }
 211:Src/nvm.c     ****         if (states != ref_states)
 406              		.loc 1 211 9 is_stmt 1 view .LVU120
 407              		.loc 1 211 12 is_stmt 0 view .LVU121
 408 002e 9742     		cmp	r7, r2
 409 0030 14D1     		bne	.L21
 204:Src/nvm.c     ****         states = sector->alloc_table[(index - 1) >> 2];
 410              		.loc 1 204 47 is_stmt 1 view .LVU122
 204:Src/nvm.c     ****         states = sector->alloc_table[(index - 1) >> 2];
 411              		.loc 1 204 53 is_stmt 0 view .LVU123
 412 0032 0438     		subs	r0, r0, #4
 413              	.LVL42:
 204:Src/nvm.c     ****         states = sector->alloc_table[(index - 1) >> 2];
 414              		.loc 1 204 12 is_stmt 1 view .LVU124
 415 0034 7146     		mov	r1, lr
 204:Src/nvm.c     ****         states = sector->alloc_table[(index - 1) >> 2];
 416              		.loc 1 204 5 is_stmt 0 view .LVU125
 417 0036 6045     		cmp	r0, ip
 418 0038 10D3     		bcc	.L21
 419              	.LVL43:
 420              	.L26:
 205:Src/nvm.c     ****         if (ignore) { // ignore the upper 1, 2 or 3 states if max_index was unaligned
 421              		.loc 1 205 9 is_stmt 1 view .LVU126
 205:Src/nvm.c     ****         if (ignore) { // ignore the upper 1, 2 or 3 states if max_index was unaligned
 422              		.loc 1 205 50 is_stmt 0 view .LVU127
 423 003a 471E     		subs	r7, r0, #1
 424 003c BF08     		lsrs	r7, r7, #2
 205:Src/nvm.c     ****         if (ignore) { // ignore the upper 1, 2 or 3 states if max_index was unaligned
 425              		.loc 1 205 16 view .LVU128
 426 003e EF5D     		ldrb	r7, [r5, r7]	@ zero_extendqisi2
 427 0040 FFB2     		uxtb	r7, r7
 428              	.LVL44:
 206:Src/nvm.c     ****             uint8_t ignore_mask = ~(0xff >> (ignore << 1));
 429              		.loc 1 206 9 is_stmt 1 view .LVU129
 206:Src/nvm.c     ****             uint8_t ignore_mask = ~(0xff >> (ignore << 1));
 430              		.loc 1 206 12 is_stmt 0 view .LVU130
 431 0042 0029     		cmp	r1, #0
 432 0044 F3D0     		beq	.L22
 433              	.LBB3:
 207:Src/nvm.c     ****             states = (states & ~ignore_mask) | (ref_states & ignore_mask);
 434              		.loc 1 207 13 is_stmt 1 view .LVU131
 207:Src/nvm.c     ****             states = (states & ~ignore_mask) | (ref_states & ignore_mask);
 435              		.loc 1 207 53 is_stmt 0 view .LVU132
 436 0046 4900     		lsls	r1, r1, #1
 437              	.LVL45:
 207:Src/nvm.c     ****             states = (states & ~ignore_mask) | (ref_states & ignore_mask);
 438              		.loc 1 207 42 view .LVU133
 439 0048 46FA01F1 		asr	r1, r6, r1
 207:Src/nvm.c     ****             states = (states & ~ignore_mask) | (ref_states & ignore_mask);
 440              		.loc 1 207 21 view .LVU134
 441 004c C943     		mvns	r1, r1
 442 004e C9B2     		uxtb	r1, r1
ARM GAS  /tmp/ccbl8B2o.s 			page 13


 443              	.LVL46:
 208:Src/nvm.c     ****             ignore = 0;
 444              		.loc 1 208 13 is_stmt 1 view .LVU135
 208:Src/nvm.c     ****             ignore = 0;
 445              		.loc 1 208 30 is_stmt 0 view .LVU136
 446 0050 27EA0107 		bic	r7, r7, r1
 447              	.LVL47:
 208:Src/nvm.c     ****             ignore = 0;
 448              		.loc 1 208 46 view .LVU137
 449 0054 1140     		ands	r1, r1, r2
 450              	.LVL48:
 208:Src/nvm.c     ****             ignore = 0;
 451              		.loc 1 208 20 view .LVU138
 452 0056 0F43     		orrs	r7, r7, r1
 453              	.LVL49:
 209:Src/nvm.c     ****         }
 454              		.loc 1 209 13 is_stmt 1 view .LVU139
 209:Src/nvm.c     ****         }
 455              		.loc 1 209 13 is_stmt 0 view .LVU140
 456 0058 E9E7     		b	.L22
 457              	.LVL50:
 458              	.L27:
 209:Src/nvm.c     ****         }
 459              		.loc 1 209 13 view .LVU141
 460              	.LBE3:
 199:Src/nvm.c     **** 
 461              		.loc 1 199 13 view .LVU142
 462 005a 1746     		mov	r7, r2
 463              	.LVL51:
 464              	.L21:
 212:Src/nvm.c     ****             break;
 213:Src/nvm.c     ****     }
 214:Src/nvm.c     **** 
 215:Src/nvm.c     ****     // once we encounterd a byte with any state mismatch determine which of the 4 states it is
 216:Src/nvm.c     ****     for (; ((states >> 6) == (ref_states & 0x3)) && (index > sector->n_reserved); index--) {
 465              		.loc 1 216 12 is_stmt 1 discriminator 1 view .LVU143
 466              		.loc 1 216 21 is_stmt 0 discriminator 1 view .LVU144
 467 005c B909     		lsrs	r1, r7, #6
 468 005e 02F00302 		and	r2, r2, #3
 469              	.LVL52:
 470              		.loc 1 216 5 discriminator 1 view .LVU145
 471 0062 B2EB971F 		cmp	r2, r7, lsr #6
 472 0066 0BD1     		bne	.L24
 473              		.loc 1 216 50 view .LVU146
 474 0068 A042     		cmp	r0, r4
 475 006a 09D9     		bls	.L24
 476              	.L25:
 217:Src/nvm.c     ****         states <<= 2;
 477              		.loc 1 217 9 is_stmt 1 discriminator 3 view .LVU147
 478              		.loc 1 217 16 is_stmt 0 discriminator 3 view .LVU148
 479 006c B900     		lsls	r1, r7, #2
 480 006e CFB2     		uxtb	r7, r1
 481              	.LVL53:
 216:Src/nvm.c     ****         states <<= 2;
 482              		.loc 1 216 83 is_stmt 1 discriminator 3 view .LVU149
 216:Src/nvm.c     ****         states <<= 2;
 483              		.loc 1 216 88 is_stmt 0 discriminator 3 view .LVU150
ARM GAS  /tmp/ccbl8B2o.s 			page 14


 484 0070 0138     		subs	r0, r0, #1
 485              	.LVL54:
 216:Src/nvm.c     ****         states <<= 2;
 486              		.loc 1 216 12 is_stmt 1 discriminator 3 view .LVU151
 216:Src/nvm.c     ****         states <<= 2;
 487              		.loc 1 216 21 is_stmt 0 discriminator 3 view .LVU152
 488 0072 C1F38111 		ubfx	r1, r1, #6, #2
 216:Src/nvm.c     ****         states <<= 2;
 489              		.loc 1 216 5 discriminator 3 view .LVU153
 490 0076 9142     		cmp	r1, r2
 491 0078 02D1     		bne	.L24
 216:Src/nvm.c     ****         states <<= 2;
 492              		.loc 1 216 50 discriminator 2 view .LVU154
 493 007a A042     		cmp	r0, r4
 494 007c F6D1     		bne	.L25
 216:Src/nvm.c     ****         states <<= 2;
 495              		.loc 1 216 88 view .LVU155
 496 007e 2046     		mov	r0, r4
 497              	.LVL55:
 498              	.L24:
 218:Src/nvm.c     ****     }
 219:Src/nvm.c     ****     
 220:Src/nvm.c     ****     *state = states >> 6;
 499              		.loc 1 220 5 is_stmt 1 view .LVU156
 500              		.loc 1 220 12 is_stmt 0 view .LVU157
 501 0080 1970     		strb	r1, [r3]
 221:Src/nvm.c     ****     //printf("(it's %02x)\r\n", index); osDelay(5);
 222:Src/nvm.c     ****     return index;
 502              		.loc 1 222 5 is_stmt 1 view .LVU158
 223:Src/nvm.c     **** }
 503              		.loc 1 223 1 is_stmt 0 view .LVU159
 504 0082 F0BD     		pop	{r4, r5, r6, r7, pc}
 505              		.loc 1 223 1 view .LVU160
 506              		.cfi_endproc
 507              	.LFE134:
 509              		.section	.text.NVM_init,"ax",%progbits
 510              		.align	1
 511              		.global	NVM_init
 512              		.syntax unified
 513              		.thumb
 514              		.thumb_func
 515              		.fpu fpv4-sp-d16
 517              	NVM_init:
 518              	.LFB135:
 224:Src/nvm.c     **** 
 225:Src/nvm.c     **** // Loads the head of the NVM data.
 226:Src/nvm.c     **** // If this function fails subsequent calls to NVM functions (other than NVM_init or NVM_erase)
 227:Src/nvm.c     **** // cause undefined behavior.
 228:Src/nvm.c     **** // @returns 0 on success or a non-zero error code otherwise
 229:Src/nvm.c     **** int NVM_init(void) {
 519              		.loc 1 229 20 is_stmt 1 view -0
 520              		.cfi_startproc
 521              		@ args = 0, pretend = 0, frame = 8
 522              		@ frame_needed = 0, uses_anonymous_args = 0
 523 0000 70B5     		push	{r4, r5, r6, lr}
 524              	.LCFI6:
 525              		.cfi_def_cfa_offset 16
ARM GAS  /tmp/ccbl8B2o.s 			page 15


 526              		.cfi_offset 4, -16
 527              		.cfi_offset 5, -12
 528              		.cfi_offset 6, -8
 529              		.cfi_offset 14, -4
 530 0002 82B0     		sub	sp, sp, #8
 531              	.LCFI7:
 532              		.cfi_def_cfa_offset 24
 230:Src/nvm.c     ****     field_state_t sector0_state, sector1_state;
 533              		.loc 1 230 5 view .LVU162
 231:Src/nvm.c     ****     sectors[0].index = scan_allocation_table(&sectors[0], sectors[0].n_data,
 534              		.loc 1 231 5 view .LVU163
 535              		.loc 1 231 24 is_stmt 0 view .LVU164
 536 0004 1A4C     		ldr	r4, .L35
 537 0006 0DF10703 		add	r3, sp, #7
 538 000a 0322     		movs	r2, #3
 539 000c A168     		ldr	r1, [r4, #8]
 540 000e 2046     		mov	r0, r4
 541 0010 FFF7FEFF 		bl	scan_allocation_table
 542              	.LVL56:
 543              		.loc 1 231 22 view .LVU165
 544 0014 2060     		str	r0, [r4]
 232:Src/nvm.c     ****                 ERASED, &sector0_state);
 233:Src/nvm.c     ****     sectors[1].index = scan_allocation_table(&sectors[1], sectors[1].n_data,
 545              		.loc 1 233 5 is_stmt 1 view .LVU166
 546              		.loc 1 233 24 is_stmt 0 view .LVU167
 547 0016 0DF10603 		add	r3, sp, #6
 548 001a 0322     		movs	r2, #3
 549 001c 216A     		ldr	r1, [r4, #32]
 550 001e 04F11800 		add	r0, r4, #24
 551 0022 FFF7FEFF 		bl	scan_allocation_table
 552              	.LVL57:
 553              		.loc 1 233 22 view .LVU168
 554 0026 A061     		str	r0, [r4, #24]
 234:Src/nvm.c     ****                 ERASED, &sector1_state);
 235:Src/nvm.c     ****     //printf("sector states: %02x, %02x\r\n", sector0_state, sector1_state); osDelay(5);
 236:Src/nvm.c     **** 
 237:Src/nvm.c     ****     // Select valid sector on a best effort basis
 238:Src/nvm.c     ****     // (in unfortunate cases valid_sector might actually point
 239:Src/nvm.c     ****     // to an invalid or erased sector)
 240:Src/nvm.c     ****     read_sector_ = 0;
 555              		.loc 1 240 5 is_stmt 1 view .LVU169
 556              		.loc 1 240 18 is_stmt 0 view .LVU170
 557 0028 124B     		ldr	r3, .L35+4
 558 002a 0022     		movs	r2, #0
 559 002c 1A70     		strb	r2, [r3]
 241:Src/nvm.c     ****     if (sector1_state == VALID)
 560              		.loc 1 241 5 is_stmt 1 view .LVU171
 561              		.loc 1 241 8 is_stmt 0 view .LVU172
 562 002e 9DF80630 		ldrb	r3, [sp, #6]	@ zero_extendqisi2
 563 0032 13B9     		cbnz	r3, .L33
 242:Src/nvm.c     ****         read_sector_ = 1;
 564              		.loc 1 242 9 is_stmt 1 view .LVU173
 565              		.loc 1 242 22 is_stmt 0 view .LVU174
 566 0034 0F4B     		ldr	r3, .L35+4
 567 0036 0122     		movs	r2, #1
 568 0038 1A70     		strb	r2, [r3]
 569              	.L33:
ARM GAS  /tmp/ccbl8B2o.s 			page 16


 243:Src/nvm.c     ****     
 244:Src/nvm.c     ****     // count the number of valid fields
 245:Src/nvm.c     ****     sector_t *read_sector = &sectors[read_sector_];
 570              		.loc 1 245 5 is_stmt 1 view .LVU175
 571              		.loc 1 245 37 is_stmt 0 view .LVU176
 572 003a 0E4B     		ldr	r3, .L35+4
 573 003c 1C78     		ldrb	r4, [r3]	@ zero_extendqisi2
 574              	.LVL58:
 246:Src/nvm.c     ****     uint8_t first_nonvalid_state;
 575              		.loc 1 246 5 is_stmt 1 view .LVU177
 247:Src/nvm.c     ****     size_t min_valid_index = scan_allocation_table(read_sector, read_sector->index,
 576              		.loc 1 247 5 view .LVU178
 577              		.loc 1 247 30 is_stmt 0 view .LVU179
 578 003e 0C4D     		ldr	r5, .L35
 579 0040 6600     		lsls	r6, r4, #1
 580 0042 04EB4401 		add	r1, r4, r4, lsl #1
 245:Src/nvm.c     ****     uint8_t first_nonvalid_state;
 581              		.loc 1 245 15 view .LVU180
 582 0046 0846     		mov	r0, r1
 583              		.loc 1 247 30 view .LVU181
 584 0048 0DF10503 		add	r3, sp, #5
 585 004c 0022     		movs	r2, #0
 586 004e 55F83110 		ldr	r1, [r5, r1, lsl #3]
 587 0052 05EBC000 		add	r0, r5, r0, lsl #3
 588 0056 FFF7FEFF 		bl	scan_allocation_table
 589              	.LVL59:
 248:Src/nvm.c     ****         VALID, &first_nonvalid_state);
 249:Src/nvm.c     ****     n_valid_ = read_sector->index - min_valid_index;
 590              		.loc 1 249 5 is_stmt 1 view .LVU182
 591              		.loc 1 249 27 is_stmt 0 view .LVU183
 592 005a 3444     		add	r4, r4, r6
 593              	.LVL60:
 594              		.loc 1 249 35 view .LVU184
 595 005c 55F83430 		ldr	r3, [r5, r4, lsl #3]
 596 0060 1B1A     		subs	r3, r3, r0
 597              		.loc 1 249 14 view .LVU185
 598 0062 054A     		ldr	r2, .L35+8
 599 0064 1360     		str	r3, [r2]
 250:Src/nvm.c     ****     
 251:Src/nvm.c     ****     n_staging_area_ = 0;
 600              		.loc 1 251 5 is_stmt 1 view .LVU186
 601              		.loc 1 251 21 is_stmt 0 view .LVU187
 602 0066 0020     		movs	r0, #0
 603              	.LVL61:
 604              		.loc 1 251 21 view .LVU188
 605 0068 044B     		ldr	r3, .L35+12
 606 006a 1860     		str	r0, [r3]
 252:Src/nvm.c     **** 
 253:Src/nvm.c     ****     int status = 0;
 607              		.loc 1 253 5 is_stmt 1 view .LVU189
 608              	.LVL62:
 254:Src/nvm.c     ****     /*// bring non-valid sectors into a known state
 255:Src/nvm.c     ****     this is not absolutely required
 256:Src/nvm.c     ****     if (sector0_state != VALID)
 257:Src/nvm.c     ****         status |= erase(&sectors[0]);
 258:Src/nvm.c     ****     if (sector1_state != VALID)
 259:Src/nvm.c     ****         status |= erase(&sectors[1]);
ARM GAS  /tmp/ccbl8B2o.s 			page 17


 260:Src/nvm.c     ****     */
 261:Src/nvm.c     ****     return status;
 609              		.loc 1 261 5 view .LVU190
 262:Src/nvm.c     **** }
 610              		.loc 1 262 1 is_stmt 0 view .LVU191
 611 006c 02B0     		add	sp, sp, #8
 612              	.LCFI8:
 613              		.cfi_def_cfa_offset 16
 614              		@ sp needed
 615 006e 70BD     		pop	{r4, r5, r6, pc}
 616              	.L36:
 617              		.align	2
 618              	.L35:
 619 0070 00000000 		.word	.LANCHOR0
 620 0074 00000000 		.word	.LANCHOR1
 621 0078 00000000 		.word	.LANCHOR2
 622 007c 00000000 		.word	.LANCHOR3
 623              		.cfi_endproc
 624              	.LFE135:
 626              		.section	.text.NVM_erase,"ax",%progbits
 627              		.align	1
 628              		.global	NVM_erase
 629              		.syntax unified
 630              		.thumb
 631              		.thumb_func
 632              		.fpu fpv4-sp-d16
 634              	NVM_erase:
 635              	.LFB136:
 263:Src/nvm.c     **** 
 264:Src/nvm.c     **** // @brief Erases all data in the NVM.
 265:Src/nvm.c     **** //
 266:Src/nvm.c     **** // If this function fails subsequent calls to NVM functions (other than NVM_init or NVM_erase)
 267:Src/nvm.c     **** // cause undefined behavior.
 268:Src/nvm.c     **** // Caution: this function may take a long time (like 1 second)
 269:Src/nvm.c     **** //
 270:Src/nvm.c     **** // @returns 0 on success or a non-zero error code otherwise
 271:Src/nvm.c     **** int NVM_erase(void) {
 636              		.loc 1 271 21 is_stmt 1 view -0
 637              		.cfi_startproc
 638              		@ args = 0, pretend = 0, frame = 0
 639              		@ frame_needed = 0, uses_anonymous_args = 0
 640 0000 38B5     		push	{r3, r4, r5, lr}
 641              	.LCFI9:
 642              		.cfi_def_cfa_offset 16
 643              		.cfi_offset 3, -16
 644              		.cfi_offset 4, -12
 645              		.cfi_offset 5, -8
 646              		.cfi_offset 14, -4
 272:Src/nvm.c     ****     read_sector_ = 0;
 647              		.loc 1 272 5 view .LVU193
 648              		.loc 1 272 18 is_stmt 0 view .LVU194
 649 0002 094B     		ldr	r3, .L39
 650 0004 0022     		movs	r2, #0
 651 0006 1A70     		strb	r2, [r3]
 273:Src/nvm.c     ****     sectors[0].index = sectors[0].n_reserved;
 652              		.loc 1 273 5 is_stmt 1 view .LVU195
 653              		.loc 1 273 22 is_stmt 0 view .LVU196
ARM GAS  /tmp/ccbl8B2o.s 			page 18


 654 0008 084C     		ldr	r4, .L39+4
 655 000a E368     		ldr	r3, [r4, #12]
 656 000c 2360     		str	r3, [r4]
 274:Src/nvm.c     ****     sectors[1].index = sectors[1].n_reserved;
 657              		.loc 1 274 5 is_stmt 1 view .LVU197
 658              		.loc 1 274 22 is_stmt 0 view .LVU198
 659 000e 636A     		ldr	r3, [r4, #36]
 660 0010 A361     		str	r3, [r4, #24]
 275:Src/nvm.c     **** 
 276:Src/nvm.c     ****     int state = 0;
 661              		.loc 1 276 5 is_stmt 1 view .LVU199
 662              	.LVL63:
 277:Src/nvm.c     ****     state |= erase(&sectors[0]);
 663              		.loc 1 277 5 view .LVU200
 664              		.loc 1 277 14 is_stmt 0 view .LVU201
 665 0012 2046     		mov	r0, r4
 666 0014 FFF7FEFF 		bl	erase
 667              	.LVL64:
 668 0018 0546     		mov	r5, r0
 669              	.LVL65:
 278:Src/nvm.c     ****     state |= erase(&sectors[1]);
 670              		.loc 1 278 5 is_stmt 1 view .LVU202
 671              		.loc 1 278 14 is_stmt 0 view .LVU203
 672 001a 04F11800 		add	r0, r4, #24
 673              	.LVL66:
 674              		.loc 1 278 14 view .LVU204
 675 001e FFF7FEFF 		bl	erase
 676              	.LVL67:
 279:Src/nvm.c     ****     return state;
 677              		.loc 1 279 5 is_stmt 1 view .LVU205
 280:Src/nvm.c     **** }
 678              		.loc 1 280 1 is_stmt 0 view .LVU206
 679 0022 2843     		orrs	r0, r0, r5
 680              	.LVL68:
 681              		.loc 1 280 1 view .LVU207
 682 0024 38BD     		pop	{r3, r4, r5, pc}
 683              	.L40:
 684 0026 00BF     		.align	2
 685              	.L39:
 686 0028 00000000 		.word	.LANCHOR1
 687 002c 00000000 		.word	.LANCHOR0
 688              		.cfi_endproc
 689              	.LFE136:
 691              		.section	.text.NVM_get_max_read_length,"ax",%progbits
 692              		.align	1
 693              		.global	NVM_get_max_read_length
 694              		.syntax unified
 695              		.thumb
 696              		.thumb_func
 697              		.fpu fpv4-sp-d16
 699              	NVM_get_max_read_length:
 700              	.LFB137:
 281:Src/nvm.c     **** 
 282:Src/nvm.c     **** // @brief Returns the maximum number of bytes that can be read using NVM_read.
 283:Src/nvm.c     **** // This holds until NVM_commit is called.
 284:Src/nvm.c     **** size_t NVM_get_max_read_length(void) {
 701              		.loc 1 284 38 is_stmt 1 view -0
ARM GAS  /tmp/ccbl8B2o.s 			page 19


 702              		.cfi_startproc
 703              		@ args = 0, pretend = 0, frame = 0
 704              		@ frame_needed = 0, uses_anonymous_args = 0
 705              		@ link register save eliminated.
 285:Src/nvm.c     ****     return n_valid_ << 3;
 706              		.loc 1 285 5 view .LVU209
 707              		.loc 1 285 21 is_stmt 0 view .LVU210
 708 0000 014B     		ldr	r3, .L42
 709 0002 1868     		ldr	r0, [r3]
 286:Src/nvm.c     **** }
 710              		.loc 1 286 1 view .LVU211
 711 0004 C000     		lsls	r0, r0, #3
 712 0006 7047     		bx	lr
 713              	.L43:
 714              		.align	2
 715              	.L42:
 716 0008 00000000 		.word	.LANCHOR2
 717              		.cfi_endproc
 718              	.LFE137:
 720              		.section	.text.NVM_get_max_write_length,"ax",%progbits
 721              		.align	1
 722              		.global	NVM_get_max_write_length
 723              		.syntax unified
 724              		.thumb
 725              		.thumb_func
 726              		.fpu fpv4-sp-d16
 728              	NVM_get_max_write_length:
 729              	.LFB138:
 287:Src/nvm.c     **** 
 288:Src/nvm.c     **** // @brief Returns the maximum length (in bytes) that can passed to NVM_start_write.
 289:Src/nvm.c     **** // This holds until NVM_commit is called.
 290:Src/nvm.c     **** size_t NVM_get_max_write_length(void) {
 730              		.loc 1 290 39 is_stmt 1 view -0
 731              		.cfi_startproc
 732              		@ args = 0, pretend = 0, frame = 0
 733              		@ frame_needed = 0, uses_anonymous_args = 0
 734              		@ link register save eliminated.
 291:Src/nvm.c     ****     sector_t *target = &sectors[1 - read_sector_];
 735              		.loc 1 291 5 view .LVU213
 736              		.loc 1 291 35 is_stmt 0 view .LVU214
 737 0000 064B     		ldr	r3, .L45
 738 0002 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 739 0004 C3F10103 		rsb	r3, r3, #1
 740              	.LVL69:
 292:Src/nvm.c     ****     return (target->n_data - target->n_reserved) << 3;
 741              		.loc 1 292 5 is_stmt 1 view .LVU215
 742              		.loc 1 292 19 is_stmt 0 view .LVU216
 743 0008 054A     		ldr	r2, .L45+4
 744 000a 03EB4301 		add	r1, r3, r3, lsl #1
 745 000e 02EBC101 		add	r1, r2, r1, lsl #3
 746              		.loc 1 292 28 view .LVU217
 747 0012 8868     		ldr	r0, [r1, #8]
 748 0014 CB68     		ldr	r3, [r1, #12]
 749              	.LVL70:
 750              		.loc 1 292 28 view .LVU218
 751 0016 C01A     		subs	r0, r0, r3
 293:Src/nvm.c     **** }
ARM GAS  /tmp/ccbl8B2o.s 			page 20


 752              		.loc 1 293 1 view .LVU219
 753 0018 C000     		lsls	r0, r0, #3
 754 001a 7047     		bx	lr
 755              	.L46:
 756              		.align	2
 757              	.L45:
 758 001c 00000000 		.word	.LANCHOR1
 759 0020 00000000 		.word	.LANCHOR0
 760              		.cfi_endproc
 761              	.LFE138:
 763              		.section	.text.NVM_read,"ax",%progbits
 764              		.align	1
 765              		.global	NVM_read
 766              		.syntax unified
 767              		.thumb
 768              		.thumb_func
 769              		.fpu fpv4-sp-d16
 771              	NVM_read:
 772              	.LVL71:
 773              	.LFB139:
 294:Src/nvm.c     **** 
 295:Src/nvm.c     **** // @brief Reads from the latest committed block in the non-volatile memory.
 296:Src/nvm.c     **** // @param offset: offset in bytes (0 meaning the beginning of the valid area)
 297:Src/nvm.c     **** // @param data: buffer to write to
 298:Src/nvm.c     **** // @param length: length in bytes (if (offset + length) is out of range, the function fails)
 299:Src/nvm.c     **** // @returns 0 on success or a non-zero error code otherwise
 300:Src/nvm.c     **** int NVM_read(size_t offset, uint8_t *data, size_t length) {
 774              		.loc 1 300 59 is_stmt 1 view -0
 775              		.cfi_startproc
 776              		@ args = 0, pretend = 0, frame = 0
 777              		@ frame_needed = 0, uses_anonymous_args = 0
 778              		.loc 1 300 59 is_stmt 0 view .LVU221
 779 0000 38B5     		push	{r3, r4, r5, lr}
 780              	.LCFI10:
 781              		.cfi_def_cfa_offset 16
 782              		.cfi_offset 3, -16
 783              		.cfi_offset 4, -12
 784              		.cfi_offset 5, -8
 785              		.cfi_offset 14, -4
 786 0002 0346     		mov	r3, r0
 787 0004 0846     		mov	r0, r1
 788              	.LVL72:
 301:Src/nvm.c     ****     if (offset + length > (n_valid_ << 3))
 789              		.loc 1 301 5 is_stmt 1 view .LVU222
 790              		.loc 1 301 37 is_stmt 0 view .LVU223
 791 0006 0F49     		ldr	r1, .L51
 792              	.LVL73:
 793              		.loc 1 301 37 view .LVU224
 794 0008 0D68     		ldr	r5, [r1]
 795              		.loc 1 301 16 view .LVU225
 796 000a 9918     		adds	r1, r3, r2
 797              		.loc 1 301 8 view .LVU226
 798 000c B1EBC50F 		cmp	r1, r5, lsl #3
 799 0010 15D8     		bhi	.L49
 302:Src/nvm.c     ****         return -1;
 303:Src/nvm.c     ****     sector_t *read_sector = &sectors[read_sector_];
 800              		.loc 1 303 5 is_stmt 1 view .LVU227
ARM GAS  /tmp/ccbl8B2o.s 			page 21


 801              		.loc 1 303 37 is_stmt 0 view .LVU228
 802 0012 0D49     		ldr	r1, .L51+4
 803 0014 91F800C0 		ldrb	ip, [r1]	@ zero_extendqisi2
 804              	.LVL74:
 304:Src/nvm.c     ****     const uint8_t *src_ptr = ((const uint8_t *)&read_sector->data[read_sector->index - n_valid_]) +
 805              		.loc 1 304 5 is_stmt 1 view .LVU229
 305:Src/nvm.c     ****     memcpy(data, src_ptr, length);
 806              		.loc 1 305 5 view .LVU230
 304:Src/nvm.c     ****     const uint8_t *src_ptr = ((const uint8_t *)&read_sector->data[read_sector->index - n_valid_]) +
 807              		.loc 1 304 60 is_stmt 0 view .LVU231
 808 0018 0C4C     		ldr	r4, .L51+8
 809 001a 0CEB4C01 		add	r1, ip, ip, lsl #1
 810 001e 04EBC101 		add	r1, r4, r1, lsl #3
 304:Src/nvm.c     ****     const uint8_t *src_ptr = ((const uint8_t *)&read_sector->data[read_sector->index - n_valid_]) +
 811              		.loc 1 304 78 view .LVU232
 812 0022 0CEB4C0C 		add	ip, ip, ip, lsl #1
 813              	.LVL75:
 304:Src/nvm.c     ****     const uint8_t *src_ptr = ((const uint8_t *)&read_sector->data[read_sector->index - n_valid_]) +
 814              		.loc 1 304 86 view .LVU233
 815 0026 54F83C40 		ldr	r4, [r4, ip, lsl #3]
 816 002a A4EB050C 		sub	ip, r4, r5
 304:Src/nvm.c     ****     const uint8_t *src_ptr = ((const uint8_t *)&read_sector->data[read_sector->index - n_valid_]) +
 817              		.loc 1 304 20 view .LVU234
 818 002e 03EBCC03 		add	r3, r3, ip, lsl #3
 819              	.LVL76:
 304:Src/nvm.c     ****     const uint8_t *src_ptr = ((const uint8_t *)&read_sector->data[read_sector->index - n_valid_]) +
 820              		.loc 1 304 20 view .LVU235
 821 0032 4969     		ldr	r1, [r1, #20]
 822              		.loc 1 305 5 view .LVU236
 823 0034 1944     		add	r1, r1, r3
 824 0036 FFF7FEFF 		bl	memcpy
 825              	.LVL77:
 306:Src/nvm.c     ****     return 0;
 826              		.loc 1 306 5 is_stmt 1 view .LVU237
 827              		.loc 1 306 12 is_stmt 0 view .LVU238
 828 003a 0020     		movs	r0, #0
 829              	.L47:
 307:Src/nvm.c     **** }
 830              		.loc 1 307 1 view .LVU239
 831 003c 38BD     		pop	{r3, r4, r5, pc}
 832              	.LVL78:
 833              	.L49:
 302:Src/nvm.c     ****     sector_t *read_sector = &sectors[read_sector_];
 834              		.loc 1 302 16 view .LVU240
 835 003e 4FF0FF30 		mov	r0, #-1
 836              	.LVL79:
 302:Src/nvm.c     ****     sector_t *read_sector = &sectors[read_sector_];
 837              		.loc 1 302 16 view .LVU241
 838 0042 FBE7     		b	.L47
 839              	.L52:
 840              		.align	2
 841              	.L51:
 842 0044 00000000 		.word	.LANCHOR2
 843 0048 00000000 		.word	.LANCHOR1
 844 004c 00000000 		.word	.LANCHOR0
 845              		.cfi_endproc
 846              	.LFE139:
ARM GAS  /tmp/ccbl8B2o.s 			page 22


 848              		.section	.text.NVM_start_write,"ax",%progbits
 849              		.align	1
 850              		.global	NVM_start_write
 851              		.syntax unified
 852              		.thumb
 853              		.thumb_func
 854              		.fpu fpv4-sp-d16
 856              	NVM_start_write:
 857              	.LVL80:
 858              	.LFB140:
 308:Src/nvm.c     **** 
 309:Src/nvm.c     **** // @brief Starts an atomic write operation.
 310:Src/nvm.c     **** //
 311:Src/nvm.c     **** // The most recent valid NVM data is not modified or invalidated until NVM_commit is called.
 312:Src/nvm.c     **** // The length must be at most equal to the size indicated by NVM_get_max_write_length().
 313:Src/nvm.c     **** //
 314:Src/nvm.c     **** // @param length: Length of the staging block that should be created
 315:Src/nvm.c     **** int NVM_start_write(size_t length) {
 859              		.loc 1 315 36 is_stmt 1 view -0
 860              		.cfi_startproc
 861              		@ args = 0, pretend = 0, frame = 0
 862              		@ frame_needed = 0, uses_anonymous_args = 0
 863              		.loc 1 315 36 is_stmt 0 view .LVU243
 864 0000 70B5     		push	{r4, r5, r6, lr}
 865              	.LCFI11:
 866              		.cfi_def_cfa_offset 16
 867              		.cfi_offset 4, -16
 868              		.cfi_offset 5, -12
 869              		.cfi_offset 6, -8
 870              		.cfi_offset 14, -4
 316:Src/nvm.c     ****     int status = 0;
 871              		.loc 1 316 5 is_stmt 1 view .LVU244
 872              	.LVL81:
 317:Src/nvm.c     ****     sector_t *target = &sectors[1 - read_sector_];
 873              		.loc 1 317 5 view .LVU245
 874              		.loc 1 317 35 is_stmt 0 view .LVU246
 875 0002 174B     		ldr	r3, .L58
 876 0004 1C78     		ldrb	r4, [r3]	@ zero_extendqisi2
 877 0006 C4F10104 		rsb	r4, r4, #1
 878              		.loc 1 317 15 view .LVU247
 879 000a 04EB4403 		add	r3, r4, r4, lsl #1
 880 000e 154D     		ldr	r5, .L58+4
 881 0010 05EBC305 		add	r5, r5, r3, lsl #3
 882              	.LVL82:
 318:Src/nvm.c     **** 
 319:Src/nvm.c     ****     length = (length + 7) >> 3; // round to multiple of 64 bit
 883              		.loc 1 319 5 is_stmt 1 view .LVU248
 884              		.loc 1 319 22 is_stmt 0 view .LVU249
 885 0014 0730     		adds	r0, r0, #7
 886              	.LVL83:
 320:Src/nvm.c     ****     if (length > target->n_data - target->n_reserved)
 887              		.loc 1 320 5 is_stmt 1 view .LVU250
 888              		.loc 1 320 24 is_stmt 0 view .LVU251
 889 0016 AB68     		ldr	r3, [r5, #8]
 890              		.loc 1 320 33 view .LVU252
 891 0018 EA68     		ldr	r2, [r5, #12]
 892 001a 9A1A     		subs	r2, r3, r2
ARM GAS  /tmp/ccbl8B2o.s 			page 23


 893              		.loc 1 320 8 view .LVU253
 894 001c B2EBD00F 		cmp	r2, r0, lsr #3
 895 0020 1AD3     		bcc	.L56
 896 0022 C608     		lsrs	r6, r0, #3
 897              	.LVL84:
 321:Src/nvm.c     ****         return -1;
 322:Src/nvm.c     **** 
 323:Src/nvm.c     ****     // make room for the new data
 324:Src/nvm.c     ****     if (length > target->n_data - target->index)
 898              		.loc 1 324 5 is_stmt 1 view .LVU254
 899              		.loc 1 324 41 is_stmt 0 view .LVU255
 900 0024 04EB4402 		add	r2, r4, r4, lsl #1
 901              		.loc 1 324 33 view .LVU256
 902 0028 0E49     		ldr	r1, .L58+4
 903 002a 51F83220 		ldr	r2, [r1, r2, lsl #3]
 904 002e 9B1A     		subs	r3, r3, r2
 905              		.loc 1 324 8 view .LVU257
 906 0030 B342     		cmp	r3, r6
 907 0032 03D2     		bcs	.L55
 325:Src/nvm.c     ****         if ((status = erase(target)))
 908              		.loc 1 325 9 is_stmt 1 view .LVU258
 909              		.loc 1 325 23 is_stmt 0 view .LVU259
 910 0034 2846     		mov	r0, r5
 911 0036 FFF7FEFF 		bl	erase
 912              	.LVL85:
 913              		.loc 1 325 12 view .LVU260
 914 003a 60B9     		cbnz	r0, .L53
 915              	.LVL86:
 916              	.L55:
 326:Src/nvm.c     ****             return status;
 327:Src/nvm.c     **** 
 328:Src/nvm.c     ****     // invalidate the fields we're about to write
 329:Src/nvm.c     ****     status = set_allocation_state(target, target->index, length, INVALID);
 917              		.loc 1 329 5 is_stmt 1 view .LVU261
 918              		.loc 1 329 14 is_stmt 0 view .LVU262
 919 003c 04EB4404 		add	r4, r4, r4, lsl #1
 920 0040 0123     		movs	r3, #1
 921 0042 3246     		mov	r2, r6
 922 0044 0749     		ldr	r1, .L58+4
 923 0046 51F83410 		ldr	r1, [r1, r4, lsl #3]
 924 004a 2846     		mov	r0, r5
 925 004c FFF7FEFF 		bl	set_allocation_state
 926              	.LVL87:
 330:Src/nvm.c     ****     if (status)
 927              		.loc 1 330 5 is_stmt 1 view .LVU263
 928              		.loc 1 330 8 is_stmt 0 view .LVU264
 929 0050 08B9     		cbnz	r0, .L53
 331:Src/nvm.c     ****         return status;
 332:Src/nvm.c     **** 
 333:Src/nvm.c     ****     n_staging_area_ = length;
 930              		.loc 1 333 5 is_stmt 1 view .LVU265
 931              		.loc 1 333 21 is_stmt 0 view .LVU266
 932 0052 054B     		ldr	r3, .L58+8
 933 0054 1E60     		str	r6, [r3]
 334:Src/nvm.c     ****     return 0;
 934              		.loc 1 334 5 is_stmt 1 view .LVU267
 935              	.LVL88:
ARM GAS  /tmp/ccbl8B2o.s 			page 24


 936              	.L53:
 335:Src/nvm.c     **** }
 937              		.loc 1 335 1 is_stmt 0 view .LVU268
 938 0056 70BD     		pop	{r4, r5, r6, pc}
 939              	.LVL89:
 940              	.L56:
 321:Src/nvm.c     **** 
 941              		.loc 1 321 16 view .LVU269
 942 0058 4FF0FF30 		mov	r0, #-1
 943              	.LVL90:
 321:Src/nvm.c     **** 
 944              		.loc 1 321 16 view .LVU270
 945 005c FBE7     		b	.L53
 946              	.L59:
 947 005e 00BF     		.align	2
 948              	.L58:
 949 0060 00000000 		.word	.LANCHOR1
 950 0064 00000000 		.word	.LANCHOR0
 951 0068 00000000 		.word	.LANCHOR3
 952              		.cfi_endproc
 953              	.LFE140:
 955              		.section	.text.NVM_write,"ax",%progbits
 956              		.align	1
 957              		.global	NVM_write
 958              		.syntax unified
 959              		.thumb
 960              		.thumb_func
 961              		.fpu fpv4-sp-d16
 963              	NVM_write:
 964              	.LVL91:
 965              	.LFB141:
 336:Src/nvm.c     **** 
 337:Src/nvm.c     **** // @brief Writes to the current data block that was opened with NVM_start_write.
 338:Src/nvm.c     **** //
 339:Src/nvm.c     **** // The operation fails if (offset + length) is larger than the length passed to NVM_start_write.
 340:Src/nvm.c     **** // The most recent valid NVM data is not modified or invalidated until NVM_commit is called.
 341:Src/nvm.c     **** // Warning: Writing different data to the same area multiple times during a single transaction
 342:Src/nvm.c     **** // will cause data corruption.
 343:Src/nvm.c     **** //
 344:Src/nvm.c     **** // @param offset: The offset in bytes, 0 being the beginning of the staging block.
 345:Src/nvm.c     **** // @param data: Pointer to the data that should be written
 346:Src/nvm.c     **** // @param length: Data length in bytes
 347:Src/nvm.c     **** int NVM_write(size_t offset, uint8_t *data, size_t length) {
 966              		.loc 1 347 60 is_stmt 1 view -0
 967              		.cfi_startproc
 968              		@ args = 0, pretend = 0, frame = 0
 969              		@ frame_needed = 0, uses_anonymous_args = 0
 970              		.loc 1 347 60 is_stmt 0 view .LVU272
 971 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 972              	.LCFI12:
 973              		.cfi_def_cfa_offset 32
 974              		.cfi_offset 4, -32
 975              		.cfi_offset 5, -28
 976              		.cfi_offset 6, -24
 977              		.cfi_offset 7, -20
 978              		.cfi_offset 8, -16
 979              		.cfi_offset 9, -12
ARM GAS  /tmp/ccbl8B2o.s 			page 25


 980              		.cfi_offset 10, -8
 981              		.cfi_offset 14, -4
 982 0004 1446     		mov	r4, r2
 348:Src/nvm.c     ****     if (offset + length > (n_staging_area_ << 3))
 983              		.loc 1 348 5 is_stmt 1 view .LVU273
 984              		.loc 1 348 16 is_stmt 0 view .LVU274
 985 0006 8318     		adds	r3, r0, r2
 986              		.loc 1 348 44 view .LVU275
 987 0008 4B4A     		ldr	r2, .L84
 988              	.LVL92:
 989              		.loc 1 348 44 view .LVU276
 990 000a 1268     		ldr	r2, [r2]
 991              		.loc 1 348 8 view .LVU277
 992 000c B3EBC20F 		cmp	r3, r2, lsl #3
 993 0010 00F28E80 		bhi	.L75
 994 0014 0546     		mov	r5, r0
 995 0016 0E46     		mov	r6, r1
 349:Src/nvm.c     ****         return -1;
 350:Src/nvm.c     ****     sector_t *target = &sectors[1 - read_sector_];
 996              		.loc 1 350 5 is_stmt 1 view .LVU278
 997              		.loc 1 350 35 is_stmt 0 view .LVU279
 998 0018 484B     		ldr	r3, .L84+4
 999 001a 93F80080 		ldrb	r8, [r3]	@ zero_extendqisi2
 1000 001e C8F10108 		rsb	r8, r8, #1
 1001              	.LVL93:
 351:Src/nvm.c     **** 
 352:Src/nvm.c     ****     HAL_FLASH_Unlock();
 1002              		.loc 1 352 5 is_stmt 1 view .LVU280
 1003 0022 FFF7FEFF 		bl	HAL_FLASH_Unlock
 1004              	.LVL94:
 353:Src/nvm.c     ****     HAL_FLASH_ClearError();
 1005              		.loc 1 353 5 view .LVU281
 1006              		.loc 1 353 5 view .LVU282
 1007              		.loc 1 353 5 view .LVU283
 1008 0026 464B     		ldr	r3, .L84+8
 1009 0028 9A69     		ldr	r2, [r3, #24]
 1010 002a 42F04042 		orr	r2, r2, #-1073741824
 1011 002e 9A61     		str	r2, [r3, #24]
 1012              		.loc 1 353 5 view .LVU284
 1013              		.loc 1 353 5 view .LVU285
 1014 0030 4CF2FA32 		movw	r2, #50170
 1015 0034 1A61     		str	r2, [r3, #16]
 354:Src/nvm.c     **** 
 355:Src/nvm.c     ****     // handle unaligned start
 356:Src/nvm.c     ****     // Handle unaligned start with doubleword writes
 357:Src/nvm.c     ****     for (; (offset & 0x7) && length; ++data, ++offset, --length)
 1016              		.loc 1 357 12 view .LVU286
 1017              		.loc 1 357 5 is_stmt 0 view .LVU287
 1018 0036 15F0070F 		tst	r5, #7
 1019 003a 1DD0     		beq	.L62
 1020              		.loc 1 357 27 view .LVU288
 1021 003c 002C     		cmp	r4, #0
 1022 003e 39D0     		beq	.L73
 358:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 359:Src/nvm.c     ****                 ((uintptr_t)&target->data[target->index]) + offset, 
 1023              		.loc 1 359 36 view .LVU289
 1024 0040 08EB4807 		add	r7, r8, r8, lsl #1
ARM GAS  /tmp/ccbl8B2o.s 			page 26


 1025 0044 3F4B     		ldr	r3, .L84+12
 1026 0046 03EBC707 		add	r7, r3, r7, lsl #3
 358:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 1027              		.loc 1 358 13 view .LVU290
 1028 004a 4FF00009 		mov	r9, #0
 1029              	.L68:
 358:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 1030              		.loc 1 358 9 is_stmt 1 view .LVU291
 1031              		.loc 1 359 42 is_stmt 0 view .LVU292
 1032 004e 3B68     		ldr	r3, [r7]
 1033              		.loc 1 359 29 view .LVU293
 1034 0050 7969     		ldr	r1, [r7, #20]
 1035 0052 01EBC301 		add	r1, r1, r3, lsl #3
 358:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 1036              		.loc 1 358 13 view .LVU294
 1037 0056 D6E90023 		ldrd	r2, [r6]
 1038 005a 2944     		add	r1, r1, r5
 1039 005c 4846     		mov	r0, r9
 1040 005e FFF7FEFF 		bl	HAL_FLASH_Program
 1041              	.LVL95:
 358:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 1042              		.loc 1 358 12 view .LVU295
 1043 0062 0028     		cmp	r0, #0
 1044 0064 41D1     		bne	.L64
 357:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 1045              		.loc 1 357 38 is_stmt 1 view .LVU296
 1046 0066 0136     		adds	r6, r6, #1
 1047              	.LVL96:
 357:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 1048              		.loc 1 357 46 is_stmt 0 view .LVU297
 1049 0068 0135     		adds	r5, r5, #1
 1050              	.LVL97:
 357:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 1051              		.loc 1 357 56 view .LVU298
 1052 006a 013C     		subs	r4, r4, #1
 1053              	.LVL98:
 357:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 1054              		.loc 1 357 12 is_stmt 1 view .LVU299
 357:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 1055              		.loc 1 357 5 is_stmt 0 view .LVU300
 1056 006c 15F0070F 		tst	r5, #7
 1057 0070 02D0     		beq	.L62
 357:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 1058              		.loc 1 357 27 discriminator 2 view .LVU301
 1059 0072 002C     		cmp	r4, #0
 1060 0074 EBD1     		bne	.L68
 1061 0076 1DE0     		b	.L73
 1062              	.L62:
 360:Src/nvm.c     ****                 *(uint64_t*)data) != HAL_OK)
 361:Src/nvm.c     ****             goto fail;
 362:Src/nvm.c     **** 
 363:Src/nvm.c     ****     // Write 32-bit values in fast mode
 364:Src/nvm.c     ****     for (; length >= 8; data += 8, offset += 8, length -= 8) {
 1063              		.loc 1 364 12 is_stmt 1 discriminator 1 view .LVU302
 1064              		.loc 1 364 5 is_stmt 0 discriminator 1 view .LVU303
 1065 0078 072C     		cmp	r4, #7
 1066 007a 3CD9     		bls	.L81
ARM GAS  /tmp/ccbl8B2o.s 			page 27


 1067              		.loc 1 364 5 discriminator 1 view .LVU304
 1068 007c 3746     		mov	r7, r6
 365:Src/nvm.c     ****         if (length == 8) {
 366:Src/nvm.c     ****             // Last word uses FAST_AND_LAST
 367:Src/nvm.c     ****             if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_FAST_AND_LAST,
 368:Src/nvm.c     ****                     ((uintptr_t)&target->data[target->index]) + offset, 
 369:Src/nvm.c     ****                     *(uint64_t*)data) != HAL_OK)
 370:Src/nvm.c     ****                 goto fail;
 371:Src/nvm.c     ****         } else {
 372:Src/nvm.c     ****             // Regular fast programming
 373:Src/nvm.c     ****             if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_FAST,
 374:Src/nvm.c     ****                     ((uintptr_t)&target->data[target->index]) + offset, 
 1069              		.loc 1 374 40 view .LVU305
 1070 007e 08EB4809 		add	r9, r8, r8, lsl #1
 1071 0082 304B     		ldr	r3, .L84+12
 1072 0084 03EBC909 		add	r9, r3, r9, lsl #3
 373:Src/nvm.c     ****                     ((uintptr_t)&target->data[target->index]) + offset, 
 1073              		.loc 1 373 17 view .LVU306
 1074 0088 4FF0010A 		mov	r10, #1
 1075 008c 1BE0     		b	.L71
 1076              	.LVL99:
 1077              	.L82:
 367:Src/nvm.c     ****                     ((uintptr_t)&target->data[target->index]) + offset, 
 1078              		.loc 1 367 13 is_stmt 1 view .LVU307
 368:Src/nvm.c     ****                     *(uint64_t*)data) != HAL_OK)
 1079              		.loc 1 368 40 is_stmt 0 view .LVU308
 1080 008e 2D49     		ldr	r1, .L84+12
 1081 0090 08EB4802 		add	r2, r8, r8, lsl #1
 1082 0094 01EBC202 		add	r2, r1, r2, lsl #3
 368:Src/nvm.c     ****                     *(uint64_t*)data) != HAL_OK)
 1083              		.loc 1 368 53 view .LVU309
 1084 0098 08EB4808 		add	r8, r8, r8, lsl #1
 1085              	.LVL100:
 368:Src/nvm.c     ****                     *(uint64_t*)data) != HAL_OK)
 1086              		.loc 1 368 46 view .LVU310
 1087 009c 51F83800 		ldr	r0, [r1, r8, lsl #3]
 368:Src/nvm.c     ****                     *(uint64_t*)data) != HAL_OK)
 1088              		.loc 1 368 33 view .LVU311
 1089 00a0 5169     		ldr	r1, [r2, #20]
 1090 00a2 01EBC001 		add	r1, r1, r0, lsl #3
 367:Src/nvm.c     ****                     ((uintptr_t)&target->data[target->index]) + offset, 
 1091              		.loc 1 367 17 view .LVU312
 1092 00a6 D7E90023 		ldrd	r2, [r7]
 1093 00aa 2944     		add	r1, r1, r5
 1094 00ac 0220     		movs	r0, #2
 1095 00ae FFF7FEFF 		bl	HAL_FLASH_Program
 1096              	.LVL101:
 367:Src/nvm.c     ****                     ((uintptr_t)&target->data[target->index]) + offset, 
 1097              		.loc 1 367 16 view .LVU313
 1098 00b2 D0B9     		cbnz	r0, .L64
 1099              	.LVL102:
 1100              	.L73:
 375:Src/nvm.c     ****                     *(uint64_t*)data) != HAL_OK)
 376:Src/nvm.c     ****                 goto fail;
 377:Src/nvm.c     ****         }
 378:Src/nvm.c     ****     }
 379:Src/nvm.c     **** 
ARM GAS  /tmp/ccbl8B2o.s 			page 28


 380:Src/nvm.c     ****     // Handle remaining bytes with doubleword writes
 381:Src/nvm.c     ****     for (; length; ++data, ++offset, --length)
 382:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 383:Src/nvm.c     ****                 ((uintptr_t)&target->data[target->index]) + offset, 
 384:Src/nvm.c     ****                 *(uint64_t*)data) != HAL_OK)
 385:Src/nvm.c     ****             goto fail;
 386:Src/nvm.c     **** 
 387:Src/nvm.c     **** 
 388:Src/nvm.c     ****     HAL_FLASH_Lock();
 1101              		.loc 1 388 5 is_stmt 1 view .LVU314
 1102 00b4 FFF7FEFF 		bl	HAL_FLASH_Lock
 1103              	.LVL103:
 389:Src/nvm.c     ****     return 0;
 1104              		.loc 1 389 5 view .LVU315
 1105              		.loc 1 389 12 is_stmt 0 view .LVU316
 1106 00b8 0020     		movs	r0, #0
 1107 00ba 1AE0     		b	.L60
 1108              	.LVL104:
 1109              	.L83:
 364:Src/nvm.c     ****         if (length == 8) {
 1110              		.loc 1 364 25 is_stmt 1 view .LVU317
 364:Src/nvm.c     ****         if (length == 8) {
 1111              		.loc 1 364 30 is_stmt 0 view .LVU318
 1112 00bc 3E46     		mov	r6, r7
 1113              	.LVL105:
 364:Src/nvm.c     ****         if (length == 8) {
 1114              		.loc 1 364 43 view .LVU319
 1115 00be 0835     		adds	r5, r5, #8
 1116              	.LVL106:
 364:Src/nvm.c     ****         if (length == 8) {
 1117              		.loc 1 364 56 view .LVU320
 1118 00c0 083C     		subs	r4, r4, #8
 1119              	.LVL107:
 364:Src/nvm.c     ****         if (length == 8) {
 1120              		.loc 1 364 12 is_stmt 1 view .LVU321
 364:Src/nvm.c     ****         if (length == 8) {
 1121              		.loc 1 364 5 is_stmt 0 view .LVU322
 1122 00c2 072C     		cmp	r4, #7
 1123 00c4 19D9     		bls	.L72
 1124              	.L71:
 364:Src/nvm.c     ****         if (length == 8) {
 1125              		.loc 1 364 5 view .LVU323
 1126 00c6 3B46     		mov	r3, r7
 1127              	.LVL108:
 365:Src/nvm.c     ****             // Last word uses FAST_AND_LAST
 1128              		.loc 1 365 9 is_stmt 1 view .LVU324
 365:Src/nvm.c     ****             // Last word uses FAST_AND_LAST
 1129              		.loc 1 365 12 is_stmt 0 view .LVU325
 1130 00c8 082C     		cmp	r4, #8
 1131 00ca E0D0     		beq	.L82
 373:Src/nvm.c     ****                     ((uintptr_t)&target->data[target->index]) + offset, 
 1132              		.loc 1 373 13 is_stmt 1 view .LVU326
 1133 00cc 0837     		adds	r7, r7, #8
 374:Src/nvm.c     ****                     *(uint64_t*)data) != HAL_OK)
 1134              		.loc 1 374 46 is_stmt 0 view .LVU327
 1135 00ce D9F80020 		ldr	r2, [r9]
 374:Src/nvm.c     ****                     *(uint64_t*)data) != HAL_OK)
ARM GAS  /tmp/ccbl8B2o.s 			page 29


 1136              		.loc 1 374 33 view .LVU328
 1137 00d2 D9F81410 		ldr	r1, [r9, #20]
 1138 00d6 01EBC201 		add	r1, r1, r2, lsl #3
 373:Src/nvm.c     ****                     ((uintptr_t)&target->data[target->index]) + offset, 
 1139              		.loc 1 373 17 view .LVU329
 1140 00da D3E90023 		ldrd	r2, [r3]
 1141 00de 2944     		add	r1, r1, r5
 1142 00e0 5046     		mov	r0, r10
 1143 00e2 FFF7FEFF 		bl	HAL_FLASH_Program
 1144              	.LVL109:
 373:Src/nvm.c     ****                     ((uintptr_t)&target->data[target->index]) + offset, 
 1145              		.loc 1 373 16 view .LVU330
 1146 00e6 0028     		cmp	r0, #0
 1147 00e8 E8D0     		beq	.L83
 1148              	.LVL110:
 1149              	.L64:
 390:Src/nvm.c     **** fail:
 391:Src/nvm.c     ****     HAL_FLASH_Lock();
 1150              		.loc 1 391 5 is_stmt 1 view .LVU331
 1151 00ea FFF7FEFF 		bl	HAL_FLASH_Lock
 1152              	.LVL111:
 392:Src/nvm.c     ****     return HAL_FLASH_GetError(); // non-zero
 1153              		.loc 1 392 5 view .LVU332
 1154              		.loc 1 392 12 is_stmt 0 view .LVU333
 1155 00ee FFF7FEFF 		bl	HAL_FLASH_GetError
 1156              	.LVL112:
 1157              	.L60:
 393:Src/nvm.c     **** }
 1158              		.loc 1 393 1 view .LVU334
 1159 00f2 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 1160              	.LVL113:
 1161              	.L81:
 381:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 1162              		.loc 1 381 12 is_stmt 1 view .LVU335
 381:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 1163              		.loc 1 381 5 is_stmt 0 view .LVU336
 1164 00f6 002C     		cmp	r4, #0
 1165 00f8 DCD0     		beq	.L73
 1166              	.L72:
 381:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 1167              		.loc 1 381 5 view .LVU337
 1168 00fa 2C44     		add	r4, r4, r5
 1169              	.LVL114:
 347:Src/nvm.c     ****     if (offset + length > (n_staging_area_ << 3))
 1170              		.loc 1 347 60 view .LVU338
 1171 00fc 2F46     		mov	r7, r5
 382:Src/nvm.c     ****                 ((uintptr_t)&target->data[target->index]) + offset, 
 1172              		.loc 1 382 13 view .LVU339
 1173 00fe 751B     		subs	r5, r6, r5
 1174              	.LVL115:
 383:Src/nvm.c     ****                 *(uint64_t*)data) != HAL_OK)
 1175              		.loc 1 383 36 view .LVU340
 1176 0100 08EB4808 		add	r8, r8, r8, lsl #1
 1177              	.LVL116:
 383:Src/nvm.c     ****                 *(uint64_t*)data) != HAL_OK)
 1178              		.loc 1 383 36 view .LVU341
 1179 0104 0F4B     		ldr	r3, .L84+12
ARM GAS  /tmp/ccbl8B2o.s 			page 30


 1180 0106 03EBC808 		add	r8, r3, r8, lsl #3
 1181              	.LVL117:
 1182              	.L74:
 382:Src/nvm.c     ****                 ((uintptr_t)&target->data[target->index]) + offset, 
 1183              		.loc 1 382 9 is_stmt 1 view .LVU342
 382:Src/nvm.c     ****                 ((uintptr_t)&target->data[target->index]) + offset, 
 1184              		.loc 1 382 13 is_stmt 0 view .LVU343
 1185 010a EB19     		adds	r3, r5, r7
 383:Src/nvm.c     ****                 *(uint64_t*)data) != HAL_OK)
 1186              		.loc 1 383 42 view .LVU344
 1187 010c D8F80020 		ldr	r2, [r8]
 383:Src/nvm.c     ****                 *(uint64_t*)data) != HAL_OK)
 1188              		.loc 1 383 29 view .LVU345
 1189 0110 D8F81410 		ldr	r1, [r8, #20]
 1190 0114 01EBC201 		add	r1, r1, r2, lsl #3
 382:Src/nvm.c     ****                 ((uintptr_t)&target->data[target->index]) + offset, 
 1191              		.loc 1 382 13 view .LVU346
 1192 0118 D3E90023 		ldrd	r2, [r3]
 1193 011c 3944     		add	r1, r1, r7
 1194 011e 0020     		movs	r0, #0
 1195 0120 FFF7FEFF 		bl	HAL_FLASH_Program
 1196              	.LVL118:
 382:Src/nvm.c     ****                 ((uintptr_t)&target->data[target->index]) + offset, 
 1197              		.loc 1 382 12 view .LVU347
 1198 0124 0028     		cmp	r0, #0
 1199 0126 E0D1     		bne	.L64
 381:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 1200              		.loc 1 381 20 is_stmt 1 view .LVU348
 381:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 1201              		.loc 1 381 28 is_stmt 0 view .LVU349
 1202 0128 0137     		adds	r7, r7, #1
 1203              	.LVL119:
 381:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 1204              		.loc 1 381 12 is_stmt 1 view .LVU350
 381:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 1205              		.loc 1 381 5 is_stmt 0 view .LVU351
 1206 012a A742     		cmp	r7, r4
 1207 012c EDD1     		bne	.L74
 1208 012e C1E7     		b	.L73
 1209              	.LVL120:
 1210              	.L75:
 349:Src/nvm.c     ****     sector_t *target = &sectors[1 - read_sector_];
 1211              		.loc 1 349 16 view .LVU352
 1212 0130 4FF0FF30 		mov	r0, #-1
 1213              	.LVL121:
 349:Src/nvm.c     ****     sector_t *target = &sectors[1 - read_sector_];
 1214              		.loc 1 349 16 view .LVU353
 1215 0134 DDE7     		b	.L60
 1216              	.L85:
 1217 0136 00BF     		.align	2
 1218              	.L84:
 1219 0138 00000000 		.word	.LANCHOR3
 1220 013c 00000000 		.word	.LANCHOR1
 1221 0140 00200240 		.word	1073881088
 1222 0144 00000000 		.word	.LANCHOR0
 1223              		.cfi_endproc
 1224              	.LFE141:
ARM GAS  /tmp/ccbl8B2o.s 			page 31


 1226              		.section	.text.NVM_commit,"ax",%progbits
 1227              		.align	1
 1228              		.global	NVM_commit
 1229              		.syntax unified
 1230              		.thumb
 1231              		.thumb_func
 1232              		.fpu fpv4-sp-d16
 1234              	NVM_commit:
 1235              	.LFB142:
 394:Src/nvm.c     **** 
 395:Src/nvm.c     **** // @brief Commits the new data to NVM atomically.
 396:Src/nvm.c     **** int NVM_commit(void) {
 1236              		.loc 1 396 22 is_stmt 1 view -0
 1237              		.cfi_startproc
 1238              		@ args = 0, pretend = 0, frame = 0
 1239              		@ frame_needed = 0, uses_anonymous_args = 0
 1240 0000 70B5     		push	{r4, r5, r6, lr}
 1241              	.LCFI13:
 1242              		.cfi_def_cfa_offset 16
 1243              		.cfi_offset 4, -16
 1244              		.cfi_offset 5, -12
 1245              		.cfi_offset 6, -8
 1246              		.cfi_offset 14, -4
 397:Src/nvm.c     ****     sector_t *read_sector = &sectors[read_sector_];
 1247              		.loc 1 397 5 view .LVU355
 1248              		.loc 1 397 37 is_stmt 0 view .LVU356
 1249 0002 1F4B     		ldr	r3, .L90
 1250 0004 1D78     		ldrb	r5, [r3]	@ zero_extendqisi2
 1251              	.LVL122:
 398:Src/nvm.c     ****     sector_t *write_sector = &sectors[1 - read_sector_];
 1252              		.loc 1 398 5 is_stmt 1 view .LVU357
 1253              		.loc 1 398 41 is_stmt 0 view .LVU358
 1254 0006 C5F10104 		rsb	r4, r5, #1
 1255              	.LVL123:
 399:Src/nvm.c     **** 
 400:Src/nvm.c     ****     // mark the newly-written fields as valid
 401:Src/nvm.c     ****     int status = set_allocation_state(write_sector, write_sector->index, n_staging_area_, VALID);
 1256              		.loc 1 401 5 is_stmt 1 view .LVU359
 1257              		.loc 1 401 18 is_stmt 0 view .LVU360
 1258 000a 1E48     		ldr	r0, .L90+4
 1259 000c 04EB440C 		add	ip, r4, r4, lsl #1
 1260 0010 0023     		movs	r3, #0
 1261 0012 1D4A     		ldr	r2, .L90+8
 1262 0014 1268     		ldr	r2, [r2]
 1263 0016 50F83C10 		ldr	r1, [r0, ip, lsl #3]
 1264 001a 00EBCC00 		add	r0, r0, ip, lsl #3
 1265 001e FFF7FEFF 		bl	set_allocation_state
 1266              	.LVL124:
 402:Src/nvm.c     ****     if (status)
 1267              		.loc 1 402 5 is_stmt 1 view .LVU361
 1268              		.loc 1 402 8 is_stmt 0 view .LVU362
 1269 0022 48BB     		cbnz	r0, .L86
 397:Src/nvm.c     ****     sector_t *write_sector = &sectors[1 - read_sector_];
 1270              		.loc 1 397 15 view .LVU363
 1271 0024 174B     		ldr	r3, .L90+4
 1272 0026 05EB4500 		add	r0, r5, r5, lsl #1
 1273 002a 03EBC000 		add	r0, r3, r0, lsl #3
ARM GAS  /tmp/ccbl8B2o.s 			page 32


 403:Src/nvm.c     ****         return status;
 404:Src/nvm.c     **** 
 405:Src/nvm.c     ****     write_sector->index += n_staging_area_;
 1274              		.loc 1 405 5 is_stmt 1 view .LVU364
 1275              		.loc 1 405 25 is_stmt 0 view .LVU365
 1276 002e 1649     		ldr	r1, .L90+8
 1277 0030 0E68     		ldr	r6, [r1]
 1278 0032 04EB440C 		add	ip, r4, r4, lsl #1
 1279 0036 53F83C20 		ldr	r2, [r3, ip, lsl #3]
 1280 003a 3244     		add	r2, r2, r6
 1281 003c 43F83C20 		str	r2, [r3, ip, lsl #3]
 406:Src/nvm.c     ****     n_valid_ = n_staging_area_;
 1282              		.loc 1 406 5 is_stmt 1 view .LVU366
 1283              		.loc 1 406 14 is_stmt 0 view .LVU367
 1284 0040 124A     		ldr	r2, .L90+12
 1285 0042 1660     		str	r6, [r2]
 407:Src/nvm.c     ****     n_staging_area_ = 0;
 1286              		.loc 1 407 5 is_stmt 1 view .LVU368
 1287              		.loc 1 407 21 is_stmt 0 view .LVU369
 1288 0044 0022     		movs	r2, #0
 1289              	.LVL125:
 1290              		.loc 1 407 21 view .LVU370
 1291 0046 0A60     		str	r2, [r1]
 408:Src/nvm.c     ****     read_sector_ = 1 - read_sector_;
 1292              		.loc 1 408 5 is_stmt 1 view .LVU371
 1293              		.loc 1 408 18 is_stmt 0 view .LVU372
 1294 0048 0D49     		ldr	r1, .L90
 1295              		.loc 1 408 22 view .LVU373
 1296 004a 0A78     		ldrb	r2, [r1]	@ zero_extendqisi2
 1297              	.LVL126:
 1298              		.loc 1 408 22 view .LVU374
 1299 004c C2F10102 		rsb	r2, r2, #1
 1300              		.loc 1 408 18 view .LVU375
 1301 0050 0A70     		strb	r2, [r1]
 409:Src/nvm.c     **** 
 410:Src/nvm.c     ****     // invalidate the other sector
 411:Src/nvm.c     ****     if (read_sector->index < read_sector->n_data) {
 1302              		.loc 1 411 5 is_stmt 1 view .LVU376
 1303              		.loc 1 411 20 is_stmt 0 view .LVU377
 1304 0052 05EB4502 		add	r2, r5, r5, lsl #1
 1305 0056 53F83210 		ldr	r1, [r3, r2, lsl #3]
 1306              		.loc 1 411 8 view .LVU378
 1307 005a 8368     		ldr	r3, [r0, #8]
 1308 005c 9942     		cmp	r1, r3
 1309 005e 0CD2     		bcs	.L88
 412:Src/nvm.c     ****         status = set_allocation_state(read_sector, read_sector->index, 1, INVALID);
 1310              		.loc 1 412 9 is_stmt 1 view .LVU379
 1311              		.loc 1 412 18 is_stmt 0 view .LVU380
 1312 0060 0123     		movs	r3, #1
 1313 0062 1A46     		mov	r2, r3
 1314 0064 FFF7FEFF 		bl	set_allocation_state
 1315              	.LVL127:
 413:Src/nvm.c     ****         read_sector->index += 1;
 1316              		.loc 1 413 9 is_stmt 1 view .LVU381
 1317              		.loc 1 413 28 is_stmt 0 view .LVU382
 1318 0068 064A     		ldr	r2, .L90+4
 1319 006a 05EB4501 		add	r1, r5, r5, lsl #1
ARM GAS  /tmp/ccbl8B2o.s 			page 33


 1320 006e 52F83130 		ldr	r3, [r2, r1, lsl #3]
 1321 0072 0133     		adds	r3, r3, #1
 1322 0074 42F83130 		str	r3, [r2, r1, lsl #3]
 1323              	.LVL128:
 1324              	.L86:
 414:Src/nvm.c     ****     } else {
 415:Src/nvm.c     ****         status = erase(read_sector);
 416:Src/nvm.c     ****     }
 417:Src/nvm.c     **** 
 418:Src/nvm.c     ****     return status;
 419:Src/nvm.c     **** }
 1325              		.loc 1 419 1 view .LVU383
 1326 0078 70BD     		pop	{r4, r5, r6, pc}
 1327              	.LVL129:
 1328              	.L88:
 415:Src/nvm.c     ****     }
 1329              		.loc 1 415 9 is_stmt 1 view .LVU384
 415:Src/nvm.c     ****     }
 1330              		.loc 1 415 18 is_stmt 0 view .LVU385
 1331 007a FFF7FEFF 		bl	erase
 1332              	.LVL130:
 415:Src/nvm.c     ****     }
 1333              		.loc 1 415 18 view .LVU386
 1334 007e FBE7     		b	.L86
 1335              	.L91:
 1336              		.align	2
 1337              	.L90:
 1338 0080 00000000 		.word	.LANCHOR1
 1339 0084 00000000 		.word	.LANCHOR0
 1340 0088 00000000 		.word	.LANCHOR3
 1341 008c 00000000 		.word	.LANCHOR2
 1342              		.cfi_endproc
 1343              	.LFE142:
 1345              		.section	.rodata.NVM_demo.str1.4,"aMS",%progbits,1
 1346              		.align	2
 1347              	.LC0:
 1348 0000 3D3D3D20 		.ascii	"=== NVM TEST ===\015\000"
 1348      4E564D20 
 1348      54455354 
 1348      203D3D3D 
 1348      0D00
 1349 0012 0000     		.align	2
 1350              	.LC1:
 1351 0014 4E564D20 		.ascii	"NVM contains %d valid bytes:\015\012\000"
 1351      636F6E74 
 1351      61696E73 
 1351      20256420 
 1351      76616C69 
 1352 0033 00       		.align	2
 1353              	.LC2:
 1354 0034 20253032 		.ascii	" %02x\000"
 1354      7800
 1355 003a 0000     		.align	2
 1356              	.LC3:
 1357 003c 0D00     		.ascii	"\015\000"
 1358 003e 0000     		.align	2
 1359              	.LC4:
ARM GAS  /tmp/ccbl8B2o.s 			page 34


 1360 0040 4E564D20 		.ascii	"NVM is empty\015\000"
 1360      69732065 
 1360      6D707479 
 1360      0D00
 1361 004e 0000     		.align	2
 1362              	.LC5:
 1363 0050 77726974 		.ascii	"write 0x%02x, ..., 0x%02x to NVM\015\012\000"
 1363      65203078 
 1363      25303278 
 1363      2C202E2E 
 1363      2E2C2030 
 1364 0073 00       		.align	2
 1365              	.LC6:
 1366 0074 6E657720 		.ascii	"new data committed to NVM\015\000"
 1366      64617461 
 1366      20636F6D 
 1366      6D697474 
 1366      65642074 
 1367 008f 00       		.align	2
 1368              	.LC7:
 1369 0090 4E564D20 		.ascii	"NVM test failed at %d!\015\012\000"
 1369      74657374 
 1369      20666169 
 1369      6C656420 
 1369      61742025 
 1370              		.section	.text.NVM_demo,"ax",%progbits
 1371              		.align	1
 1372              		.global	NVM_demo
 1373              		.syntax unified
 1374              		.thumb
 1375              		.thumb_func
 1376              		.fpu fpv4-sp-d16
 1378              	NVM_demo:
 1379              	.LFB148:
 420:Src/nvm.c     **** 
 421:Src/nvm.c     **** 
 422:Src/nvm.c     **** #include <cmsis_os.h>
 423:Src/nvm.c     **** /** @brief Call this at startup to test/demo the NVM driver
 424:Src/nvm.c     **** 
 425:Src/nvm.c     ****  Expected output when starting with a fully erased NVM
 426:Src/nvm.c     **** 
 427:Src/nvm.c     ****     [1st boot]
 428:Src/nvm.c     ****     === NVM TEST ===
 429:Src/nvm.c     ****     NVM is empty
 430:Src/nvm.c     ****     write 0x00, ..., 0x25 to NVM
 431:Src/nvm.c     ****     new data committed to NVM
 432:Src/nvm.c     ****     
 433:Src/nvm.c     ****     [2nd boot]
 434:Src/nvm.c     ****     === NVM TEST ===
 435:Src/nvm.c     ****     NVM contains 40 valid bytes:
 436:Src/nvm.c     ****     00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f
 437:Src/nvm.c     ****     10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f
 438:Src/nvm.c     ****     20 21 22 23 24 25 ff ff
 439:Src/nvm.c     ****     write 0xbd, ..., 0xe2 to NVM
 440:Src/nvm.c     ****     new data committed to NVM
 441:Src/nvm.c     **** 
 442:Src/nvm.c     ****     [3rd boot]
ARM GAS  /tmp/ccbl8B2o.s 			page 35


 443:Src/nvm.c     ****     === NVM TEST ===
 444:Src/nvm.c     ****     NVM contains 40 valid bytes:
 445:Src/nvm.c     ****     bd be bf c0 c1 c2 c3 c4 c5 c6 c7 c8 c9 ca cb cc
 446:Src/nvm.c     ****     cd ce cf d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 da db dc
 447:Src/nvm.c     ****     dd de df e0 e1 e2 ff ff
 448:Src/nvm.c     ****     write 0xcb, ..., 0xf0 to NVM
 449:Src/nvm.c     ****     new data committed to NVM
 450:Src/nvm.c     **** */
 451:Src/nvm.c     **** void NVM_demo(void) {
 1380              		.loc 1 451 21 is_stmt 1 view -0
 1381              		.cfi_startproc
 1382              		@ args = 0, pretend = 0, frame = 48
 1383              		@ frame_needed = 1, uses_anonymous_args = 0
 1384 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1385              	.LCFI14:
 1386              		.cfi_def_cfa_offset 36
 1387              		.cfi_offset 4, -36
 1388              		.cfi_offset 5, -32
 1389              		.cfi_offset 6, -28
 1390              		.cfi_offset 7, -24
 1391              		.cfi_offset 8, -20
 1392              		.cfi_offset 9, -16
 1393              		.cfi_offset 10, -12
 1394              		.cfi_offset 11, -8
 1395              		.cfi_offset 14, -4
 1396 0004 8DB0     		sub	sp, sp, #52
 1397              	.LCFI15:
 1398              		.cfi_def_cfa_offset 88
 1399 0006 00AF     		add	r7, sp, #0
 1400              	.LCFI16:
 1401              		.cfi_def_cfa_register 7
 1402              		.loc 1 451 21 is_stmt 0 view .LVU388
 1403 0008 E946     		mov	r9, sp
 452:Src/nvm.c     ****     const size_t len = 38;
 1404              		.loc 1 452 5 is_stmt 1 view .LVU389
 1405              	.LVL131:
 453:Src/nvm.c     ****     uint8_t data[len];
 1406              		.loc 1 453 5 view .LVU390
 454:Src/nvm.c     ****     int progress = 0;
 1407              		.loc 1 454 5 view .LVU391
 455:Src/nvm.c     ****     uint8_t seed = 0;
 1408              		.loc 1 455 5 view .LVU392
 456:Src/nvm.c     **** 
 457:Src/nvm.c     ****     osDelay(100);
 1409              		.loc 1 457 5 view .LVU393
 1410 000a 6420     		movs	r0, #100
 1411 000c FFF7FEFF 		bl	osDelay
 1412              	.LVL132:
 458:Src/nvm.c     ****     printf("=== NVM TEST ===\r\n"); osDelay(5);
 1413              		.loc 1 458 5 view .LVU394
 1414 0010 4A48     		ldr	r0, .L113
 1415 0012 FFF7FEFF 		bl	puts
 1416              	.LVL133:
 1417              		.loc 1 458 37 view .LVU395
 1418 0016 0520     		movs	r0, #5
 1419 0018 FFF7FEFF 		bl	osDelay
 1420              	.LVL134:
ARM GAS  /tmp/ccbl8B2o.s 			page 36


 459:Src/nvm.c     ****     //NVM_erase();
 460:Src/nvm.c     ****     if (progress++, NVM_init() != 0)
 1421              		.loc 1 460 5 view .LVU396
 1422              		.loc 1 460 21 is_stmt 0 view .LVU397
 1423 001c FFF7FEFF 		bl	NVM_init
 1424              	.LVL135:
 1425              		.loc 1 460 8 view .LVU398
 1426 0020 0028     		cmp	r0, #0
 1427 0022 40F08180 		bne	.L108
 461:Src/nvm.c     ****         goto fail;
 462:Src/nvm.c     ****     
 463:Src/nvm.c     ****     // load bytes from NVM and print them
 464:Src/nvm.c     ****     size_t available = NVM_get_max_read_length();
 1428              		.loc 1 464 5 is_stmt 1 view .LVU399
 1429              	.LBB9:
 1430              	.LBI9:
 284:Src/nvm.c     ****     return n_valid_ << 3;
 1431              		.loc 1 284 8 view .LVU400
 1432              	.LBB10:
 285:Src/nvm.c     **** }
 1433              		.loc 1 285 5 view .LVU401
 285:Src/nvm.c     **** }
 1434              		.loc 1 285 21 is_stmt 0 view .LVU402
 1435 0026 464B     		ldr	r3, .L113+4
 1436 0028 1E68     		ldr	r6, [r3]
 1437              	.LVL136:
 285:Src/nvm.c     **** }
 1438              		.loc 1 285 21 view .LVU403
 1439              	.LBE10:
 1440              	.LBE9:
 465:Src/nvm.c     ****     if (available) {
 1441              		.loc 1 465 5 is_stmt 1 view .LVU404
 1442              		.loc 1 465 8 is_stmt 0 view .LVU405
 1443 002a F600     		lsls	r6, r6, #3
 1444              	.LVL137:
 1445              		.loc 1 465 8 view .LVU406
 1446 002c 3BD0     		beq	.L94
 1447              	.LBB11:
 1448              		.loc 1 465 20 discriminator 1 view .LVU407
 1449 002e C7F804D0 		str	sp, [r7, #4]
 466:Src/nvm.c     ****         printf("NVM contains %d valid bytes:\r\n", available); osDelay(5);
 1450              		.loc 1 466 9 is_stmt 1 discriminator 1 view .LVU408
 1451 0032 3146     		mov	r1, r6
 1452 0034 4348     		ldr	r0, .L113+8
 1453 0036 FFF7FEFF 		bl	printf
 1454              	.LVL138:
 1455              		.loc 1 466 64 discriminator 1 view .LVU409
 1456 003a 0520     		movs	r0, #5
 1457 003c FFF7FEFF 		bl	osDelay
 1458              	.LVL139:
 467:Src/nvm.c     ****         uint8_t buf[available];
 1459              		.loc 1 467 9 discriminator 1 view .LVU410
 1460              		.loc 1 467 17 is_stmt 0 discriminator 1 view .LVU411
 1461 0040 ADEB060D 		sub	sp, sp, r6
 1462 0044 E846     		mov	r8, sp
 1463              	.LVL140:
 468:Src/nvm.c     ****         if (progress++, NVM_read(0, buf, available) != 0)
ARM GAS  /tmp/ccbl8B2o.s 			page 37


 1464              		.loc 1 468 9 is_stmt 1 discriminator 1 view .LVU412
 1465              		.loc 1 468 25 is_stmt 0 discriminator 1 view .LVU413
 1466 0046 3246     		mov	r2, r6
 1467 0048 6946     		mov	r1, sp
 1468 004a 0020     		movs	r0, #0
 1469 004c FFF7FEFF 		bl	NVM_read
 1470              	.LVL141:
 1471              		.loc 1 468 12 discriminator 1 view .LVU414
 1472 0050 40B9     		cbnz	r0, .L111
 1473 0052 08F1FF38 		add	r8, r8, #-1
 1474              	.LVL142:
 1475              	.LBB12:
 469:Src/nvm.c     ****             goto fail;
 470:Src/nvm.c     ****         for (size_t pos = 0; pos < available; ++pos) {
 1476              		.loc 1 470 21 view .LVU415
 1477 0056 0025     		movs	r5, #0
 1478              	.LBE12:
 1479              	.LBE11:
 455:Src/nvm.c     **** 
 1480              		.loc 1 455 13 view .LVU416
 1481 0058 2C46     		mov	r4, r5
 1482              	.LBB15:
 1483              	.LBB13:
 471:Src/nvm.c     ****             seed += buf[pos];
 472:Src/nvm.c     ****             printf(" %02x", buf[pos]);
 1484              		.loc 1 472 13 view .LVU417
 1485 005a DFF800A1 		ldr	r10, .L113+32
 473:Src/nvm.c     ****             if ((((pos + 1) % 16) == 0) || ((pos + 1) == available))
 474:Src/nvm.c     ****                 printf("\r\n");
 475:Src/nvm.c     ****             osDelay(2);
 1486              		.loc 1 475 13 view .LVU418
 1487 005e 4FF0020B 		mov	fp, #2
 1488 0062 0BE0     		b	.L99
 1489              	.LVL143:
 1490              	.L111:
 1491              		.loc 1 475 13 view .LVU419
 1492              	.LBE13:
 469:Src/nvm.c     ****         for (size_t pos = 0; pos < available; ++pos) {
 1493              		.loc 1 469 13 is_stmt 1 view .LVU420
 1494 0064 D7F804D0 		ldr	sp, [r7, #4]
 468:Src/nvm.c     ****             goto fail;
 1495              		.loc 1 468 21 is_stmt 0 view .LVU421
 1496 0068 0221     		movs	r1, #2
 1497 006a 5EE0     		b	.L93
 1498              	.LVL144:
 1499              	.L96:
 1500              	.LBB14:
 474:Src/nvm.c     ****             osDelay(2);
 1501              		.loc 1 474 17 is_stmt 1 view .LVU422
 1502 006c 3648     		ldr	r0, .L113+12
 1503 006e FFF7FEFF 		bl	puts
 1504              	.LVL145:
 1505              		.loc 1 475 13 view .LVU423
 1506 0072 5846     		mov	r0, fp
 1507 0074 FFF7FEFF 		bl	osDelay
 1508              	.LVL146:
 470:Src/nvm.c     ****             seed += buf[pos];
ARM GAS  /tmp/ccbl8B2o.s 			page 38


 1509              		.loc 1 470 47 view .LVU424
 470:Src/nvm.c     ****             seed += buf[pos];
 1510              		.loc 1 470 30 view .LVU425
 470:Src/nvm.c     ****             seed += buf[pos];
 1511              		.loc 1 470 9 is_stmt 0 view .LVU426
 1512 0078 B542     		cmp	r5, r6
 1513 007a 10D0     		beq	.L112
 1514              	.LVL147:
 1515              	.L99:
 471:Src/nvm.c     ****             printf(" %02x", buf[pos]);
 1516              		.loc 1 471 13 is_stmt 1 view .LVU427
 471:Src/nvm.c     ****             printf(" %02x", buf[pos]);
 1517              		.loc 1 471 24 is_stmt 0 view .LVU428
 1518 007c 18F8011F 		ldrb	r1, [r8, #1]!	@ zero_extendqisi2
 471:Src/nvm.c     ****             printf(" %02x", buf[pos]);
 1519              		.loc 1 471 18 view .LVU429
 1520 0080 0C44     		add	r4, r4, r1
 1521              	.LVL148:
 471:Src/nvm.c     ****             printf(" %02x", buf[pos]);
 1522              		.loc 1 471 18 view .LVU430
 1523 0082 E4B2     		uxtb	r4, r4
 1524              	.LVL149:
 472:Src/nvm.c     ****             if ((((pos + 1) % 16) == 0) || ((pos + 1) == available))
 1525              		.loc 1 472 13 is_stmt 1 view .LVU431
 1526 0084 5046     		mov	r0, r10
 1527 0086 FFF7FEFF 		bl	printf
 1528              	.LVL150:
 473:Src/nvm.c     ****                 printf("\r\n");
 1529              		.loc 1 473 13 view .LVU432
 473:Src/nvm.c     ****                 printf("\r\n");
 1530              		.loc 1 473 24 is_stmt 0 view .LVU433
 1531 008a 0135     		adds	r5, r5, #1
 1532              	.LVL151:
 473:Src/nvm.c     ****                 printf("\r\n");
 1533              		.loc 1 473 16 view .LVU434
 1534 008c 15F00F0F 		tst	r5, #15
 1535 0090 ECD0     		beq	.L96
 473:Src/nvm.c     ****                 printf("\r\n");
 1536              		.loc 1 473 41 discriminator 1 view .LVU435
 1537 0092 B542     		cmp	r5, r6
 1538 0094 EAD0     		beq	.L96
 1539              		.loc 1 475 13 is_stmt 1 view .LVU436
 1540 0096 5846     		mov	r0, fp
 1541 0098 FFF7FEFF 		bl	osDelay
 1542              	.LVL152:
 470:Src/nvm.c     ****             seed += buf[pos];
 1543              		.loc 1 470 47 view .LVU437
 470:Src/nvm.c     ****             seed += buf[pos];
 1544              		.loc 1 470 30 view .LVU438
 470:Src/nvm.c     ****             seed += buf[pos];
 1545              		.loc 1 470 30 is_stmt 0 view .LVU439
 1546 009c EEE7     		b	.L99
 1547              	.L112:
 470:Src/nvm.c     ****             seed += buf[pos];
 1548              		.loc 1 470 30 view .LVU440
 1549 009e D7F804D0 		ldr	sp, [r7, #4]
 1550              	.LVL153:
ARM GAS  /tmp/ccbl8B2o.s 			page 39


 470:Src/nvm.c     ****             seed += buf[pos];
 1551              		.loc 1 470 30 view .LVU441
 1552              	.LBE14:
 468:Src/nvm.c     ****             goto fail;
 1553              		.loc 1 468 21 view .LVU442
 1554 00a2 0225     		movs	r5, #2
 1555              	.LVL154:
 468:Src/nvm.c     ****             goto fail;
 1556              		.loc 1 468 21 view .LVU443
 1557              	.LBE15:
 1558 00a4 07E0     		b	.L100
 1559              	.LVL155:
 1560              	.L94:
 476:Src/nvm.c     ****         }
 477:Src/nvm.c     ****     } else {
 478:Src/nvm.c     ****         printf("NVM is empty\r\n"); osDelay(5);
 1561              		.loc 1 478 9 is_stmt 1 view .LVU444
 1562 00a6 2948     		ldr	r0, .L113+16
 1563 00a8 FFF7FEFF 		bl	puts
 1564              	.LVL156:
 1565              		.loc 1 478 37 view .LVU445
 1566 00ac 0520     		movs	r0, #5
 1567 00ae FFF7FEFF 		bl	osDelay
 1568              	.LVL157:
 455:Src/nvm.c     **** 
 1569              		.loc 1 455 13 is_stmt 0 view .LVU446
 1570 00b2 0024     		movs	r4, #0
 460:Src/nvm.c     ****         goto fail;
 1571              		.loc 1 460 17 view .LVU447
 1572 00b4 0125     		movs	r5, #1
 1573              	.LVL158:
 1574              	.L100:
 479:Src/nvm.c     ****     }
 480:Src/nvm.c     **** 
 481:Src/nvm.c     ****     // store new bytes in NVM (data based on seed)
 482:Src/nvm.c     ****     printf("write 0x%02x, ..., 0x%02x to NVM\r\n", seed, seed + len - 1); osDelay(5);
 1575              		.loc 1 482 5 is_stmt 1 view .LVU448
 1576 00b6 04F12502 		add	r2, r4, #37
 1577 00ba 2146     		mov	r1, r4
 1578 00bc 2448     		ldr	r0, .L113+20
 1579 00be FFF7FEFF 		bl	printf
 1580              	.LVL159:
 1581              		.loc 1 482 75 view .LVU449
 1582 00c2 0520     		movs	r0, #5
 1583 00c4 FFF7FEFF 		bl	osDelay
 1584              	.LVL160:
 483:Src/nvm.c     ****     for (size_t i = 0; i < len; i++)
 1585              		.loc 1 483 5 view .LVU450
 1586              	.LBB16:
 1587              		.loc 1 483 10 view .LVU451
 1588              		.loc 1 483 24 view .LVU452
 1589 00c8 07F10802 		add	r2, r7, #8
 1590              	.LVL161:
 1591              		.loc 1 483 24 is_stmt 0 view .LVU453
 1592 00cc 07F12E00 		add	r0, r7, #46
 1593              	.LBE16:
 482:Src/nvm.c     ****     for (size_t i = 0; i < len; i++)
ARM GAS  /tmp/ccbl8B2o.s 			page 40


 1594              		.loc 1 482 75 view .LVU454
 1595 00d0 1346     		mov	r3, r2
 1596              	.LBB17:
 484:Src/nvm.c     ****         data[i] = seed++;
 1597              		.loc 1 484 17 view .LVU455
 1598 00d2 A41A     		subs	r4, r4, r2
 1599              	.LVL162:
 1600              	.L101:
 1601              		.loc 1 484 9 is_stmt 1 discriminator 3 view .LVU456
 1602              		.loc 1 484 17 is_stmt 0 discriminator 3 view .LVU457
 1603 00d4 E218     		adds	r2, r4, r3
 1604 00d6 03F8012B 		strb	r2, [r3], #1
 1605              	.LVL163:
 483:Src/nvm.c     ****     for (size_t i = 0; i < len; i++)
 1606              		.loc 1 483 33 is_stmt 1 discriminator 3 view .LVU458
 483:Src/nvm.c     ****     for (size_t i = 0; i < len; i++)
 1607              		.loc 1 483 24 discriminator 3 view .LVU459
 483:Src/nvm.c     ****     for (size_t i = 0; i < len; i++)
 1608              		.loc 1 483 5 is_stmt 0 discriminator 3 view .LVU460
 1609 00da 8342     		cmp	r3, r0
 1610 00dc FAD1     		bne	.L101
 1611              	.LBE17:
 485:Src/nvm.c     ****     if (progress++, NVM_start_write(len) != 0)
 1612              		.loc 1 485 5 is_stmt 1 view .LVU461
 1613              	.LVL164:
 1614              		.loc 1 485 21 is_stmt 0 view .LVU462
 1615 00de 2620     		movs	r0, #38
 1616 00e0 FFF7FEFF 		bl	NVM_start_write
 1617              	.LVL165:
 1618              		.loc 1 485 8 view .LVU463
 1619 00e4 08B1     		cbz	r0, .L102
 1620              		.loc 1 485 17 view .LVU464
 1621 00e6 691C     		adds	r1, r5, #1
 1622              	.LVL166:
 1623              		.loc 1 485 17 view .LVU465
 1624 00e8 1FE0     		b	.L93
 1625              	.LVL167:
 1626              	.L102:
 486:Src/nvm.c     ****         goto fail;
 487:Src/nvm.c     ****     if (progress++, NVM_write(0, data, len / 2))
 1627              		.loc 1 487 5 is_stmt 1 view .LVU466
 1628              		.loc 1 487 21 is_stmt 0 view .LVU467
 1629 00ea 1322     		movs	r2, #19
 1630 00ec 07F10801 		add	r1, r7, #8
 1631              	.LVL168:
 1632              		.loc 1 487 21 view .LVU468
 1633 00f0 0020     		movs	r0, #0
 1634 00f2 FFF7FEFF 		bl	NVM_write
 1635              	.LVL169:
 1636              		.loc 1 487 8 view .LVU469
 1637 00f6 08B1     		cbz	r0, .L103
 1638              		.loc 1 487 17 view .LVU470
 1639 00f8 A91C     		adds	r1, r5, #2
 1640              	.LVL170:
 1641              		.loc 1 487 17 view .LVU471
 1642 00fa 16E0     		b	.L93
 1643              	.LVL171:
ARM GAS  /tmp/ccbl8B2o.s 			page 41


 1644              	.L103:
 488:Src/nvm.c     ****         goto fail;
 489:Src/nvm.c     ****     if (progress++, NVM_write(len / 2, &data[len / 2], len - (len / 2)))
 1645              		.loc 1 489 5 is_stmt 1 view .LVU472
 1646              		.loc 1 489 21 is_stmt 0 view .LVU473
 1647 00fc 1322     		movs	r2, #19
 1648 00fe 07F11B01 		add	r1, r7, #27
 1649 0102 1046     		mov	r0, r2
 1650 0104 FFF7FEFF 		bl	NVM_write
 1651              	.LVL172:
 1652              		.loc 1 489 8 view .LVU474
 1653 0108 08B1     		cbz	r0, .L104
 1654              		.loc 1 489 17 view .LVU475
 1655 010a E91C     		adds	r1, r5, #3
 1656              	.LVL173:
 1657              		.loc 1 489 17 view .LVU476
 1658 010c 0DE0     		b	.L93
 1659              	.LVL174:
 1660              	.L104:
 490:Src/nvm.c     ****         goto fail;
 491:Src/nvm.c     ****     if (progress++, NVM_commit())
 1661              		.loc 1 491 5 is_stmt 1 view .LVU477
 1662              		.loc 1 491 21 is_stmt 0 view .LVU478
 1663 010e FFF7FEFF 		bl	NVM_commit
 1664              	.LVL175:
 1665              		.loc 1 491 8 view .LVU479
 1666 0112 08B1     		cbz	r0, .L105
 1667              		.loc 1 491 17 view .LVU480
 1668 0114 291D     		adds	r1, r5, #4
 1669              	.LVL176:
 1670              		.loc 1 491 17 view .LVU481
 1671 0116 08E0     		b	.L93
 1672              	.LVL177:
 1673              	.L105:
 492:Src/nvm.c     ****         goto fail;
 493:Src/nvm.c     ****     printf("new data committed to NVM\r\n"); osDelay(5);
 1674              		.loc 1 493 5 is_stmt 1 view .LVU482
 1675 0118 0E48     		ldr	r0, .L113+24
 1676 011a FFF7FEFF 		bl	puts
 1677              	.LVL178:
 1678              		.loc 1 493 46 view .LVU483
 1679 011e 0520     		movs	r0, #5
 1680 0120 FFF7FEFF 		bl	osDelay
 1681              	.LVL179:
 494:Src/nvm.c     **** 
 495:Src/nvm.c     ****     return;
 1682              		.loc 1 495 5 view .LVU484
 1683 0124 CD46     		mov	sp, r9
 1684 0126 04E0     		b	.L92
 1685              	.LVL180:
 1686              	.L108:
 460:Src/nvm.c     ****         goto fail;
 1687              		.loc 1 460 17 is_stmt 0 view .LVU485
 1688 0128 0121     		movs	r1, #1
 1689              	.LVL181:
 1690              	.L93:
 496:Src/nvm.c     **** 
ARM GAS  /tmp/ccbl8B2o.s 			page 42


 497:Src/nvm.c     **** fail:
 498:Src/nvm.c     ****     printf("NVM test failed at %d!\r\n", progress);
 1691              		.loc 1 498 5 is_stmt 1 view .LVU486
 1692 012a 0B48     		ldr	r0, .L113+28
 1693 012c FFF7FEFF 		bl	printf
 1694              	.LVL182:
 1695              		.loc 1 498 5 is_stmt 0 view .LVU487
 1696 0130 CD46     		mov	sp, r9
 1697              	.L92:
 499:Src/nvm.c     **** }
 1698              		.loc 1 499 1 view .LVU488
 1699 0132 3437     		adds	r7, r7, #52
 1700              	.LCFI17:
 1701              		.cfi_def_cfa_offset 36
 1702 0134 BD46     		mov	sp, r7
 1703              	.LCFI18:
 1704              		.cfi_def_cfa_register 13
 1705              		@ sp needed
 1706 0136 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1707              	.L114:
 1708 013a 00BF     		.align	2
 1709              	.L113:
 1710 013c 00000000 		.word	.LC0
 1711 0140 00000000 		.word	.LANCHOR2
 1712 0144 14000000 		.word	.LC1
 1713 0148 3C000000 		.word	.LC3
 1714 014c 40000000 		.word	.LC4
 1715 0150 50000000 		.word	.LC5
 1716 0154 74000000 		.word	.LC6
 1717 0158 90000000 		.word	.LC7
 1718 015c 34000000 		.word	.LC2
 1719              		.cfi_endproc
 1720              	.LFE148:
 1722              		.global	n_valid_
 1723              		.global	n_staging_area_
 1724              		.global	read_sector_
 1725              		.global	sectors
 1726              		.section	.bss.n_staging_area_,"aw",%nobits
 1727              		.align	2
 1728              		.set	.LANCHOR3,. + 0
 1731              	n_staging_area_:
 1732 0000 00000000 		.space	4
 1733              		.section	.bss.n_valid_,"aw",%nobits
 1734              		.align	2
 1735              		.set	.LANCHOR2,. + 0
 1738              	n_valid_:
 1739 0000 00000000 		.space	4
 1740              		.section	.bss.read_sector_,"aw",%nobits
 1741              		.set	.LANCHOR1,. + 0
 1744              	read_sector_:
 1745 0000 00       		.space	1
 1746              		.section	.data.sectors,"aw"
 1747              		.align	2
 1748              		.set	.LANCHOR0,. + 0
 1751              	sectors:
 1752 0000 00000000 		.space	4
 1753 0004 3E000000 		.word	62
ARM GAS  /tmp/ccbl8B2o.s 			page 43


 1754 0008 00010000 		.word	256
 1755 000c 08000000 		.word	8
 1756 0010 00F00108 		.word	134344704
 1757 0014 00F00108 		.word	134344704
 1758 0018 00000000 		.space	4
 1759 001c 3F000000 		.word	63
 1760 0020 00010000 		.word	256
 1761 0024 08000000 		.word	8
 1762 0028 00F80108 		.word	134346752
 1763 002c 00F80108 		.word	134346752
 1764              		.text
 1765              	.Letext0:
 1766              		.file 2 "/usr/share/gcc-arm-none-eabi-10-2020-q4-major/arm-none-eabi/include/machine/_default_type
 1767              		.file 3 "/usr/share/gcc-arm-none-eabi-10-2020-q4-major/arm-none-eabi/include/sys/_stdint.h"
 1768              		.file 4 "/usr/share/gcc-arm-none-eabi-10-2020-q4-major/lib/gcc/arm-none-eabi/10.2.1/include/stddef
 1769              		.file 5 "Drivers/CMSIS/Device/ST/STM32G4xx/Include/stm32g431xx.h"
 1770              		.file 6 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_flash.h"
 1771              		.file 7 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_def.h"
 1772              		.file 8 "<built-in>"
 1773              		.file 9 "Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS/cmsis_os.h"
 1774              		.file 10 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_flash_ex.h"
ARM GAS  /tmp/ccbl8B2o.s 			page 44


DEFINED SYMBOLS
                            *ABS*:0000000000000000 nvm.c
     /tmp/ccbl8B2o.s:18     .text.erase:0000000000000000 $t
     /tmp/ccbl8B2o.s:26     .text.erase:0000000000000000 erase
     /tmp/ccbl8B2o.s:112    .text.erase:000000000000004c $d
     /tmp/ccbl8B2o.s:117    .text.set_allocation_state:0000000000000000 $t
     /tmp/ccbl8B2o.s:124    .text.set_allocation_state:0000000000000000 set_allocation_state
     /tmp/ccbl8B2o.s:332    .text.set_allocation_state:00000000000000e8 $d
     /tmp/ccbl8B2o.s:337    .text.scan_allocation_table:0000000000000000 $t
     /tmp/ccbl8B2o.s:344    .text.scan_allocation_table:0000000000000000 scan_allocation_table
     /tmp/ccbl8B2o.s:510    .text.NVM_init:0000000000000000 $t
     /tmp/ccbl8B2o.s:517    .text.NVM_init:0000000000000000 NVM_init
     /tmp/ccbl8B2o.s:619    .text.NVM_init:0000000000000070 $d
     /tmp/ccbl8B2o.s:627    .text.NVM_erase:0000000000000000 $t
     /tmp/ccbl8B2o.s:634    .text.NVM_erase:0000000000000000 NVM_erase
     /tmp/ccbl8B2o.s:686    .text.NVM_erase:0000000000000028 $d
     /tmp/ccbl8B2o.s:692    .text.NVM_get_max_read_length:0000000000000000 $t
     /tmp/ccbl8B2o.s:699    .text.NVM_get_max_read_length:0000000000000000 NVM_get_max_read_length
     /tmp/ccbl8B2o.s:716    .text.NVM_get_max_read_length:0000000000000008 $d
     /tmp/ccbl8B2o.s:721    .text.NVM_get_max_write_length:0000000000000000 $t
     /tmp/ccbl8B2o.s:728    .text.NVM_get_max_write_length:0000000000000000 NVM_get_max_write_length
     /tmp/ccbl8B2o.s:758    .text.NVM_get_max_write_length:000000000000001c $d
     /tmp/ccbl8B2o.s:764    .text.NVM_read:0000000000000000 $t
     /tmp/ccbl8B2o.s:771    .text.NVM_read:0000000000000000 NVM_read
     /tmp/ccbl8B2o.s:842    .text.NVM_read:0000000000000044 $d
     /tmp/ccbl8B2o.s:849    .text.NVM_start_write:0000000000000000 $t
     /tmp/ccbl8B2o.s:856    .text.NVM_start_write:0000000000000000 NVM_start_write
     /tmp/ccbl8B2o.s:949    .text.NVM_start_write:0000000000000060 $d
     /tmp/ccbl8B2o.s:956    .text.NVM_write:0000000000000000 $t
     /tmp/ccbl8B2o.s:963    .text.NVM_write:0000000000000000 NVM_write
     /tmp/ccbl8B2o.s:1219   .text.NVM_write:0000000000000138 $d
     /tmp/ccbl8B2o.s:1227   .text.NVM_commit:0000000000000000 $t
     /tmp/ccbl8B2o.s:1234   .text.NVM_commit:0000000000000000 NVM_commit
     /tmp/ccbl8B2o.s:1338   .text.NVM_commit:0000000000000080 $d
     /tmp/ccbl8B2o.s:1346   .rodata.NVM_demo.str1.4:0000000000000000 $d
     /tmp/ccbl8B2o.s:1371   .text.NVM_demo:0000000000000000 $t
     /tmp/ccbl8B2o.s:1378   .text.NVM_demo:0000000000000000 NVM_demo
     /tmp/ccbl8B2o.s:1710   .text.NVM_demo:000000000000013c $d
     /tmp/ccbl8B2o.s:1738   .bss.n_valid_:0000000000000000 n_valid_
     /tmp/ccbl8B2o.s:1731   .bss.n_staging_area_:0000000000000000 n_staging_area_
     /tmp/ccbl8B2o.s:1744   .bss.read_sector_:0000000000000000 read_sector_
     /tmp/ccbl8B2o.s:1751   .data.sectors:0000000000000000 sectors
     /tmp/ccbl8B2o.s:1727   .bss.n_staging_area_:0000000000000000 $d
     /tmp/ccbl8B2o.s:1734   .bss.n_valid_:0000000000000000 $d
     /tmp/ccbl8B2o.s:1745   .bss.read_sector_:0000000000000000 $d
     /tmp/ccbl8B2o.s:1747   .data.sectors:0000000000000000 $d

UNDEFINED SYMBOLS
HAL_FLASH_Unlock
HAL_FLASHEx_Erase
HAL_FLASH_Lock
HAL_FLASH_GetError
HAL_FLASH_Program
memcpy
osDelay
puts
printf
ARM GAS  /tmp/ccbl8B2o.s 			page 45


