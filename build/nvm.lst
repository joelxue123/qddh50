ARM GAS  /tmp/ccYYtTab.s 			page 1


   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 2
  13              		.file	"nvm.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.global	sectors
  18              		.section	.data.sectors,"aw"
  19              		.align	2
  22              	sectors:
  23 0000 00000000 		.space	4
  24 0004 3E000000 		.word	62
  25 0008 00010000 		.word	256
  26 000c 08000000 		.word	8
  27 0010 00F00108 		.word	134344704
  28 0014 00F00108 		.word	134344704
  29 0018 00000000 		.space	4
  30 001c 3F000000 		.word	63
  31 0020 00010000 		.word	256
  32 0024 08000000 		.word	8
  33 0028 00F80108 		.word	134346752
  34 002c 00F80108 		.word	134346752
  35              		.global	read_sector_
  36              		.section	.bss.read_sector_,"aw",%nobits
  39              	read_sector_:
  40 0000 00       		.space	1
  41              		.global	n_staging_area_
  42              		.section	.bss.n_staging_area_,"aw",%nobits
  43              		.align	2
  46              	n_staging_area_:
  47 0000 00000000 		.space	4
  48              		.global	n_valid_
  49              		.section	.bss.n_valid_,"aw",%nobits
  50              		.align	2
  53              	n_valid_:
  54 0000 00000000 		.space	4
  55              		.section	.text.erase,"ax",%progbits
  56              		.align	1
  57              		.global	erase
  58              		.arch armv7e-m
  59              		.syntax unified
  60              		.thumb
  61              		.thumb_func
  62              		.fpu fpv4-sp-d16
  64              	erase:
  65              	.LFB132:
  66              		.file 1 "Src/nvm.c"
ARM GAS  /tmp/ccYYtTab.s 			page 2


   1:Src/nvm.c     **** /*
   2:Src/nvm.c     **** * Flash-based Non-Volatile Memory (NVM)
   3:Src/nvm.c     **** * 
   4:Src/nvm.c     **** * This file supports storing and loading persistent configuration based on
   5:Src/nvm.c     **** * the STM32 builtin flash memory.
   6:Src/nvm.c     **** *
   7:Src/nvm.c     **** * The STM32F405xx has 12 flash sectors of heterogeneous size. We use the last
   8:Src/nvm.c     **** * two sectors for configuration data. These pages have a size of 128kB each.
   9:Src/nvm.c     **** * Setting any bit in these sectors to 0 is always possible, but setting them
  10:Src/nvm.c     **** * to 1 requires erasing the whole sector.
  11:Src/nvm.c     **** *
  12:Src/nvm.c     **** * We consider each sector as an array of 64-bit fields except the first N bytes, which we
  13:Src/nvm.c     **** * instead use as an allocation block. The allocation block is a compact bit-field (2 bit per entry)
  14:Src/nvm.c     **** * that keeps track of the state of each field (erased, invalid, valid).
  15:Src/nvm.c     **** *
  16:Src/nvm.c     **** * One sector is always considered the valid (read) sector and the other one is the
  17:Src/nvm.c     **** * target for the next write access: they can be considered to be ping-pong or double buffred.
  18:Src/nvm.c     **** *
  19:Src/nvm.c     **** * When writing a block of data, instead of always erasing the whole writable sector the
  20:Src/nvm.c     **** * new data is appended in the erased area. This presumably increases flash life span.
  21:Src/nvm.c     **** * The writable sector is only erased if there is not enough space for the new data.
  22:Src/nvm.c     **** *
  23:Src/nvm.c     **** * On startup, if there is exactly one sector
  24:Src/nvm.c     **** * whose last non-erased value has the state "valid" that sector is considered
  25:Src/nvm.c     **** * the valid sector. In any other case the selection is undefined.
  26:Src/nvm.c     **** *
  27:Src/nvm.c     **** *
  28:Src/nvm.c     **** * To write a new block of data atomically we first mark all associated fields
  29:Src/nvm.c     **** * as "invalid" (in the allocation table) then write the data and then mark the
  30:Src/nvm.c     **** * fields as "valid" (in the direction of increasing address).
  31:Src/nvm.c     **** */
  32:Src/nvm.c     **** 
  33:Src/nvm.c     **** #include "nvm.h"
  34:Src/nvm.c     **** 
  35:Src/nvm.c     **** #include "stm32g4xx_hal.h"
  36:Src/nvm.c     **** 
  37:Src/nvm.c     **** #include <string.h>
  38:Src/nvm.c     **** #if defined(STM32G431xx)
  39:Src/nvm.c     **** // STM32G431 has 128KB flash organized as 64 pages of 2KB each
  40:Src/nvm.c     **** // Using last two pages (63 and 62) for configuration
  41:Src/nvm.c     **** // Refer to RM0440 Rev 7 Section 3.3.1
  42:Src/nvm.c     **** 
  43:Src/nvm.c     **** #define FLASH_PAGE_SIZE          0x800U    // 2KB per page
  44:Src/nvm.c     **** #define FLASH_PAGE_62           62U        // Second to last page
  45:Src/nvm.c     **** #define FLASH_PAGE_63           63U        // Last page
  46:Src/nvm.c     **** #define FLASH_BASE_ADDR         0x08000000U
  47:Src/nvm.c     **** 
  48:Src/nvm.c     **** #define FLASH_SECTOR_10_BASE    (const volatile uint8_t*)(FLASH_BASE_ADDR + (FLASH_PAGE_62 * FLASH_
  49:Src/nvm.c     **** #define FLASH_SECTOR_10_SIZE    FLASH_PAGE_SIZE
  50:Src/nvm.c     **** #define FLASH_SECTOR_11_BASE    (const volatile uint8_t*)(FLASH_BASE_ADDR + (FLASH_PAGE_63 * FLASH_
  51:Src/nvm.c     **** #define FLASH_SECTOR_11_SIZE    FLASH_PAGE_SIZE
  52:Src/nvm.c     **** 
  53:Src/nvm.c     **** // Update error flags for STM32G4
  54:Src/nvm.c     **** #define HAL_FLASH_ClearError() __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS)
  55:Src/nvm.c     **** 
  56:Src/nvm.c     **** #else
  57:Src/nvm.c     **** #error "Unsupported STM32 device"
ARM GAS  /tmp/ccYYtTab.s 			page 3


  58:Src/nvm.c     **** #endif
  59:Src/nvm.c     **** 
  60:Src/nvm.c     **** 
  61:Src/nvm.c     **** typedef enum {
  62:Src/nvm.c     ****     VALID = 0,
  63:Src/nvm.c     ****     INVALID = 1,
  64:Src/nvm.c     ****     ERASED = 3
  65:Src/nvm.c     **** } field_state_t;
  66:Src/nvm.c     **** 
  67:Src/nvm.c     **** typedef struct {
  68:Src/nvm.c     ****     size_t index;               //!< next field to be written to (can be equal to n_data)
  69:Src/nvm.c     ****     const uint32_t sector_id;   //!< HAL ID of this sector
  70:Src/nvm.c     ****     const size_t n_data;        //!< number of 64-bit fields in this sector
  71:Src/nvm.c     ****     const size_t n_reserved;    //!< number of 64-bit fields in this sector that are reserved for t
  72:Src/nvm.c     ****     const volatile uint8_t* const alloc_table;
  73:Src/nvm.c     ****     const volatile uint64_t* const data;
  74:Src/nvm.c     **** } sector_t;
  75:Src/nvm.c     **** 
  76:Src/nvm.c     **** sector_t sectors[] = { {
  77:Src/nvm.c     ****     .sector_id = FLASH_PAGE_62,
  78:Src/nvm.c     ****     .n_data = FLASH_SECTOR_10_SIZE >> 3,
  79:Src/nvm.c     ****     .n_reserved = (FLASH_SECTOR_10_SIZE >> 3) >> 5,
  80:Src/nvm.c     ****     .alloc_table = FLASH_SECTOR_10_BASE,
  81:Src/nvm.c     ****     .data = (uint64_t *)FLASH_SECTOR_10_BASE
  82:Src/nvm.c     **** }, {
  83:Src/nvm.c     ****     .sector_id = FLASH_PAGE_63,
  84:Src/nvm.c     ****     .n_data = FLASH_SECTOR_11_SIZE >> 3,
  85:Src/nvm.c     ****     .n_reserved = (FLASH_SECTOR_11_SIZE >> 3) >> 5,
  86:Src/nvm.c     ****     .alloc_table = FLASH_SECTOR_11_BASE,
  87:Src/nvm.c     ****     .data = (uint64_t *)FLASH_SECTOR_11_BASE
  88:Src/nvm.c     **** }};
  89:Src/nvm.c     **** 
  90:Src/nvm.c     **** uint8_t read_sector_; // 0 or 1 to indicate which sector to read from and which to write to
  91:Src/nvm.c     **** size_t n_staging_area_; // number of 64-bit values that were reserved using NVM_start_write
  92:Src/nvm.c     **** size_t n_valid_; // number of 64-bit fields that can be read
  93:Src/nvm.c     **** 
  94:Src/nvm.c     **** // @brief Erases a flash sector. This sets all bits in the sector to 1.
  95:Src/nvm.c     **** // The sector's current index is reset to the minimum value (n_reserved).
  96:Src/nvm.c     **** // @returns 0 on success or a non-zero error code otherwise
  97:Src/nvm.c     **** // Update erase function for STM32G4
  98:Src/nvm.c     **** int erase(sector_t *sector) {
  67              		.loc 1 98 29
  68              		.cfi_startproc
  69              		@ args = 0, pretend = 0, frame = 32
  70              		@ frame_needed = 1, uses_anonymous_args = 0
  71 0000 80B5     		push	{r7, lr}
  72              	.LCFI0:
  73              		.cfi_def_cfa_offset 8
  74              		.cfi_offset 7, -8
  75              		.cfi_offset 14, -4
  76 0002 88B0     		sub	sp, sp, #32
  77              	.LCFI1:
  78              		.cfi_def_cfa_offset 40
  79 0004 00AF     		add	r7, sp, #0
  80              	.LCFI2:
  81              		.cfi_def_cfa_register 7
  82 0006 7860     		str	r0, [r7, #4]
ARM GAS  /tmp/ccYYtTab.s 			page 4


  99:Src/nvm.c     ****     FLASH_EraseInitTypeDef erase_struct = {
  83              		.loc 1 99 28
  84 0008 0023     		movs	r3, #0
  85 000a 3B61     		str	r3, [r7, #16]
  86 000c 0123     		movs	r3, #1
  87 000e 7B61     		str	r3, [r7, #20]
 100:Src/nvm.c     ****         .TypeErase = FLASH_TYPEERASE_PAGES,    // Changed from SECTORS to PAGES
 101:Src/nvm.c     ****         .Page = sector->sector_id,             // Using page number instead of sector
  88              		.loc 1 101 23
  89 0010 7B68     		ldr	r3, [r7, #4]
  90 0012 5B68     		ldr	r3, [r3, #4]
  99:Src/nvm.c     ****     FLASH_EraseInitTypeDef erase_struct = {
  91              		.loc 1 99 28
  92 0014 BB61     		str	r3, [r7, #24]
  93 0016 0123     		movs	r3, #1
  94 0018 FB61     		str	r3, [r7, #28]
 102:Src/nvm.c     ****         .NbPages = 1,                          // Erase one page
 103:Src/nvm.c     ****         .Banks = FLASH_BANK_1                  // Always Bank 1 for G431
 104:Src/nvm.c     ****     };
 105:Src/nvm.c     ****     
 106:Src/nvm.c     ****     HAL_FLASH_Unlock();
  95              		.loc 1 106 5
  96 001a FFF7FEFF 		bl	HAL_FLASH_Unlock
 107:Src/nvm.c     ****     HAL_FLASH_ClearError();
  97              		.loc 1 107 5
  98 001e 134B     		ldr	r3, .L8
  99 0020 9B69     		ldr	r3, [r3, #24]
 100 0022 124A     		ldr	r2, .L8
 101 0024 43F04043 		orr	r3, r3, #-1073741824
 102 0028 9361     		str	r3, [r2, #24]
 103 002a 104B     		ldr	r3, .L8
 104 002c 4CF2FA32 		movw	r2, #50170
 105 0030 1A61     		str	r2, [r3, #16]
 108:Src/nvm.c     ****     uint32_t page_error;
 109:Src/nvm.c     ****     if (HAL_FLASHEx_Erase(&erase_struct, &page_error) != HAL_OK)
 106              		.loc 1 109 9
 107 0032 07F10C02 		add	r2, r7, #12
 108 0036 07F11003 		add	r3, r7, #16
 109 003a 1146     		mov	r1, r2
 110 003c 1846     		mov	r0, r3
 111 003e FFF7FEFF 		bl	HAL_FLASHEx_Erase
 112 0042 0346     		mov	r3, r0
 113              		.loc 1 109 8
 114 0044 002B     		cmp	r3, #0
 115 0046 07D1     		bne	.L7
 110:Src/nvm.c     ****         goto fail;
 111:Src/nvm.c     ****     sector->index = sector->n_reserved;
 116              		.loc 1 111 27
 117 0048 7B68     		ldr	r3, [r7, #4]
 118 004a DA68     		ldr	r2, [r3, #12]
 119              		.loc 1 111 19
 120 004c 7B68     		ldr	r3, [r7, #4]
 121 004e 1A60     		str	r2, [r3]
 112:Src/nvm.c     **** 
 113:Src/nvm.c     ****     HAL_FLASH_Lock();
 122              		.loc 1 113 5
 123 0050 FFF7FEFF 		bl	HAL_FLASH_Lock
ARM GAS  /tmp/ccYYtTab.s 			page 5


 114:Src/nvm.c     ****     return 0;
 124              		.loc 1 114 12
 125 0054 0023     		movs	r3, #0
 126 0056 05E0     		b	.L5
 127              	.L7:
 110:Src/nvm.c     ****         goto fail;
 128              		.loc 1 110 9
 129 0058 00BF     		nop
 130              	.L3:
 115:Src/nvm.c     **** fail:
 116:Src/nvm.c     ****     HAL_FLASH_Lock();
 131              		.loc 1 116 5
 132 005a FFF7FEFF 		bl	HAL_FLASH_Lock
 117:Src/nvm.c     ****     return HAL_FLASH_GetError();
 133              		.loc 1 117 12
 134 005e FFF7FEFF 		bl	HAL_FLASH_GetError
 135 0062 0346     		mov	r3, r0
 136              	.L5:
 118:Src/nvm.c     **** }
 137              		.loc 1 118 1 discriminator 1
 138 0064 1846     		mov	r0, r3
 139 0066 2037     		adds	r7, r7, #32
 140              	.LCFI3:
 141              		.cfi_def_cfa_offset 8
 142 0068 BD46     		mov	sp, r7
 143              	.LCFI4:
 144              		.cfi_def_cfa_register 13
 145              		@ sp needed
 146 006a 80BD     		pop	{r7, pc}
 147              	.L9:
 148              		.align	2
 149              	.L8:
 150 006c 00200240 		.word	1073881088
 151              		.cfi_endproc
 152              	.LFE132:
 154              		.section	.text.set_allocation_state,"ax",%progbits
 155              		.align	1
 156              		.global	set_allocation_state
 157              		.syntax unified
 158              		.thumb
 159              		.thumb_func
 160              		.fpu fpv4-sp-d16
 162              	set_allocation_state:
 163              	.LFB133:
 119:Src/nvm.c     **** 
 120:Src/nvm.c     **** // @brief Writes states into the allocation table.
 121:Src/nvm.c     **** // The write operation goes in the direction of increasing indices.
 122:Src/nvm.c     **** // @param state: 11: erased, 10: writing, 00: valid data
 123:Src/nvm.c     **** // @returns 0 on success or a non-zero error code otherwise
 124:Src/nvm.c     **** int set_allocation_state(sector_t *sector, size_t index, size_t count, field_state_t state) {
 164              		.loc 1 124 93
 165              		.cfi_startproc
 166              		@ args = 0, pretend = 0, frame = 264
 167              		@ frame_needed = 1, uses_anonymous_args = 0
 168 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 169              	.LCFI5:
 170              		.cfi_def_cfa_offset 36
ARM GAS  /tmp/ccYYtTab.s 			page 6


 171              		.cfi_offset 4, -36
 172              		.cfi_offset 5, -32
 173              		.cfi_offset 6, -28
 174              		.cfi_offset 7, -24
 175              		.cfi_offset 8, -20
 176              		.cfi_offset 9, -16
 177              		.cfi_offset 10, -12
 178              		.cfi_offset 11, -8
 179              		.cfi_offset 14, -4
 180 0004 C3B0     		sub	sp, sp, #268
 181              	.LCFI6:
 182              		.cfi_def_cfa_offset 304
 183 0006 00AF     		add	r7, sp, #0
 184              	.LCFI7:
 185              		.cfi_def_cfa_register 7
 186 0008 C7F8F400 		str	r0, [r7, #244]
 187 000c C7F8F010 		str	r1, [r7, #240]
 188 0010 C7F8EC20 		str	r2, [r7, #236]
 189 0014 87F8EB30 		strb	r3, [r7, #235]
 125:Src/nvm.c     ****     if (index < sector->n_reserved)
 190              		.loc 1 125 23
 191 0018 D7F8F430 		ldr	r3, [r7, #244]
 192 001c DA68     		ldr	r2, [r3, #12]
 193              		.loc 1 125 8
 194 001e D7F8F030 		ldr	r3, [r7, #240]
 195 0022 9342     		cmp	r3, r2
 196 0024 02D2     		bcs	.L11
 126:Src/nvm.c     ****         return -1;
 197              		.loc 1 126 16
 198 0026 4FF0FF33 		mov	r3, #-1
 199 002a 52E2     		b	.L12
 200              	.L11:
 127:Src/nvm.c     ****     if (index + count >= sector->n_data)
 201              		.loc 1 127 15
 202 002c D7F8F020 		ldr	r2, [r7, #240]
 203 0030 D7F8EC30 		ldr	r3, [r7, #236]
 204 0034 1A44     		add	r2, r2, r3
 205              		.loc 1 127 32
 206 0036 D7F8F430 		ldr	r3, [r7, #244]
 207 003a 9B68     		ldr	r3, [r3, #8]
 208              		.loc 1 127 8
 209 003c 9A42     		cmp	r2, r3
 210 003e 02D3     		bcc	.L13
 128:Src/nvm.c     ****         return -1;
 211              		.loc 1 128 16
 212 0040 4FF0FF33 		mov	r3, #-1
 213 0044 45E2     		b	.L12
 214              	.L13:
 129:Src/nvm.c     **** 
 130:Src/nvm.c     ****     // expand state to state for 4 values
 131:Src/nvm.c     ****     const uint8_t states = (state << 0) | (state << 2) | (state << 4) | (state << 6);
 215              		.loc 1 131 50
 216 0046 97F8EB30 		ldrb	r3, [r7, #235]	@ zero_extendqisi2
 217 004a 9B00     		lsls	r3, r3, #2
 218              		.loc 1 131 41
 219 004c 5AB2     		sxtb	r2, r3
 220 004e 97F9EB30 		ldrsb	r3, [r7, #235]
ARM GAS  /tmp/ccYYtTab.s 			page 7


 221 0052 1343     		orrs	r3, r3, r2
 222 0054 5AB2     		sxtb	r2, r3
 223              		.loc 1 131 65
 224 0056 97F8EB30 		ldrb	r3, [r7, #235]	@ zero_extendqisi2
 225 005a 1B01     		lsls	r3, r3, #4
 226              		.loc 1 131 56
 227 005c 5BB2     		sxtb	r3, r3
 228 005e 1343     		orrs	r3, r3, r2
 229 0060 5AB2     		sxtb	r2, r3
 230              		.loc 1 131 80
 231 0062 97F8EB30 		ldrb	r3, [r7, #235]	@ zero_extendqisi2
 232 0066 9B01     		lsls	r3, r3, #6
 233              		.loc 1 131 71
 234 0068 5BB2     		sxtb	r3, r3
 235 006a 1343     		orrs	r3, r3, r2
 236 006c 5BB2     		sxtb	r3, r3
 237              		.loc 1 131 19
 238 006e 87F80631 		strb	r3, [r7, #262]
 132:Src/nvm.c     ****     
 133:Src/nvm.c     ****     // handle unaligned start
 134:Src/nvm.c     ****     uint8_t mask = ~(0xff << ((index & 0x3) << 1));
 239              		.loc 1 134 45
 240 0072 D7F8F030 		ldr	r3, [r7, #240]
 241 0076 5B00     		lsls	r3, r3, #1
 242 0078 03F00602 		and	r2, r3, #6
 243              		.loc 1 134 27
 244 007c FF23     		movs	r3, #255
 245 007e 9340     		lsls	r3, r3, r2
 246              		.loc 1 134 13
 247 0080 DBB2     		uxtb	r3, r3
 248 0082 DB43     		mvns	r3, r3
 249 0084 87F80731 		strb	r3, [r7, #263]
 135:Src/nvm.c     ****     count += index & 0x3;
 250              		.loc 1 135 20
 251 0088 D7F8F030 		ldr	r3, [r7, #240]
 252 008c 03F00302 		and	r2, r3, #3
 253              		.loc 1 135 11
 254 0090 D7F8EC30 		ldr	r3, [r7, #236]
 255 0094 1344     		add	r3, r3, r2
 256 0096 C7F8EC30 		str	r3, [r7, #236]
 136:Src/nvm.c     ****     index -= index & 0x3;
 257              		.loc 1 136 11
 258 009a D7F8F030 		ldr	r3, [r7, #240]
 259 009e 23F00303 		bic	r3, r3, #3
 260 00a2 C7F8F030 		str	r3, [r7, #240]
 137:Src/nvm.c     **** 
 138:Src/nvm.c     ****     HAL_FLASH_Unlock();
 261              		.loc 1 138 5
 262 00a6 FFF7FEFF 		bl	HAL_FLASH_Unlock
 139:Src/nvm.c     ****     HAL_FLASH_ClearError();
 263              		.loc 1 139 5
 264 00aa 054B     		ldr	r3, .L21
 265 00ac 9B69     		ldr	r3, [r3, #24]
 266 00ae 044A     		ldr	r2, .L21
 267 00b0 43F04043 		orr	r3, r3, #-1073741824
 268 00b4 9361     		str	r3, [r2, #24]
 269 00b6 024A     		ldr	r2, .L21
ARM GAS  /tmp/ccYYtTab.s 			page 8


 270 00b8 4CF2FA33 		movw	r3, #50170
 271 00bc 1361     		str	r3, [r2, #16]
 140:Src/nvm.c     **** 
 141:Src/nvm.c     ****     uint64_t dword_data;
 142:Src/nvm.c     ****     
 143:Src/nvm.c     ****     // write states
 144:Src/nvm.c     ****     for (; count >= 4; count -= 4, index += 4) {
 272              		.loc 1 144 5
 273 00be 00E1     		b	.L14
 274              	.L22:
 275              		.align	2
 276              	.L21:
 277 00c0 00200240 		.word	1073881088
 278              	.L17:
 145:Src/nvm.c     ****         dword_data = ((uint64_t)(states | mask) << 56) | 
 279              		.loc 1 145 23
 280 00c4 97F80621 		ldrb	r2, [r7, #262]
 281 00c8 97F80731 		ldrb	r3, [r7, #263]
 282 00cc 1343     		orrs	r3, r3, r2
 283 00ce DBB2     		uxtb	r3, r3
 284 00d0 DBB2     		uxtb	r3, r3
 285 00d2 0022     		movs	r2, #0
 286 00d4 C7F8B830 		str	r3, [r7, #184]
 287 00d8 C7F8BC20 		str	r2, [r7, #188]
 288              		.loc 1 145 49
 289 00dc 4FF00000 		mov	r0, #0
 290 00e0 4FF00001 		mov	r1, #0
 291 00e4 D7F8B830 		ldr	r3, [r7, #184]
 292 00e8 1906     		lsls	r1, r3, #24
 293 00ea 0020     		movs	r0, #0
 146:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 48) |
 294              		.loc 1 146 22
 295 00ec 97F80621 		ldrb	r2, [r7, #262]
 296 00f0 97F80731 		ldrb	r3, [r7, #263]
 297 00f4 1343     		orrs	r3, r3, r2
 298 00f6 DBB2     		uxtb	r3, r3
 299 00f8 DBB2     		uxtb	r3, r3
 300 00fa 0022     		movs	r2, #0
 301 00fc C7F8B030 		str	r3, [r7, #176]
 302 0100 C7F8B420 		str	r2, [r7, #180]
 303              		.loc 1 146 48
 304 0104 4FF00002 		mov	r2, #0
 305 0108 4FF00003 		mov	r3, #0
 306 010c D7F8B060 		ldr	r6, [r7, #176]
 307 0110 3304     		lsls	r3, r6, #16
 308 0112 0022     		movs	r2, #0
 145:Src/nvm.c     ****         dword_data = ((uint64_t)(states | mask) << 56) | 
 309              		.loc 1 145 56
 310 0114 40EA0206 		orr	r6, r0, r2
 311 0118 C7F8D060 		str	r6, [r7, #208]
 312 011c 0B43     		orrs	r3, r3, r1
 313 011e C7F8D430 		str	r3, [r7, #212]
 147:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 40) |
 314              		.loc 1 147 22
 315 0122 97F80621 		ldrb	r2, [r7, #262]
 316 0126 97F80731 		ldrb	r3, [r7, #263]
 317 012a 1343     		orrs	r3, r3, r2
ARM GAS  /tmp/ccYYtTab.s 			page 9


 318 012c DBB2     		uxtb	r3, r3
 319 012e DBB2     		uxtb	r3, r3
 320 0130 0022     		movs	r2, #0
 321 0132 C7F8A830 		str	r3, [r7, #168]
 322 0136 C7F8AC20 		str	r2, [r7, #172]
 323              		.loc 1 147 48
 324 013a 4FF00002 		mov	r2, #0
 325 013e 4FF00003 		mov	r3, #0
 326 0142 D7F8A810 		ldr	r1, [r7, #168]
 327 0146 0B02     		lsls	r3, r1, #8
 328 0148 0022     		movs	r2, #0
 146:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 48) |
 329              		.loc 1 146 55
 330 014a D7F8D010 		ldr	r1, [r7, #208]
 331 014e 1143     		orrs	r1, r1, r2
 332 0150 C7F8C810 		str	r1, [r7, #200]
 333 0154 D7F8D410 		ldr	r1, [r7, #212]
 334 0158 0B43     		orrs	r3, r3, r1
 335 015a C7F8CC30 		str	r3, [r7, #204]
 148:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 32) |
 336              		.loc 1 148 22
 337 015e 97F80621 		ldrb	r2, [r7, #262]
 338 0162 97F80731 		ldrb	r3, [r7, #263]
 339 0166 1343     		orrs	r3, r3, r2
 340 0168 DBB2     		uxtb	r3, r3
 341 016a DBB2     		uxtb	r3, r3
 342 016c 0022     		movs	r2, #0
 343 016e C7F8A030 		str	r3, [r7, #160]
 344 0172 C7F8A420 		str	r2, [r7, #164]
 345              		.loc 1 148 48
 346 0176 4FF00002 		mov	r2, #0
 347 017a 4FF00003 		mov	r3, #0
 348 017e D7F8A010 		ldr	r1, [r7, #160]
 349 0182 0B00     		movs	r3, r1
 350 0184 0022     		movs	r2, #0
 147:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 40) |
 351              		.loc 1 147 55
 352 0186 D7F8C810 		ldr	r1, [r7, #200]
 353 018a 1143     		orrs	r1, r1, r2
 354 018c C7F8C010 		str	r1, [r7, #192]
 355 0190 D7F8CC10 		ldr	r1, [r7, #204]
 356 0194 0B43     		orrs	r3, r3, r1
 357 0196 C7F8C430 		str	r3, [r7, #196]
 149:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 24) |
 358              		.loc 1 149 22
 359 019a 97F80621 		ldrb	r2, [r7, #262]
 360 019e 97F80731 		ldrb	r3, [r7, #263]
 361 01a2 1343     		orrs	r3, r3, r2
 362 01a4 DBB2     		uxtb	r3, r3
 363 01a6 DBB2     		uxtb	r3, r3
 364 01a8 0022     		movs	r2, #0
 365 01aa C7F89830 		str	r3, [r7, #152]
 366 01ae C7F89C20 		str	r2, [r7, #156]
 367              		.loc 1 149 48
 368 01b2 D7E92612 		ldrd	r1, [r7, #152]
 369 01b6 0B46     		mov	r3, r1
 370 01b8 1B0A     		lsrs	r3, r3, #8
ARM GAS  /tmp/ccYYtTab.s 			page 10


 371 01ba C7F89430 		str	r3, [r7, #148]
 372 01be 0B46     		mov	r3, r1
 373 01c0 1B06     		lsls	r3, r3, #24
 374 01c2 C7F89030 		str	r3, [r7, #144]
 148:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 32) |
 375              		.loc 1 148 55
 376 01c6 D7F8C030 		ldr	r3, [r7, #192]
 377 01ca D7E92401 		ldrd	r0, [r7, #144]
 378 01ce 0246     		mov	r2, r0
 379 01d0 43EA020A 		orr	r10, r3, r2
 380 01d4 D7F8C430 		ldr	r3, [r7, #196]
 381 01d8 0A46     		mov	r2, r1
 382 01da 43EA020B 		orr	fp, r3, r2
 150:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 16) |
 383              		.loc 1 150 22
 384 01de 97F80621 		ldrb	r2, [r7, #262]
 385 01e2 97F80731 		ldrb	r3, [r7, #263]
 386 01e6 1343     		orrs	r3, r3, r2
 387 01e8 DBB2     		uxtb	r3, r3
 388 01ea DBB2     		uxtb	r3, r3
 389 01ec 0022     		movs	r2, #0
 390 01ee C7F8E030 		str	r3, [r7, #224]
 391 01f2 C7F8E420 		str	r2, [r7, #228]
 392              		.loc 1 150 48
 393 01f6 4FF00002 		mov	r2, #0
 394 01fa 4FF00003 		mov	r3, #0
 395 01fe D7F8E410 		ldr	r1, [r7, #228]
 396 0202 0B04     		lsls	r3, r1, #16
 397 0204 D7F8E010 		ldr	r1, [r7, #224]
 398 0208 43EA1143 		orr	r3, r3, r1, lsr #16
 399 020c D7F8E010 		ldr	r1, [r7, #224]
 400 0210 0A04     		lsls	r2, r1, #16
 149:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 24) |
 401              		.loc 1 149 55
 402 0212 4AEA0208 		orr	r8, r10, r2
 403 0216 4BEA0309 		orr	r9, fp, r3
 151:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 8) |
 404              		.loc 1 151 22
 405 021a 97F80621 		ldrb	r2, [r7, #262]
 406 021e 97F80731 		ldrb	r3, [r7, #263]
 407 0222 1343     		orrs	r3, r3, r2
 408 0224 DBB2     		uxtb	r3, r3
 409 0226 DBB2     		uxtb	r3, r3
 410 0228 0022     		movs	r2, #0
 411 022a C7F8D830 		str	r3, [r7, #216]
 412 022e C7F8DC20 		str	r2, [r7, #220]
 413              		.loc 1 151 48
 414 0232 4FF00002 		mov	r2, #0
 415 0236 4FF00003 		mov	r3, #0
 416 023a D7F8DC10 		ldr	r1, [r7, #220]
 417 023e 0B02     		lsls	r3, r1, #8
 418 0240 D7F8D810 		ldr	r1, [r7, #216]
 419 0244 43EA1163 		orr	r3, r3, r1, lsr #24
 420 0248 D7F8D810 		ldr	r1, [r7, #216]
 421 024c 0A02     		lsls	r2, r1, #8
 150:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 16) |
 422              		.loc 1 150 55
ARM GAS  /tmp/ccYYtTab.s 			page 11


 423 024e 48EA0204 		orr	r4, r8, r2
 424 0252 49EA0305 		orr	r5, r9, r3
 152:Src/nvm.c     ****                     (uint64_t)(states | mask);
 425              		.loc 1 152 21
 426 0256 97F80621 		ldrb	r2, [r7, #262]
 427 025a 97F80731 		ldrb	r3, [r7, #263]
 428 025e 1343     		orrs	r3, r3, r2
 429 0260 DBB2     		uxtb	r3, r3
 430 0262 DBB2     		uxtb	r3, r3
 431 0264 0022     		movs	r2, #0
 432 0266 C7F88830 		str	r3, [r7, #136]
 433 026a C7F88C20 		str	r2, [r7, #140]
 145:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 48) |
 434              		.loc 1 145 20
 435 026e D7E92212 		ldrd	r1, [r7, #136]
 436 0272 0B46     		mov	r3, r1
 437 0274 2343     		orrs	r3, r3, r4
 438 0276 BB60     		str	r3, [r7, #8]
 439 0278 1346     		mov	r3, r2
 440 027a 2B43     		orrs	r3, r3, r5
 441 027c FB60     		str	r3, [r7, #12]
 442 027e D7E90223 		ldrd	r2, [r7, #8]
 443 0282 C7E93E23 		strd	r2, [r7, #248]
 153:Src/nvm.c     ****         
 154:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, 
 155:Src/nvm.c     ****                 (uintptr_t)&sector->alloc_table[index >> 2], 
 444              		.loc 1 155 35
 445 0286 D7F8F430 		ldr	r3, [r7, #244]
 446 028a 1A69     		ldr	r2, [r3, #16]
 447              		.loc 1 155 55
 448 028c D7F8F030 		ldr	r3, [r7, #240]
 449 0290 9B08     		lsrs	r3, r3, #2
 450              		.loc 1 155 28
 451 0292 1344     		add	r3, r3, r2
 154:Src/nvm.c     ****                 (uintptr_t)&sector->alloc_table[index >> 2], 
 452              		.loc 1 154 13
 453 0294 1946     		mov	r1, r3
 454 0296 D7E93E23 		ldrd	r2, [r7, #248]
 455 029a 0020     		movs	r0, #0
 456 029c FFF7FEFF 		bl	HAL_FLASH_Program
 457 02a0 0346     		mov	r3, r0
 154:Src/nvm.c     ****                 (uintptr_t)&sector->alloc_table[index >> 2], 
 458              		.loc 1 154 12
 459 02a2 002B     		cmp	r3, #0
 460 02a4 40F00D81 		bne	.L19
 156:Src/nvm.c     ****                 dword_data) != HAL_OK)
 157:Src/nvm.c     ****             goto fail;
 158:Src/nvm.c     ****         mask = 0;
 461              		.loc 1 158 14
 462 02a8 0023     		movs	r3, #0
 463 02aa 87F80731 		strb	r3, [r7, #263]
 144:Src/nvm.c     ****         dword_data = ((uint64_t)(states | mask) << 56) | 
 464              		.loc 1 144 30
 465 02ae D7F8EC30 		ldr	r3, [r7, #236]
 466 02b2 043B     		subs	r3, r3, #4
 467 02b4 C7F8EC30 		str	r3, [r7, #236]
 144:Src/nvm.c     ****         dword_data = ((uint64_t)(states | mask) << 56) | 
ARM GAS  /tmp/ccYYtTab.s 			page 12


 468              		.loc 1 144 42
 469 02b8 D7F8F030 		ldr	r3, [r7, #240]
 470 02bc 0433     		adds	r3, r3, #4
 471 02be C7F8F030 		str	r3, [r7, #240]
 472              	.L14:
 144:Src/nvm.c     ****         dword_data = ((uint64_t)(states | mask) << 56) | 
 473              		.loc 1 144 5 discriminator 1
 474 02c2 D7F8EC30 		ldr	r3, [r7, #236]
 475 02c6 032B     		cmp	r3, #3
 476 02c8 3FF6FCAE 		bhi	.L17
 159:Src/nvm.c     ****     }
 160:Src/nvm.c     **** 
 161:Src/nvm.c     ****     // handle unaligned end
 162:Src/nvm.c     ****     if (count) {
 477              		.loc 1 162 8
 478 02cc D7F8EC30 		ldr	r3, [r7, #236]
 479 02d0 002B     		cmp	r3, #0
 480 02d2 00F0F280 		beq	.L18
 163:Src/nvm.c     ****         mask |= ~(0xff >> ((4 - count) << 1));
 481              		.loc 1 163 31
 482 02d6 D7F8EC30 		ldr	r3, [r7, #236]
 483 02da C3F10403 		rsb	r3, r3, #4
 484              		.loc 1 163 40
 485 02de 5A00     		lsls	r2, r3, #1
 486              		.loc 1 163 24
 487 02e0 FF23     		movs	r3, #255
 488 02e2 1341     		asrs	r3, r3, r2
 489              		.loc 1 163 14
 490 02e4 5BB2     		sxtb	r3, r3
 491 02e6 DB43     		mvns	r3, r3
 492 02e8 5AB2     		sxtb	r2, r3
 493 02ea 97F90731 		ldrsb	r3, [r7, #263]
 494 02ee 1343     		orrs	r3, r3, r2
 495 02f0 5BB2     		sxtb	r3, r3
 496 02f2 87F80731 		strb	r3, [r7, #263]
 164:Src/nvm.c     ****         dword_data = ((uint64_t)(states | mask) << 56) |
 497              		.loc 1 164 23
 498 02f6 97F80621 		ldrb	r2, [r7, #262]
 499 02fa 97F80731 		ldrb	r3, [r7, #263]
 500 02fe 1343     		orrs	r3, r3, r2
 501 0300 DBB2     		uxtb	r3, r3
 502 0302 DBB2     		uxtb	r3, r3
 503 0304 0022     		movs	r2, #0
 504 0306 C7F88030 		str	r3, [r7, #128]
 505 030a C7F88420 		str	r2, [r7, #132]
 506              		.loc 1 164 49
 507 030e 4FF00000 		mov	r0, #0
 508 0312 4FF00001 		mov	r1, #0
 509 0316 D7F88030 		ldr	r3, [r7, #128]
 510 031a 1906     		lsls	r1, r3, #24
 511 031c 0020     		movs	r0, #0
 165:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 48) |
 512              		.loc 1 165 22
 513 031e 97F80621 		ldrb	r2, [r7, #262]
 514 0322 97F80731 		ldrb	r3, [r7, #263]
 515 0326 1343     		orrs	r3, r3, r2
 516 0328 DBB2     		uxtb	r3, r3
ARM GAS  /tmp/ccYYtTab.s 			page 13


 517 032a DBB2     		uxtb	r3, r3
 518 032c 0022     		movs	r2, #0
 519 032e BB67     		str	r3, [r7, #120]
 520 0330 FA67     		str	r2, [r7, #124]
 521              		.loc 1 165 48
 522 0332 4FF00002 		mov	r2, #0
 523 0336 4FF00003 		mov	r3, #0
 524 033a BC6F     		ldr	r4, [r7, #120]
 525 033c 2304     		lsls	r3, r4, #16
 526 033e 0022     		movs	r2, #0
 164:Src/nvm.c     ****         dword_data = ((uint64_t)(states | mask) << 56) |
 527              		.loc 1 164 56
 528 0340 40EA0204 		orr	r4, r0, r2
 529 0344 3C67     		str	r4, [r7, #112]
 530 0346 0B43     		orrs	r3, r3, r1
 531 0348 7B67     		str	r3, [r7, #116]
 166:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 40) |
 532              		.loc 1 166 22
 533 034a 97F80621 		ldrb	r2, [r7, #262]
 534 034e 97F80731 		ldrb	r3, [r7, #263]
 535 0352 1343     		orrs	r3, r3, r2
 536 0354 DBB2     		uxtb	r3, r3
 537 0356 DBB2     		uxtb	r3, r3
 538 0358 0022     		movs	r2, #0
 539 035a BB66     		str	r3, [r7, #104]
 540 035c FA66     		str	r2, [r7, #108]
 541              		.loc 1 166 48
 542 035e 4FF00002 		mov	r2, #0
 543 0362 4FF00003 		mov	r3, #0
 544 0366 B96E     		ldr	r1, [r7, #104]
 545 0368 0B02     		lsls	r3, r1, #8
 546 036a 0022     		movs	r2, #0
 165:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 48) |
 547              		.loc 1 165 55
 548 036c D7E91C45 		ldrd	r4, [r7, #112]
 549 0370 2146     		mov	r1, r4
 550 0372 1143     		orrs	r1, r1, r2
 551 0374 3966     		str	r1, [r7, #96]
 552 0376 2946     		mov	r1, r5
 553 0378 1943     		orrs	r1, r1, r3
 554 037a 7966     		str	r1, [r7, #100]
 167:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 32) |
 555              		.loc 1 167 22
 556 037c 97F80621 		ldrb	r2, [r7, #262]
 557 0380 97F80731 		ldrb	r3, [r7, #263]
 558 0384 1343     		orrs	r3, r3, r2
 559 0386 DBB2     		uxtb	r3, r3
 560 0388 DBB2     		uxtb	r3, r3
 561 038a 0022     		movs	r2, #0
 562 038c BB65     		str	r3, [r7, #88]
 563 038e FA65     		str	r2, [r7, #92]
 564              		.loc 1 167 48
 565 0390 4FF00002 		mov	r2, #0
 566 0394 4FF00003 		mov	r3, #0
 567 0398 B96D     		ldr	r1, [r7, #88]
 568 039a 0B00     		movs	r3, r1
 569 039c 0022     		movs	r2, #0
ARM GAS  /tmp/ccYYtTab.s 			page 14


 166:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 40) |
 570              		.loc 1 166 55
 571 039e D7E91845 		ldrd	r4, [r7, #96]
 572 03a2 2146     		mov	r1, r4
 573 03a4 1143     		orrs	r1, r1, r2
 574 03a6 3965     		str	r1, [r7, #80]
 575 03a8 2946     		mov	r1, r5
 576 03aa 1943     		orrs	r1, r1, r3
 577 03ac 7965     		str	r1, [r7, #84]
 168:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 24) |
 578              		.loc 1 168 22
 579 03ae 97F80621 		ldrb	r2, [r7, #262]
 580 03b2 97F80731 		ldrb	r3, [r7, #263]
 581 03b6 1343     		orrs	r3, r3, r2
 582 03b8 DBB2     		uxtb	r3, r3
 583 03ba DBB2     		uxtb	r3, r3
 584 03bc 0022     		movs	r2, #0
 585 03be BB64     		str	r3, [r7, #72]
 586 03c0 FA64     		str	r2, [r7, #76]
 587              		.loc 1 168 48
 588 03c2 D7E91212 		ldrd	r1, [r7, #72]
 589 03c6 0B46     		mov	r3, r1
 590 03c8 1B0A     		lsrs	r3, r3, #8
 591 03ca 7B64     		str	r3, [r7, #68]
 592 03cc 0B46     		mov	r3, r1
 593 03ce 1B06     		lsls	r3, r3, #24
 594 03d0 3B64     		str	r3, [r7, #64]
 167:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 32) |
 595              		.loc 1 167 55
 596 03d2 D7E91445 		ldrd	r4, [r7, #80]
 597 03d6 2346     		mov	r3, r4
 598 03d8 D7E91001 		ldrd	r0, [r7, #64]
 599 03dc 0246     		mov	r2, r0
 600 03de 1343     		orrs	r3, r3, r2
 601 03e0 BB63     		str	r3, [r7, #56]
 602 03e2 2B46     		mov	r3, r5
 603 03e4 0A46     		mov	r2, r1
 604 03e6 1343     		orrs	r3, r3, r2
 605 03e8 FB63     		str	r3, [r7, #60]
 169:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 16) |
 606              		.loc 1 169 22
 607 03ea 97F80621 		ldrb	r2, [r7, #262]
 608 03ee 97F80731 		ldrb	r3, [r7, #263]
 609 03f2 1343     		orrs	r3, r3, r2
 610 03f4 DBB2     		uxtb	r3, r3
 611 03f6 DBB2     		uxtb	r3, r3
 612 03f8 0022     		movs	r2, #0
 613 03fa 3B63     		str	r3, [r7, #48]
 614 03fc 7A63     		str	r2, [r7, #52]
 615              		.loc 1 169 48
 616 03fe 4FF00002 		mov	r2, #0
 617 0402 4FF00003 		mov	r3, #0
 618 0406 D7E90C45 		ldrd	r4, [r7, #48]
 619 040a 2946     		mov	r1, r5
 620 040c 0B04     		lsls	r3, r1, #16
 621 040e 2146     		mov	r1, r4
 622 0410 43EA1143 		orr	r3, r3, r1, lsr #16
ARM GAS  /tmp/ccYYtTab.s 			page 15


 623 0414 2146     		mov	r1, r4
 624 0416 0A04     		lsls	r2, r1, #16
 168:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 24) |
 625              		.loc 1 168 55
 626 0418 D7E90E45 		ldrd	r4, [r7, #56]
 627 041c 2146     		mov	r1, r4
 628 041e 1143     		orrs	r1, r1, r2
 629 0420 B962     		str	r1, [r7, #40]
 630 0422 2946     		mov	r1, r5
 631 0424 1943     		orrs	r1, r1, r3
 632 0426 F962     		str	r1, [r7, #44]
 170:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 8) |
 633              		.loc 1 170 22
 634 0428 97F80621 		ldrb	r2, [r7, #262]
 635 042c 97F80731 		ldrb	r3, [r7, #263]
 636 0430 1343     		orrs	r3, r3, r2
 637 0432 DBB2     		uxtb	r3, r3
 638 0434 DBB2     		uxtb	r3, r3
 639 0436 0022     		movs	r2, #0
 640 0438 3B62     		str	r3, [r7, #32]
 641 043a 7A62     		str	r2, [r7, #36]
 642              		.loc 1 170 48
 643 043c 4FF00002 		mov	r2, #0
 644 0440 4FF00003 		mov	r3, #0
 645 0444 D7E90845 		ldrd	r4, [r7, #32]
 646 0448 2946     		mov	r1, r5
 647 044a 0B02     		lsls	r3, r1, #8
 648 044c 2146     		mov	r1, r4
 649 044e 43EA1163 		orr	r3, r3, r1, lsr #24
 650 0452 2146     		mov	r1, r4
 651 0454 0A02     		lsls	r2, r1, #8
 169:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 16) |
 652              		.loc 1 169 55
 653 0456 D7E90A45 		ldrd	r4, [r7, #40]
 654 045a 2146     		mov	r1, r4
 655 045c 1143     		orrs	r1, r1, r2
 656 045e B961     		str	r1, [r7, #24]
 657 0460 2946     		mov	r1, r5
 658 0462 1943     		orrs	r1, r1, r3
 659 0464 F961     		str	r1, [r7, #28]
 171:Src/nvm.c     ****                     (uint64_t)(states | mask);
 660              		.loc 1 171 21
 661 0466 97F80621 		ldrb	r2, [r7, #262]
 662 046a 97F80731 		ldrb	r3, [r7, #263]
 663 046e 1343     		orrs	r3, r3, r2
 664 0470 DBB2     		uxtb	r3, r3
 665 0472 DBB2     		uxtb	r3, r3
 666 0474 0022     		movs	r2, #0
 667 0476 3B61     		str	r3, [r7, #16]
 668 0478 7A61     		str	r2, [r7, #20]
 164:Src/nvm.c     ****                     ((uint64_t)(states | mask) << 48) |
 669              		.loc 1 164 20
 670 047a D7E90645 		ldrd	r4, [r7, #24]
 671 047e 2346     		mov	r3, r4
 672 0480 D7E90401 		ldrd	r0, [r7, #16]
 673 0484 0246     		mov	r2, r0
 674 0486 1343     		orrs	r3, r3, r2
ARM GAS  /tmp/ccYYtTab.s 			page 16


 675 0488 3B60     		str	r3, [r7]
 676 048a 2B46     		mov	r3, r5
 677 048c 0A46     		mov	r2, r1
 678 048e 1343     		orrs	r3, r3, r2
 679 0490 7B60     		str	r3, [r7, #4]
 680 0492 D7E90034 		ldrd	r3, [r7]
 681 0496 C7E93E34 		strd	r3, [r7, #248]
 172:Src/nvm.c     ****                     
 173:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, 
 174:Src/nvm.c     ****                 (uintptr_t)&sector->alloc_table[index >> 2], 
 682              		.loc 1 174 35
 683 049a D7F8F430 		ldr	r3, [r7, #244]
 684 049e 1A69     		ldr	r2, [r3, #16]
 685              		.loc 1 174 55
 686 04a0 D7F8F030 		ldr	r3, [r7, #240]
 687 04a4 9B08     		lsrs	r3, r3, #2
 688              		.loc 1 174 28
 689 04a6 1344     		add	r3, r3, r2
 173:Src/nvm.c     ****                 (uintptr_t)&sector->alloc_table[index >> 2], 
 690              		.loc 1 173 13
 691 04a8 1946     		mov	r1, r3
 692 04aa D7E93E23 		ldrd	r2, [r7, #248]
 693 04ae 0020     		movs	r0, #0
 694 04b0 FFF7FEFF 		bl	HAL_FLASH_Program
 695 04b4 0346     		mov	r3, r0
 173:Src/nvm.c     ****                 (uintptr_t)&sector->alloc_table[index >> 2], 
 696              		.loc 1 173 12
 697 04b6 002B     		cmp	r3, #0
 698 04b8 05D1     		bne	.L20
 699              	.L18:
 175:Src/nvm.c     ****                 dword_data) != HAL_OK)
 176:Src/nvm.c     ****             goto fail;
 177:Src/nvm.c     ****     }
 178:Src/nvm.c     ****     
 179:Src/nvm.c     ****     HAL_FLASH_Lock();
 700              		.loc 1 179 5
 701 04ba FFF7FEFF 		bl	HAL_FLASH_Lock
 180:Src/nvm.c     ****     return 0;
 702              		.loc 1 180 12
 703 04be 0023     		movs	r3, #0
 704 04c0 07E0     		b	.L12
 705              	.L19:
 157:Src/nvm.c     ****         mask = 0;
 706              		.loc 1 157 13
 707 04c2 00BF     		nop
 708 04c4 00E0     		b	.L16
 709              	.L20:
 176:Src/nvm.c     ****     }
 710              		.loc 1 176 13
 711 04c6 00BF     		nop
 712              	.L16:
 181:Src/nvm.c     **** fail:
 182:Src/nvm.c     ****     HAL_FLASH_Lock();
 713              		.loc 1 182 5
 714 04c8 FFF7FEFF 		bl	HAL_FLASH_Lock
 183:Src/nvm.c     ****     return HAL_FLASH_GetError(); // non-zero
 715              		.loc 1 183 12
ARM GAS  /tmp/ccYYtTab.s 			page 17


 716 04cc FFF7FEFF 		bl	HAL_FLASH_GetError
 717 04d0 0346     		mov	r3, r0
 718              	.L12:
 184:Src/nvm.c     **** }
 719              		.loc 1 184 1
 720 04d2 1846     		mov	r0, r3
 721 04d4 07F58677 		add	r7, r7, #268
 722              	.LCFI8:
 723              		.cfi_def_cfa_offset 36
 724 04d8 BD46     		mov	sp, r7
 725              	.LCFI9:
 726              		.cfi_def_cfa_register 13
 727              		@ sp needed
 728 04da BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 729              		.cfi_endproc
 730              	.LFE133:
 732 04de 00BF     		.section	.text.scan_allocation_table,"ax",%progbits
 733              		.align	1
 734              		.global	scan_allocation_table
 735              		.syntax unified
 736              		.thumb
 737              		.thumb_func
 738              		.fpu fpv4-sp-d16
 740              	scan_allocation_table:
 741              	.LFB134:
 185:Src/nvm.c     **** 
 186:Src/nvm.c     **** // @brief Reads the allocation table from behind to determine how many fields match the
 187:Src/nvm.c     **** // reference state.
 188:Src/nvm.c     **** // @param sector: The sector on which to perform the search
 189:Src/nvm.c     **** // @param max_index: The maximum index that should be considered
 190:Src/nvm.c     **** // @param ref_state: The reference state
 191:Src/nvm.c     **** // @param state: Set to the first encountered state that is unequal to ref_state.
 192:Src/nvm.c     **** //               Set to ref_state if all encountered states are equal to ref_state.
 193:Src/nvm.c     **** // @returns The smallest index that points to a field with ref_state.
 194:Src/nvm.c     **** //          This value is at least sector->n_reserved and at most max_index.
 195:Src/nvm.c     **** size_t scan_allocation_table(sector_t *sector, size_t max_index, field_state_t ref_state, field_sta
 742              		.loc 1 195 113
 743              		.cfi_startproc
 744              		@ args = 0, pretend = 0, frame = 32
 745              		@ frame_needed = 1, uses_anonymous_args = 0
 746              		@ link register save eliminated.
 747 0000 80B4     		push	{r7}
 748              	.LCFI10:
 749              		.cfi_def_cfa_offset 4
 750              		.cfi_offset 7, -4
 751 0002 89B0     		sub	sp, sp, #36
 752              	.LCFI11:
 753              		.cfi_def_cfa_offset 40
 754 0004 00AF     		add	r7, sp, #0
 755              	.LCFI12:
 756              		.cfi_def_cfa_register 7
 757 0006 F860     		str	r0, [r7, #12]
 758 0008 B960     		str	r1, [r7, #8]
 759 000a 3B60     		str	r3, [r7]
 760 000c 1346     		mov	r3, r2
 761 000e FB71     		strb	r3, [r7, #7]
 196:Src/nvm.c     ****     const uint8_t ref_states = (ref_state << 0) | (ref_state << 2) | (ref_state << 4) | (ref_state 
ARM GAS  /tmp/ccYYtTab.s 			page 18


 762              		.loc 1 196 62
 763 0010 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 764 0012 9B00     		lsls	r3, r3, #2
 765              		.loc 1 196 49
 766 0014 5AB2     		sxtb	r2, r3
 767 0016 97F90730 		ldrsb	r3, [r7, #7]
 768 001a 1343     		orrs	r3, r3, r2
 769 001c 5AB2     		sxtb	r2, r3
 770              		.loc 1 196 81
 771 001e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 772 0020 1B01     		lsls	r3, r3, #4
 773              		.loc 1 196 68
 774 0022 5BB2     		sxtb	r3, r3
 775 0024 1343     		orrs	r3, r3, r2
 776 0026 5AB2     		sxtb	r2, r3
 777              		.loc 1 196 100
 778 0028 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 779 002a 9B01     		lsls	r3, r3, #6
 780              		.loc 1 196 87
 781 002c 5BB2     		sxtb	r3, r3
 782 002e 1343     		orrs	r3, r3, r2
 783 0030 5BB2     		sxtb	r3, r3
 784              		.loc 1 196 19
 785 0032 BB75     		strb	r3, [r7, #22]
 197:Src/nvm.c     ****     size_t index = (((max_index + 3) >> 2) << 2); // start at the max index but round up to a multi
 786              		.loc 1 197 33
 787 0034 BB68     		ldr	r3, [r7, #8]
 788 0036 0333     		adds	r3, r3, #3
 789              		.loc 1 197 12
 790 0038 23F00303 		bic	r3, r3, #3
 791 003c FB61     		str	r3, [r7, #28]
 198:Src/nvm.c     ****     size_t ignore = index - max_index;
 792              		.loc 1 198 12
 793 003e FA69     		ldr	r2, [r7, #28]
 794 0040 BB68     		ldr	r3, [r7, #8]
 795 0042 D31A     		subs	r3, r2, r3
 796 0044 BB61     		str	r3, [r7, #24]
 199:Src/nvm.c     ****     uint8_t states = ref_states;
 797              		.loc 1 199 13
 798 0046 BB7D     		ldrb	r3, [r7, #22]
 799 0048 FB75     		strb	r3, [r7, #23]
 200:Src/nvm.c     **** 
 201:Src/nvm.c     ****     //printf("scan from %08x to %08x for %02x\r\n", index, sector->n_reserved, ref_states); osDelay
 202:Src/nvm.c     **** 
 203:Src/nvm.c     ****     // read 4 states at a time
 204:Src/nvm.c     ****     for (; index >= (sector->n_reserved + 4); index -= 4) {
 800              		.loc 1 204 5
 801 004a 2BE0     		b	.L24
 802              	.L28:
 205:Src/nvm.c     ****         states = sector->alloc_table[(index - 1) >> 2];
 803              		.loc 1 205 24
 804 004c FB68     		ldr	r3, [r7, #12]
 805 004e 1A69     		ldr	r2, [r3, #16]
 806              		.loc 1 205 45
 807 0050 FB69     		ldr	r3, [r7, #28]
 808 0052 013B     		subs	r3, r3, #1
 809              		.loc 1 205 50
ARM GAS  /tmp/ccYYtTab.s 			page 19


 810 0054 9B08     		lsrs	r3, r3, #2
 811              		.loc 1 205 37
 812 0056 1344     		add	r3, r3, r2
 813              		.loc 1 205 16
 814 0058 1B78     		ldrb	r3, [r3]
 815 005a FB75     		strb	r3, [r7, #23]
 206:Src/nvm.c     ****         if (ignore) { // ignore the upper 1, 2 or 3 states if max_index was unaligned
 816              		.loc 1 206 12
 817 005c BB69     		ldr	r3, [r7, #24]
 818 005e 002B     		cmp	r3, #0
 819 0060 19D0     		beq	.L25
 820              	.LBB2:
 207:Src/nvm.c     ****             uint8_t ignore_mask = ~(0xff >> (ignore << 1));
 821              		.loc 1 207 53
 822 0062 BB69     		ldr	r3, [r7, #24]
 823 0064 5B00     		lsls	r3, r3, #1
 824              		.loc 1 207 42
 825 0066 FF22     		movs	r2, #255
 826 0068 42FA03F3 		asr	r3, r2, r3
 827              		.loc 1 207 21
 828 006c DBB2     		uxtb	r3, r3
 829 006e DB43     		mvns	r3, r3
 830 0070 7B75     		strb	r3, [r7, #21]
 208:Src/nvm.c     ****             states = (states & ~ignore_mask) | (ref_states & ignore_mask);
 831              		.loc 1 208 30
 832 0072 97F91530 		ldrsb	r3, [r7, #21]
 833 0076 DB43     		mvns	r3, r3
 834 0078 5AB2     		sxtb	r2, r3
 835 007a 97F91730 		ldrsb	r3, [r7, #23]
 836 007e 1340     		ands	r3, r3, r2
 837 0080 5AB2     		sxtb	r2, r3
 838              		.loc 1 208 46
 839 0082 B97D     		ldrb	r1, [r7, #22]
 840 0084 7B7D     		ldrb	r3, [r7, #21]
 841 0086 0B40     		ands	r3, r3, r1
 842 0088 DBB2     		uxtb	r3, r3
 843 008a 5BB2     		sxtb	r3, r3
 844 008c 1343     		orrs	r3, r3, r2
 845 008e 5BB2     		sxtb	r3, r3
 846              		.loc 1 208 20
 847 0090 FB75     		strb	r3, [r7, #23]
 209:Src/nvm.c     ****             ignore = 0;
 848              		.loc 1 209 20
 849 0092 0023     		movs	r3, #0
 850 0094 BB61     		str	r3, [r7, #24]
 851              	.L25:
 852              	.LBE2:
 210:Src/nvm.c     ****         }
 211:Src/nvm.c     ****         if (states != ref_states)
 853              		.loc 1 211 12
 854 0096 FA7D     		ldrb	r2, [r7, #23]	@ zero_extendqisi2
 855 0098 BB7D     		ldrb	r3, [r7, #22]	@ zero_extendqisi2
 856 009a 9A42     		cmp	r2, r3
 857 009c 09D1     		bne	.L33
 204:Src/nvm.c     ****         states = sector->alloc_table[(index - 1) >> 2];
 858              		.loc 1 204 53
 859 009e FB69     		ldr	r3, [r7, #28]
ARM GAS  /tmp/ccYYtTab.s 			page 20


 860 00a0 043B     		subs	r3, r3, #4
 861 00a2 FB61     		str	r3, [r7, #28]
 862              	.L24:
 204:Src/nvm.c     ****         states = sector->alloc_table[(index - 1) >> 2];
 863              		.loc 1 204 28 discriminator 1
 864 00a4 FB68     		ldr	r3, [r7, #12]
 865 00a6 DB68     		ldr	r3, [r3, #12]
 204:Src/nvm.c     ****         states = sector->alloc_table[(index - 1) >> 2];
 866              		.loc 1 204 41 discriminator 1
 867 00a8 0433     		adds	r3, r3, #4
 204:Src/nvm.c     ****         states = sector->alloc_table[(index - 1) >> 2];
 868              		.loc 1 204 5 discriminator 1
 869 00aa FA69     		ldr	r2, [r7, #28]
 870 00ac 9A42     		cmp	r2, r3
 871 00ae CDD2     		bcs	.L28
 872 00b0 07E0     		b	.L29
 873              	.L33:
 212:Src/nvm.c     ****             break;
 874              		.loc 1 212 13
 875 00b2 00BF     		nop
 213:Src/nvm.c     ****     }
 214:Src/nvm.c     **** 
 215:Src/nvm.c     ****     // once we encounterd a byte with any state mismatch determine which of the 4 states it is
 216:Src/nvm.c     ****     for (; ((states >> 6) == (ref_states & 0x3)) && (index > sector->n_reserved); index--) {
 876              		.loc 1 216 5
 877 00b4 05E0     		b	.L29
 878              	.L31:
 217:Src/nvm.c     ****         states <<= 2;
 879              		.loc 1 217 16 discriminator 3
 880 00b6 FB7D     		ldrb	r3, [r7, #23]
 881 00b8 9B00     		lsls	r3, r3, #2
 882 00ba FB75     		strb	r3, [r7, #23]
 216:Src/nvm.c     ****         states <<= 2;
 883              		.loc 1 216 88 discriminator 3
 884 00bc FB69     		ldr	r3, [r7, #28]
 885 00be 013B     		subs	r3, r3, #1
 886 00c0 FB61     		str	r3, [r7, #28]
 887              	.L29:
 216:Src/nvm.c     ****         states <<= 2;
 888              		.loc 1 216 21 discriminator 1
 889 00c2 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 890 00c4 9B09     		lsrs	r3, r3, #6
 891 00c6 DBB2     		uxtb	r3, r3
 892 00c8 1A46     		mov	r2, r3
 216:Src/nvm.c     ****         states <<= 2;
 893              		.loc 1 216 42 discriminator 1
 894 00ca BB7D     		ldrb	r3, [r7, #22]	@ zero_extendqisi2
 895 00cc 03F00303 		and	r3, r3, #3
 216:Src/nvm.c     ****         states <<= 2;
 896              		.loc 1 216 5 discriminator 1
 897 00d0 9A42     		cmp	r2, r3
 898 00d2 04D1     		bne	.L30
 216:Src/nvm.c     ****         states <<= 2;
 899              		.loc 1 216 68 discriminator 2
 900 00d4 FB68     		ldr	r3, [r7, #12]
 901 00d6 DB68     		ldr	r3, [r3, #12]
 216:Src/nvm.c     ****         states <<= 2;
ARM GAS  /tmp/ccYYtTab.s 			page 21


 902              		.loc 1 216 50 discriminator 2
 903 00d8 FA69     		ldr	r2, [r7, #28]
 904 00da 9A42     		cmp	r2, r3
 905 00dc EBD8     		bhi	.L31
 906              	.L30:
 218:Src/nvm.c     ****     }
 219:Src/nvm.c     ****     
 220:Src/nvm.c     ****     *state = states >> 6;
 907              		.loc 1 220 12
 908 00de FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 909 00e0 9B09     		lsrs	r3, r3, #6
 910 00e2 DAB2     		uxtb	r2, r3
 911 00e4 3B68     		ldr	r3, [r7]
 912 00e6 1A70     		strb	r2, [r3]
 221:Src/nvm.c     ****     //printf("(it's %02x)\r\n", index); osDelay(5);
 222:Src/nvm.c     ****     return index;
 913              		.loc 1 222 12
 914 00e8 FB69     		ldr	r3, [r7, #28]
 223:Src/nvm.c     **** }
 915              		.loc 1 223 1
 916 00ea 1846     		mov	r0, r3
 917 00ec 2437     		adds	r7, r7, #36
 918              	.LCFI13:
 919              		.cfi_def_cfa_offset 4
 920 00ee BD46     		mov	sp, r7
 921              	.LCFI14:
 922              		.cfi_def_cfa_register 13
 923              		@ sp needed
 924 00f0 5DF8047B 		ldr	r7, [sp], #4
 925              	.LCFI15:
 926              		.cfi_restore 7
 927              		.cfi_def_cfa_offset 0
 928 00f4 7047     		bx	lr
 929              		.cfi_endproc
 930              	.LFE134:
 932              		.section	.text.NVM_init,"ax",%progbits
 933              		.align	1
 934              		.global	NVM_init
 935              		.syntax unified
 936              		.thumb
 937              		.thumb_func
 938              		.fpu fpv4-sp-d16
 940              	NVM_init:
 941              	.LFB135:
 224:Src/nvm.c     **** 
 225:Src/nvm.c     **** // Loads the head of the NVM data.
 226:Src/nvm.c     **** // If this function fails subsequent calls to NVM functions (other than NVM_init or NVM_erase)
 227:Src/nvm.c     **** // cause undefined behavior.
 228:Src/nvm.c     **** // @returns 0 on success or a non-zero error code otherwise
 229:Src/nvm.c     **** int NVM_init(void) {
 942              		.loc 1 229 20
 943              		.cfi_startproc
 944              		@ args = 0, pretend = 0, frame = 16
 945              		@ frame_needed = 1, uses_anonymous_args = 0
 946 0000 80B5     		push	{r7, lr}
 947              	.LCFI16:
 948              		.cfi_def_cfa_offset 8
ARM GAS  /tmp/ccYYtTab.s 			page 22


 949              		.cfi_offset 7, -8
 950              		.cfi_offset 14, -4
 951 0002 84B0     		sub	sp, sp, #16
 952              	.LCFI17:
 953              		.cfi_def_cfa_offset 24
 954 0004 00AF     		add	r7, sp, #0
 955              	.LCFI18:
 956              		.cfi_def_cfa_register 7
 230:Src/nvm.c     ****     field_state_t sector0_state, sector1_state;
 231:Src/nvm.c     ****     sectors[0].index = scan_allocation_table(&sectors[0], sectors[0].n_data,
 957              		.loc 1 231 24
 958 0006 1F4B     		ldr	r3, .L37
 959 0008 9968     		ldr	r1, [r3, #8]
 960 000a FB1C     		adds	r3, r7, #3
 961 000c 0322     		movs	r2, #3
 962 000e 1D48     		ldr	r0, .L37
 963 0010 FFF7FEFF 		bl	scan_allocation_table
 964 0014 0346     		mov	r3, r0
 965              		.loc 1 231 22
 966 0016 1B4A     		ldr	r2, .L37
 967 0018 1360     		str	r3, [r2]
 232:Src/nvm.c     ****                 ERASED, &sector0_state);
 233:Src/nvm.c     ****     sectors[1].index = scan_allocation_table(&sectors[1], sectors[1].n_data,
 968              		.loc 1 233 24
 969 001a 1A4B     		ldr	r3, .L37
 970 001c 196A     		ldr	r1, [r3, #32]
 971 001e BB1C     		adds	r3, r7, #2
 972 0020 0322     		movs	r2, #3
 973 0022 1948     		ldr	r0, .L37+4
 974 0024 FFF7FEFF 		bl	scan_allocation_table
 975 0028 0346     		mov	r3, r0
 976              		.loc 1 233 22
 977 002a 164A     		ldr	r2, .L37
 978 002c 9361     		str	r3, [r2, #24]
 234:Src/nvm.c     ****                 ERASED, &sector1_state);
 235:Src/nvm.c     ****     //printf("sector states: %02x, %02x\r\n", sector0_state, sector1_state); osDelay(5);
 236:Src/nvm.c     **** 
 237:Src/nvm.c     ****     // Select valid sector on a best effort basis
 238:Src/nvm.c     ****     // (in unfortunate cases valid_sector might actually point
 239:Src/nvm.c     ****     // to an invalid or erased sector)
 240:Src/nvm.c     ****     read_sector_ = 0;
 979              		.loc 1 240 18
 980 002e 174B     		ldr	r3, .L37+8
 981 0030 0022     		movs	r2, #0
 982 0032 1A70     		strb	r2, [r3]
 241:Src/nvm.c     ****     if (sector1_state == VALID)
 983              		.loc 1 241 23
 984 0034 BB78     		ldrb	r3, [r7, #2]	@ zero_extendqisi2
 985              		.loc 1 241 8
 986 0036 002B     		cmp	r3, #0
 987 0038 02D1     		bne	.L35
 242:Src/nvm.c     ****         read_sector_ = 1;
 988              		.loc 1 242 22
 989 003a 144B     		ldr	r3, .L37+8
 990 003c 0122     		movs	r2, #1
 991 003e 1A70     		strb	r2, [r3]
 992              	.L35:
ARM GAS  /tmp/ccYYtTab.s 			page 23


 243:Src/nvm.c     ****     
 244:Src/nvm.c     ****     // count the number of valid fields
 245:Src/nvm.c     ****     sector_t *read_sector = &sectors[read_sector_];
 993              		.loc 1 245 37
 994 0040 124B     		ldr	r3, .L37+8
 995 0042 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 996 0044 1A46     		mov	r2, r3
 997              		.loc 1 245 15
 998 0046 1346     		mov	r3, r2
 999 0048 5B00     		lsls	r3, r3, #1
 1000 004a 1344     		add	r3, r3, r2
 1001 004c DB00     		lsls	r3, r3, #3
 1002 004e 0D4A     		ldr	r2, .L37
 1003 0050 1344     		add	r3, r3, r2
 1004 0052 FB60     		str	r3, [r7, #12]
 246:Src/nvm.c     ****     uint8_t first_nonvalid_state;
 247:Src/nvm.c     ****     size_t min_valid_index = scan_allocation_table(read_sector, read_sector->index,
 1005              		.loc 1 247 30
 1006 0054 FB68     		ldr	r3, [r7, #12]
 1007 0056 1968     		ldr	r1, [r3]
 1008 0058 7B1C     		adds	r3, r7, #1
 1009 005a 0022     		movs	r2, #0
 1010 005c F868     		ldr	r0, [r7, #12]
 1011 005e FFF7FEFF 		bl	scan_allocation_table
 1012 0062 B860     		str	r0, [r7, #8]
 248:Src/nvm.c     ****         VALID, &first_nonvalid_state);
 249:Src/nvm.c     ****     n_valid_ = read_sector->index - min_valid_index;
 1013              		.loc 1 249 27
 1014 0064 FB68     		ldr	r3, [r7, #12]
 1015 0066 1A68     		ldr	r2, [r3]
 1016              		.loc 1 249 35
 1017 0068 BB68     		ldr	r3, [r7, #8]
 1018 006a D31A     		subs	r3, r2, r3
 1019              		.loc 1 249 14
 1020 006c 084A     		ldr	r2, .L37+12
 1021 006e 1360     		str	r3, [r2]
 250:Src/nvm.c     ****     
 251:Src/nvm.c     ****     n_staging_area_ = 0;
 1022              		.loc 1 251 21
 1023 0070 084B     		ldr	r3, .L37+16
 1024 0072 0022     		movs	r2, #0
 1025 0074 1A60     		str	r2, [r3]
 252:Src/nvm.c     **** 
 253:Src/nvm.c     ****     int status = 0;
 1026              		.loc 1 253 9
 1027 0076 0023     		movs	r3, #0
 1028 0078 7B60     		str	r3, [r7, #4]
 254:Src/nvm.c     ****     /*// bring non-valid sectors into a known state
 255:Src/nvm.c     ****     this is not absolutely required
 256:Src/nvm.c     ****     if (sector0_state != VALID)
 257:Src/nvm.c     ****         status |= erase(&sectors[0]);
 258:Src/nvm.c     ****     if (sector1_state != VALID)
 259:Src/nvm.c     ****         status |= erase(&sectors[1]);
 260:Src/nvm.c     ****     */
 261:Src/nvm.c     ****     return status;
 1029              		.loc 1 261 12
 1030 007a 7B68     		ldr	r3, [r7, #4]
ARM GAS  /tmp/ccYYtTab.s 			page 24


 262:Src/nvm.c     **** }
 1031              		.loc 1 262 1
 1032 007c 1846     		mov	r0, r3
 1033 007e 1037     		adds	r7, r7, #16
 1034              	.LCFI19:
 1035              		.cfi_def_cfa_offset 8
 1036 0080 BD46     		mov	sp, r7
 1037              	.LCFI20:
 1038              		.cfi_def_cfa_register 13
 1039              		@ sp needed
 1040 0082 80BD     		pop	{r7, pc}
 1041              	.L38:
 1042              		.align	2
 1043              	.L37:
 1044 0084 00000000 		.word	sectors
 1045 0088 18000000 		.word	sectors+24
 1046 008c 00000000 		.word	read_sector_
 1047 0090 00000000 		.word	n_valid_
 1048 0094 00000000 		.word	n_staging_area_
 1049              		.cfi_endproc
 1050              	.LFE135:
 1052              		.section	.text.NVM_erase,"ax",%progbits
 1053              		.align	1
 1054              		.global	NVM_erase
 1055              		.syntax unified
 1056              		.thumb
 1057              		.thumb_func
 1058              		.fpu fpv4-sp-d16
 1060              	NVM_erase:
 1061              	.LFB136:
 263:Src/nvm.c     **** 
 264:Src/nvm.c     **** // @brief Erases all data in the NVM.
 265:Src/nvm.c     **** //
 266:Src/nvm.c     **** // If this function fails subsequent calls to NVM functions (other than NVM_init or NVM_erase)
 267:Src/nvm.c     **** // cause undefined behavior.
 268:Src/nvm.c     **** // Caution: this function may take a long time (like 1 second)
 269:Src/nvm.c     **** //
 270:Src/nvm.c     **** // @returns 0 on success or a non-zero error code otherwise
 271:Src/nvm.c     **** int NVM_erase(void) {
 1062              		.loc 1 271 21
 1063              		.cfi_startproc
 1064              		@ args = 0, pretend = 0, frame = 8
 1065              		@ frame_needed = 1, uses_anonymous_args = 0
 1066 0000 80B5     		push	{r7, lr}
 1067              	.LCFI21:
 1068              		.cfi_def_cfa_offset 8
 1069              		.cfi_offset 7, -8
 1070              		.cfi_offset 14, -4
 1071 0002 82B0     		sub	sp, sp, #8
 1072              	.LCFI22:
 1073              		.cfi_def_cfa_offset 16
 1074 0004 00AF     		add	r7, sp, #0
 1075              	.LCFI23:
 1076              		.cfi_def_cfa_register 7
 272:Src/nvm.c     ****     read_sector_ = 0;
 1077              		.loc 1 272 18
 1078 0006 104B     		ldr	r3, .L41
ARM GAS  /tmp/ccYYtTab.s 			page 25


 1079 0008 0022     		movs	r2, #0
 1080 000a 1A70     		strb	r2, [r3]
 273:Src/nvm.c     ****     sectors[0].index = sectors[0].n_reserved;
 1081              		.loc 1 273 34
 1082 000c 0F4B     		ldr	r3, .L41+4
 1083 000e DB68     		ldr	r3, [r3, #12]
 1084              		.loc 1 273 22
 1085 0010 0E4A     		ldr	r2, .L41+4
 1086 0012 1360     		str	r3, [r2]
 274:Src/nvm.c     ****     sectors[1].index = sectors[1].n_reserved;
 1087              		.loc 1 274 34
 1088 0014 0D4B     		ldr	r3, .L41+4
 1089 0016 5B6A     		ldr	r3, [r3, #36]
 1090              		.loc 1 274 22
 1091 0018 0C4A     		ldr	r2, .L41+4
 1092 001a 9361     		str	r3, [r2, #24]
 275:Src/nvm.c     **** 
 276:Src/nvm.c     ****     int state = 0;
 1093              		.loc 1 276 9
 1094 001c 0023     		movs	r3, #0
 1095 001e 7B60     		str	r3, [r7, #4]
 277:Src/nvm.c     ****     state |= erase(&sectors[0]);
 1096              		.loc 1 277 14
 1097 0020 0A48     		ldr	r0, .L41+4
 1098 0022 FFF7FEFF 		bl	erase
 1099 0026 0246     		mov	r2, r0
 1100              		.loc 1 277 11
 1101 0028 7B68     		ldr	r3, [r7, #4]
 1102 002a 1343     		orrs	r3, r3, r2
 1103 002c 7B60     		str	r3, [r7, #4]
 278:Src/nvm.c     ****     state |= erase(&sectors[1]);
 1104              		.loc 1 278 14
 1105 002e 0848     		ldr	r0, .L41+8
 1106 0030 FFF7FEFF 		bl	erase
 1107 0034 0246     		mov	r2, r0
 1108              		.loc 1 278 11
 1109 0036 7B68     		ldr	r3, [r7, #4]
 1110 0038 1343     		orrs	r3, r3, r2
 1111 003a 7B60     		str	r3, [r7, #4]
 279:Src/nvm.c     ****     return state;
 1112              		.loc 1 279 12
 1113 003c 7B68     		ldr	r3, [r7, #4]
 280:Src/nvm.c     **** }
 1114              		.loc 1 280 1
 1115 003e 1846     		mov	r0, r3
 1116 0040 0837     		adds	r7, r7, #8
 1117              	.LCFI24:
 1118              		.cfi_def_cfa_offset 8
 1119 0042 BD46     		mov	sp, r7
 1120              	.LCFI25:
 1121              		.cfi_def_cfa_register 13
 1122              		@ sp needed
 1123 0044 80BD     		pop	{r7, pc}
 1124              	.L42:
 1125 0046 00BF     		.align	2
 1126              	.L41:
 1127 0048 00000000 		.word	read_sector_
ARM GAS  /tmp/ccYYtTab.s 			page 26


 1128 004c 00000000 		.word	sectors
 1129 0050 18000000 		.word	sectors+24
 1130              		.cfi_endproc
 1131              	.LFE136:
 1133              		.section	.text.NVM_get_max_read_length,"ax",%progbits
 1134              		.align	1
 1135              		.global	NVM_get_max_read_length
 1136              		.syntax unified
 1137              		.thumb
 1138              		.thumb_func
 1139              		.fpu fpv4-sp-d16
 1141              	NVM_get_max_read_length:
 1142              	.LFB137:
 281:Src/nvm.c     **** 
 282:Src/nvm.c     **** // @brief Returns the maximum number of bytes that can be read using NVM_read.
 283:Src/nvm.c     **** // This holds until NVM_commit is called.
 284:Src/nvm.c     **** size_t NVM_get_max_read_length(void) {
 1143              		.loc 1 284 38
 1144              		.cfi_startproc
 1145              		@ args = 0, pretend = 0, frame = 0
 1146              		@ frame_needed = 1, uses_anonymous_args = 0
 1147              		@ link register save eliminated.
 1148 0000 80B4     		push	{r7}
 1149              	.LCFI26:
 1150              		.cfi_def_cfa_offset 4
 1151              		.cfi_offset 7, -4
 1152 0002 00AF     		add	r7, sp, #0
 1153              	.LCFI27:
 1154              		.cfi_def_cfa_register 7
 285:Src/nvm.c     ****     return n_valid_ << 3;
 1155              		.loc 1 285 21
 1156 0004 034B     		ldr	r3, .L45
 1157 0006 1B68     		ldr	r3, [r3]
 1158 0008 DB00     		lsls	r3, r3, #3
 286:Src/nvm.c     **** }
 1159              		.loc 1 286 1
 1160 000a 1846     		mov	r0, r3
 1161 000c BD46     		mov	sp, r7
 1162              	.LCFI28:
 1163              		.cfi_def_cfa_register 13
 1164              		@ sp needed
 1165 000e 5DF8047B 		ldr	r7, [sp], #4
 1166              	.LCFI29:
 1167              		.cfi_restore 7
 1168              		.cfi_def_cfa_offset 0
 1169 0012 7047     		bx	lr
 1170              	.L46:
 1171              		.align	2
 1172              	.L45:
 1173 0014 00000000 		.word	n_valid_
 1174              		.cfi_endproc
 1175              	.LFE137:
 1177              		.section	.text.NVM_get_max_write_length,"ax",%progbits
 1178              		.align	1
 1179              		.global	NVM_get_max_write_length
 1180              		.syntax unified
 1181              		.thumb
ARM GAS  /tmp/ccYYtTab.s 			page 27


 1182              		.thumb_func
 1183              		.fpu fpv4-sp-d16
 1185              	NVM_get_max_write_length:
 1186              	.LFB138:
 287:Src/nvm.c     **** 
 288:Src/nvm.c     **** // @brief Returns the maximum length (in bytes) that can passed to NVM_start_write.
 289:Src/nvm.c     **** // This holds until NVM_commit is called.
 290:Src/nvm.c     **** size_t NVM_get_max_write_length(void) {
 1187              		.loc 1 290 39
 1188              		.cfi_startproc
 1189              		@ args = 0, pretend = 0, frame = 8
 1190              		@ frame_needed = 1, uses_anonymous_args = 0
 1191              		@ link register save eliminated.
 1192 0000 80B4     		push	{r7}
 1193              	.LCFI30:
 1194              		.cfi_def_cfa_offset 4
 1195              		.cfi_offset 7, -4
 1196 0002 83B0     		sub	sp, sp, #12
 1197              	.LCFI31:
 1198              		.cfi_def_cfa_offset 16
 1199 0004 00AF     		add	r7, sp, #0
 1200              	.LCFI32:
 1201              		.cfi_def_cfa_register 7
 291:Src/nvm.c     ****     sector_t *target = &sectors[1 - read_sector_];
 1202              		.loc 1 291 35
 1203 0006 0B4B     		ldr	r3, .L49
 1204 0008 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1205 000a C3F10102 		rsb	r2, r3, #1
 1206              		.loc 1 291 15
 1207 000e 1346     		mov	r3, r2
 1208 0010 5B00     		lsls	r3, r3, #1
 1209 0012 1344     		add	r3, r3, r2
 1210 0014 DB00     		lsls	r3, r3, #3
 1211 0016 084A     		ldr	r2, .L49+4
 1212 0018 1344     		add	r3, r3, r2
 1213 001a 7B60     		str	r3, [r7, #4]
 292:Src/nvm.c     ****     return (target->n_data - target->n_reserved) << 3;
 1214              		.loc 1 292 19
 1215 001c 7B68     		ldr	r3, [r7, #4]
 1216 001e 9A68     		ldr	r2, [r3, #8]
 1217              		.loc 1 292 36
 1218 0020 7B68     		ldr	r3, [r7, #4]
 1219 0022 DB68     		ldr	r3, [r3, #12]
 1220              		.loc 1 292 28
 1221 0024 D31A     		subs	r3, r2, r3
 1222              		.loc 1 292 50
 1223 0026 DB00     		lsls	r3, r3, #3
 293:Src/nvm.c     **** }
 1224              		.loc 1 293 1
 1225 0028 1846     		mov	r0, r3
 1226 002a 0C37     		adds	r7, r7, #12
 1227              	.LCFI33:
 1228              		.cfi_def_cfa_offset 4
 1229 002c BD46     		mov	sp, r7
 1230              	.LCFI34:
 1231              		.cfi_def_cfa_register 13
 1232              		@ sp needed
ARM GAS  /tmp/ccYYtTab.s 			page 28


 1233 002e 5DF8047B 		ldr	r7, [sp], #4
 1234              	.LCFI35:
 1235              		.cfi_restore 7
 1236              		.cfi_def_cfa_offset 0
 1237 0032 7047     		bx	lr
 1238              	.L50:
 1239              		.align	2
 1240              	.L49:
 1241 0034 00000000 		.word	read_sector_
 1242 0038 00000000 		.word	sectors
 1243              		.cfi_endproc
 1244              	.LFE138:
 1246              		.section	.text.NVM_read,"ax",%progbits
 1247              		.align	1
 1248              		.global	NVM_read
 1249              		.syntax unified
 1250              		.thumb
 1251              		.thumb_func
 1252              		.fpu fpv4-sp-d16
 1254              	NVM_read:
 1255              	.LFB139:
 294:Src/nvm.c     **** 
 295:Src/nvm.c     **** // @brief Reads from the latest committed block in the non-volatile memory.
 296:Src/nvm.c     **** // @param offset: offset in bytes (0 meaning the beginning of the valid area)
 297:Src/nvm.c     **** // @param data: buffer to write to
 298:Src/nvm.c     **** // @param length: length in bytes (if (offset + length) is out of range, the function fails)
 299:Src/nvm.c     **** // @returns 0 on success or a non-zero error code otherwise
 300:Src/nvm.c     **** int NVM_read(size_t offset, uint8_t *data, size_t length) {
 1256              		.loc 1 300 59
 1257              		.cfi_startproc
 1258              		@ args = 0, pretend = 0, frame = 24
 1259              		@ frame_needed = 1, uses_anonymous_args = 0
 1260 0000 80B5     		push	{r7, lr}
 1261              	.LCFI36:
 1262              		.cfi_def_cfa_offset 8
 1263              		.cfi_offset 7, -8
 1264              		.cfi_offset 14, -4
 1265 0002 86B0     		sub	sp, sp, #24
 1266              	.LCFI37:
 1267              		.cfi_def_cfa_offset 32
 1268 0004 00AF     		add	r7, sp, #0
 1269              	.LCFI38:
 1270              		.cfi_def_cfa_register 7
 1271 0006 F860     		str	r0, [r7, #12]
 1272 0008 B960     		str	r1, [r7, #8]
 1273 000a 7A60     		str	r2, [r7, #4]
 301:Src/nvm.c     ****     if (offset + length > (n_valid_ << 3))
 1274              		.loc 1 301 16
 1275 000c FA68     		ldr	r2, [r7, #12]
 1276 000e 7B68     		ldr	r3, [r7, #4]
 1277 0010 1A44     		add	r2, r2, r3
 1278              		.loc 1 301 37
 1279 0012 144B     		ldr	r3, .L54
 1280 0014 1B68     		ldr	r3, [r3]
 1281 0016 DB00     		lsls	r3, r3, #3
 1282              		.loc 1 301 8
 1283 0018 9A42     		cmp	r2, r3
ARM GAS  /tmp/ccYYtTab.s 			page 29


 1284 001a 02D9     		bls	.L52
 302:Src/nvm.c     ****         return -1;
 1285              		.loc 1 302 16
 1286 001c 4FF0FF33 		mov	r3, #-1
 1287 0020 1BE0     		b	.L53
 1288              	.L52:
 303:Src/nvm.c     ****     sector_t *read_sector = &sectors[read_sector_];
 1289              		.loc 1 303 37
 1290 0022 114B     		ldr	r3, .L54+4
 1291 0024 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1292 0026 1A46     		mov	r2, r3
 1293              		.loc 1 303 15
 1294 0028 1346     		mov	r3, r2
 1295 002a 5B00     		lsls	r3, r3, #1
 1296 002c 1344     		add	r3, r3, r2
 1297 002e DB00     		lsls	r3, r3, #3
 1298 0030 0E4A     		ldr	r2, .L54+8
 1299 0032 1344     		add	r3, r3, r2
 1300 0034 7B61     		str	r3, [r7, #20]
 304:Src/nvm.c     ****     const uint8_t *src_ptr = ((const uint8_t *)&read_sector->data[read_sector->index - n_valid_]) +
 1301              		.loc 1 304 60
 1302 0036 7B69     		ldr	r3, [r7, #20]
 1303 0038 5A69     		ldr	r2, [r3, #20]
 1304              		.loc 1 304 78
 1305 003a 7B69     		ldr	r3, [r7, #20]
 1306 003c 1968     		ldr	r1, [r3]
 1307              		.loc 1 304 86
 1308 003e 094B     		ldr	r3, .L54
 1309 0040 1B68     		ldr	r3, [r3]
 1310 0042 CB1A     		subs	r3, r1, r3
 1311              		.loc 1 304 66
 1312 0044 DB00     		lsls	r3, r3, #3
 1313              		.loc 1 304 48
 1314 0046 1A44     		add	r2, r2, r3
 1315              		.loc 1 304 20
 1316 0048 FB68     		ldr	r3, [r7, #12]
 1317 004a 1344     		add	r3, r3, r2
 1318 004c 3B61     		str	r3, [r7, #16]
 305:Src/nvm.c     ****     memcpy(data, src_ptr, length);
 1319              		.loc 1 305 5
 1320 004e 7A68     		ldr	r2, [r7, #4]
 1321 0050 3969     		ldr	r1, [r7, #16]
 1322 0052 B868     		ldr	r0, [r7, #8]
 1323 0054 FFF7FEFF 		bl	memcpy
 306:Src/nvm.c     ****     return 0;
 1324              		.loc 1 306 12
 1325 0058 0023     		movs	r3, #0
 1326              	.L53:
 307:Src/nvm.c     **** }
 1327              		.loc 1 307 1
 1328 005a 1846     		mov	r0, r3
 1329 005c 1837     		adds	r7, r7, #24
 1330              	.LCFI39:
 1331              		.cfi_def_cfa_offset 8
 1332 005e BD46     		mov	sp, r7
 1333              	.LCFI40:
 1334              		.cfi_def_cfa_register 13
ARM GAS  /tmp/ccYYtTab.s 			page 30


 1335              		@ sp needed
 1336 0060 80BD     		pop	{r7, pc}
 1337              	.L55:
 1338 0062 00BF     		.align	2
 1339              	.L54:
 1340 0064 00000000 		.word	n_valid_
 1341 0068 00000000 		.word	read_sector_
 1342 006c 00000000 		.word	sectors
 1343              		.cfi_endproc
 1344              	.LFE139:
 1346              		.section	.text.NVM_start_write,"ax",%progbits
 1347              		.align	1
 1348              		.global	NVM_start_write
 1349              		.syntax unified
 1350              		.thumb
 1351              		.thumb_func
 1352              		.fpu fpv4-sp-d16
 1354              	NVM_start_write:
 1355              	.LFB140:
 308:Src/nvm.c     **** 
 309:Src/nvm.c     **** // @brief Starts an atomic write operation.
 310:Src/nvm.c     **** //
 311:Src/nvm.c     **** // The most recent valid NVM data is not modified or invalidated until NVM_commit is called.
 312:Src/nvm.c     **** // The length must be at most equal to the size indicated by NVM_get_max_write_length().
 313:Src/nvm.c     **** //
 314:Src/nvm.c     **** // @param length: Length of the staging block that should be created
 315:Src/nvm.c     **** int NVM_start_write(size_t length) {
 1356              		.loc 1 315 36
 1357              		.cfi_startproc
 1358              		@ args = 0, pretend = 0, frame = 16
 1359              		@ frame_needed = 1, uses_anonymous_args = 0
 1360 0000 80B5     		push	{r7, lr}
 1361              	.LCFI41:
 1362              		.cfi_def_cfa_offset 8
 1363              		.cfi_offset 7, -8
 1364              		.cfi_offset 14, -4
 1365 0002 84B0     		sub	sp, sp, #16
 1366              	.LCFI42:
 1367              		.cfi_def_cfa_offset 24
 1368 0004 00AF     		add	r7, sp, #0
 1369              	.LCFI43:
 1370              		.cfi_def_cfa_register 7
 1371 0006 7860     		str	r0, [r7, #4]
 316:Src/nvm.c     ****     int status = 0;
 1372              		.loc 1 316 9
 1373 0008 0023     		movs	r3, #0
 1374 000a FB60     		str	r3, [r7, #12]
 317:Src/nvm.c     ****     sector_t *target = &sectors[1 - read_sector_];
 1375              		.loc 1 317 35
 1376 000c 1F4B     		ldr	r3, .L61
 1377 000e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1378 0010 C3F10102 		rsb	r2, r3, #1
 1379              		.loc 1 317 15
 1380 0014 1346     		mov	r3, r2
 1381 0016 5B00     		lsls	r3, r3, #1
 1382 0018 1344     		add	r3, r3, r2
 1383 001a DB00     		lsls	r3, r3, #3
ARM GAS  /tmp/ccYYtTab.s 			page 31


 1384 001c 1C4A     		ldr	r2, .L61+4
 1385 001e 1344     		add	r3, r3, r2
 1386 0020 BB60     		str	r3, [r7, #8]
 318:Src/nvm.c     **** 
 319:Src/nvm.c     ****     length = (length + 7) >> 3; // round to multiple of 64 bit
 1387              		.loc 1 319 22
 1388 0022 7B68     		ldr	r3, [r7, #4]
 1389 0024 0733     		adds	r3, r3, #7
 1390              		.loc 1 319 12
 1391 0026 DB08     		lsrs	r3, r3, #3
 1392 0028 7B60     		str	r3, [r7, #4]
 320:Src/nvm.c     ****     if (length > target->n_data - target->n_reserved)
 1393              		.loc 1 320 24
 1394 002a BB68     		ldr	r3, [r7, #8]
 1395 002c 9A68     		ldr	r2, [r3, #8]
 1396              		.loc 1 320 41
 1397 002e BB68     		ldr	r3, [r7, #8]
 1398 0030 DB68     		ldr	r3, [r3, #12]
 1399              		.loc 1 320 33
 1400 0032 D31A     		subs	r3, r2, r3
 1401              		.loc 1 320 8
 1402 0034 7A68     		ldr	r2, [r7, #4]
 1403 0036 9A42     		cmp	r2, r3
 1404 0038 02D9     		bls	.L57
 321:Src/nvm.c     ****         return -1;
 1405              		.loc 1 321 16
 1406 003a 4FF0FF33 		mov	r3, #-1
 1407 003e 21E0     		b	.L58
 1408              	.L57:
 322:Src/nvm.c     **** 
 323:Src/nvm.c     ****     // make room for the new data
 324:Src/nvm.c     ****     if (length > target->n_data - target->index)
 1409              		.loc 1 324 24
 1410 0040 BB68     		ldr	r3, [r7, #8]
 1411 0042 9A68     		ldr	r2, [r3, #8]
 1412              		.loc 1 324 41
 1413 0044 BB68     		ldr	r3, [r7, #8]
 1414 0046 1B68     		ldr	r3, [r3]
 1415              		.loc 1 324 33
 1416 0048 D31A     		subs	r3, r2, r3
 1417              		.loc 1 324 8
 1418 004a 7A68     		ldr	r2, [r7, #4]
 1419 004c 9A42     		cmp	r2, r3
 1420 004e 08D9     		bls	.L59
 325:Src/nvm.c     ****         if ((status = erase(target)))
 1421              		.loc 1 325 23
 1422 0050 B868     		ldr	r0, [r7, #8]
 1423 0052 FFF7FEFF 		bl	erase
 1424 0056 F860     		str	r0, [r7, #12]
 1425              		.loc 1 325 12
 1426 0058 FB68     		ldr	r3, [r7, #12]
 1427 005a 002B     		cmp	r3, #0
 1428 005c 01D0     		beq	.L59
 326:Src/nvm.c     ****             return status;
 1429              		.loc 1 326 20
 1430 005e FB68     		ldr	r3, [r7, #12]
 1431 0060 10E0     		b	.L58
ARM GAS  /tmp/ccYYtTab.s 			page 32


 1432              	.L59:
 327:Src/nvm.c     **** 
 328:Src/nvm.c     ****     // invalidate the fields we're about to write
 329:Src/nvm.c     ****     status = set_allocation_state(target, target->index, length, INVALID);
 1433              		.loc 1 329 14
 1434 0062 BB68     		ldr	r3, [r7, #8]
 1435 0064 1968     		ldr	r1, [r3]
 1436 0066 0123     		movs	r3, #1
 1437 0068 7A68     		ldr	r2, [r7, #4]
 1438 006a B868     		ldr	r0, [r7, #8]
 1439 006c FFF7FEFF 		bl	set_allocation_state
 1440 0070 F860     		str	r0, [r7, #12]
 330:Src/nvm.c     ****     if (status)
 1441              		.loc 1 330 8
 1442 0072 FB68     		ldr	r3, [r7, #12]
 1443 0074 002B     		cmp	r3, #0
 1444 0076 01D0     		beq	.L60
 331:Src/nvm.c     ****         return status;
 1445              		.loc 1 331 16
 1446 0078 FB68     		ldr	r3, [r7, #12]
 1447 007a 03E0     		b	.L58
 1448              	.L60:
 332:Src/nvm.c     **** 
 333:Src/nvm.c     ****     n_staging_area_ = length;
 1449              		.loc 1 333 21
 1450 007c 054A     		ldr	r2, .L61+8
 1451 007e 7B68     		ldr	r3, [r7, #4]
 1452 0080 1360     		str	r3, [r2]
 334:Src/nvm.c     ****     return 0;
 1453              		.loc 1 334 12
 1454 0082 0023     		movs	r3, #0
 1455              	.L58:
 335:Src/nvm.c     **** }
 1456              		.loc 1 335 1
 1457 0084 1846     		mov	r0, r3
 1458 0086 1037     		adds	r7, r7, #16
 1459              	.LCFI44:
 1460              		.cfi_def_cfa_offset 8
 1461 0088 BD46     		mov	sp, r7
 1462              	.LCFI45:
 1463              		.cfi_def_cfa_register 13
 1464              		@ sp needed
 1465 008a 80BD     		pop	{r7, pc}
 1466              	.L62:
 1467              		.align	2
 1468              	.L61:
 1469 008c 00000000 		.word	read_sector_
 1470 0090 00000000 		.word	sectors
 1471 0094 00000000 		.word	n_staging_area_
 1472              		.cfi_endproc
 1473              	.LFE140:
 1475              		.section	.text.NVM_write,"ax",%progbits
 1476              		.align	1
 1477              		.global	NVM_write
 1478              		.syntax unified
 1479              		.thumb
 1480              		.thumb_func
ARM GAS  /tmp/ccYYtTab.s 			page 33


 1481              		.fpu fpv4-sp-d16
 1483              	NVM_write:
 1484              	.LFB141:
 336:Src/nvm.c     **** 
 337:Src/nvm.c     **** // @brief Writes to the current data block that was opened with NVM_start_write.
 338:Src/nvm.c     **** //
 339:Src/nvm.c     **** // The operation fails if (offset + length) is larger than the length passed to NVM_start_write.
 340:Src/nvm.c     **** // The most recent valid NVM data is not modified or invalidated until NVM_commit is called.
 341:Src/nvm.c     **** // Warning: Writing different data to the same area multiple times during a single transaction
 342:Src/nvm.c     **** // will cause data corruption.
 343:Src/nvm.c     **** //
 344:Src/nvm.c     **** // @param offset: The offset in bytes, 0 being the beginning of the staging block.
 345:Src/nvm.c     **** // @param data: Pointer to the data that should be written
 346:Src/nvm.c     **** // @param length: Data length in bytes
 347:Src/nvm.c     **** int NVM_write(size_t offset, uint8_t *data, size_t length) {
 1485              		.loc 1 347 60
 1486              		.cfi_startproc
 1487              		@ args = 0, pretend = 0, frame = 24
 1488              		@ frame_needed = 1, uses_anonymous_args = 0
 1489 0000 80B5     		push	{r7, lr}
 1490              	.LCFI46:
 1491              		.cfi_def_cfa_offset 8
 1492              		.cfi_offset 7, -8
 1493              		.cfi_offset 14, -4
 1494 0002 86B0     		sub	sp, sp, #24
 1495              	.LCFI47:
 1496              		.cfi_def_cfa_offset 32
 1497 0004 00AF     		add	r7, sp, #0
 1498              	.LCFI48:
 1499              		.cfi_def_cfa_register 7
 1500 0006 F860     		str	r0, [r7, #12]
 1501 0008 B960     		str	r1, [r7, #8]
 1502 000a 7A60     		str	r2, [r7, #4]
 348:Src/nvm.c     ****     if (offset + length > (n_staging_area_ << 3))
 1503              		.loc 1 348 16
 1504 000c FA68     		ldr	r2, [r7, #12]
 1505 000e 7B68     		ldr	r3, [r7, #4]
 1506 0010 1A44     		add	r2, r2, r3
 1507              		.loc 1 348 44
 1508 0012 544B     		ldr	r3, .L81
 1509 0014 1B68     		ldr	r3, [r3]
 1510 0016 DB00     		lsls	r3, r3, #3
 1511              		.loc 1 348 8
 1512 0018 9A42     		cmp	r2, r3
 1513 001a 02D9     		bls	.L64
 349:Src/nvm.c     ****         return -1;
 1514              		.loc 1 349 16
 1515 001c 4FF0FF33 		mov	r3, #-1
 1516 0020 9CE0     		b	.L65
 1517              	.L64:
 350:Src/nvm.c     ****     sector_t *target = &sectors[1 - read_sector_];
 1518              		.loc 1 350 35
 1519 0022 514B     		ldr	r3, .L81+4
 1520 0024 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1521 0026 C3F10102 		rsb	r2, r3, #1
 1522              		.loc 1 350 15
 1523 002a 1346     		mov	r3, r2
ARM GAS  /tmp/ccYYtTab.s 			page 34


 1524 002c 5B00     		lsls	r3, r3, #1
 1525 002e 1344     		add	r3, r3, r2
 1526 0030 DB00     		lsls	r3, r3, #3
 1527 0032 4E4A     		ldr	r2, .L81+8
 1528 0034 1344     		add	r3, r3, r2
 1529 0036 7B61     		str	r3, [r7, #20]
 351:Src/nvm.c     **** 
 352:Src/nvm.c     ****     HAL_FLASH_Unlock();
 1530              		.loc 1 352 5
 1531 0038 FFF7FEFF 		bl	HAL_FLASH_Unlock
 353:Src/nvm.c     ****     HAL_FLASH_ClearError();
 1532              		.loc 1 353 5
 1533 003c 4C4B     		ldr	r3, .L81+12
 1534 003e 9B69     		ldr	r3, [r3, #24]
 1535 0040 4B4A     		ldr	r2, .L81+12
 1536 0042 43F04043 		orr	r3, r3, #-1073741824
 1537 0046 9361     		str	r3, [r2, #24]
 1538 0048 494B     		ldr	r3, .L81+12
 1539 004a 4CF2FA32 		movw	r2, #50170
 1540 004e 1A61     		str	r2, [r3, #16]
 354:Src/nvm.c     **** 
 355:Src/nvm.c     ****     // handle unaligned start
 356:Src/nvm.c     ****     // Handle unaligned start with doubleword writes
 357:Src/nvm.c     ****     for (; (offset & 0x7) && length; ++data, ++offset, --length)
 1541              		.loc 1 357 5
 1542 0050 1AE0     		b	.L66
 1543              	.L70:
 358:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 359:Src/nvm.c     ****                 ((uintptr_t)&target->data[target->index]) + offset, 
 1544              		.loc 1 359 36
 1545 0052 7B69     		ldr	r3, [r7, #20]
 1546 0054 5A69     		ldr	r2, [r3, #20]
 1547              		.loc 1 359 49
 1548 0056 7B69     		ldr	r3, [r7, #20]
 1549 0058 1B68     		ldr	r3, [r3]
 1550              		.loc 1 359 42
 1551 005a DB00     		lsls	r3, r3, #3
 1552              		.loc 1 359 29
 1553 005c 1344     		add	r3, r3, r2
 1554              		.loc 1 359 18
 1555 005e 1A46     		mov	r2, r3
 1556              		.loc 1 359 59
 1557 0060 FB68     		ldr	r3, [r7, #12]
 1558 0062 D118     		adds	r1, r2, r3
 358:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 1559              		.loc 1 358 13
 1560 0064 BB68     		ldr	r3, [r7, #8]
 1561 0066 D3E90023 		ldrd	r2, [r3]
 1562 006a 0020     		movs	r0, #0
 1563 006c FFF7FEFF 		bl	HAL_FLASH_Program
 1564 0070 0346     		mov	r3, r0
 358:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 1565              		.loc 1 358 12
 1566 0072 002B     		cmp	r3, #0
 1567 0074 68D1     		bne	.L78
 357:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 1568              		.loc 1 357 38
ARM GAS  /tmp/ccYYtTab.s 			page 35


 1569 0076 BB68     		ldr	r3, [r7, #8]
 1570 0078 0133     		adds	r3, r3, #1
 1571 007a BB60     		str	r3, [r7, #8]
 357:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 1572              		.loc 1 357 46
 1573 007c FB68     		ldr	r3, [r7, #12]
 1574 007e 0133     		adds	r3, r3, #1
 1575 0080 FB60     		str	r3, [r7, #12]
 357:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 1576              		.loc 1 357 56
 1577 0082 7B68     		ldr	r3, [r7, #4]
 1578 0084 013B     		subs	r3, r3, #1
 1579 0086 7B60     		str	r3, [r7, #4]
 1580              	.L66:
 357:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 1581              		.loc 1 357 20 discriminator 1
 1582 0088 FB68     		ldr	r3, [r7, #12]
 1583 008a 03F00703 		and	r3, r3, #7
 357:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 1584              		.loc 1 357 5 discriminator 1
 1585 008e 002B     		cmp	r3, #0
 1586 0090 34D0     		beq	.L71
 357:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 1587              		.loc 1 357 27 discriminator 2
 1588 0092 7B68     		ldr	r3, [r7, #4]
 1589 0094 002B     		cmp	r3, #0
 1590 0096 DCD1     		bne	.L70
 360:Src/nvm.c     ****                 *(uint64_t*)data) != HAL_OK)
 361:Src/nvm.c     ****             goto fail;
 362:Src/nvm.c     **** 
 363:Src/nvm.c     ****     // Write 32-bit values in fast mode
 364:Src/nvm.c     ****     for (; length >= 8; data += 8, offset += 8, length -= 8) {
 1591              		.loc 1 364 5
 1592 0098 30E0     		b	.L71
 1593              	.L74:
 365:Src/nvm.c     ****         if (length == 8) {
 1594              		.loc 1 365 12
 1595 009a 7B68     		ldr	r3, [r7, #4]
 1596 009c 082B     		cmp	r3, #8
 1597 009e 12D1     		bne	.L72
 366:Src/nvm.c     ****             // Last word uses FAST_AND_LAST
 367:Src/nvm.c     ****             if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_FAST_AND_LAST,
 368:Src/nvm.c     ****                     ((uintptr_t)&target->data[target->index]) + offset, 
 1598              		.loc 1 368 40
 1599 00a0 7B69     		ldr	r3, [r7, #20]
 1600 00a2 5A69     		ldr	r2, [r3, #20]
 1601              		.loc 1 368 53
 1602 00a4 7B69     		ldr	r3, [r7, #20]
 1603 00a6 1B68     		ldr	r3, [r3]
 1604              		.loc 1 368 46
 1605 00a8 DB00     		lsls	r3, r3, #3
 1606              		.loc 1 368 33
 1607 00aa 1344     		add	r3, r3, r2
 1608              		.loc 1 368 22
 1609 00ac 1A46     		mov	r2, r3
 1610              		.loc 1 368 63
 1611 00ae FB68     		ldr	r3, [r7, #12]
ARM GAS  /tmp/ccYYtTab.s 			page 36


 1612 00b0 D118     		adds	r1, r2, r3
 367:Src/nvm.c     ****                     ((uintptr_t)&target->data[target->index]) + offset, 
 1613              		.loc 1 367 17
 1614 00b2 BB68     		ldr	r3, [r7, #8]
 1615 00b4 D3E90023 		ldrd	r2, [r3]
 1616 00b8 0220     		movs	r0, #2
 1617 00ba FFF7FEFF 		bl	HAL_FLASH_Program
 1618 00be 0346     		mov	r3, r0
 367:Src/nvm.c     ****                     ((uintptr_t)&target->data[target->index]) + offset, 
 1619              		.loc 1 367 16
 1620 00c0 002B     		cmp	r3, #0
 1621 00c2 12D0     		beq	.L73
 369:Src/nvm.c     ****                     *(uint64_t*)data) != HAL_OK)
 370:Src/nvm.c     ****                 goto fail;
 1622              		.loc 1 370 17
 1623 00c4 45E0     		b	.L68
 1624              	.L72:
 371:Src/nvm.c     ****         } else {
 372:Src/nvm.c     ****             // Regular fast programming
 373:Src/nvm.c     ****             if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_FAST,
 374:Src/nvm.c     ****                     ((uintptr_t)&target->data[target->index]) + offset, 
 1625              		.loc 1 374 40
 1626 00c6 7B69     		ldr	r3, [r7, #20]
 1627 00c8 5A69     		ldr	r2, [r3, #20]
 1628              		.loc 1 374 53
 1629 00ca 7B69     		ldr	r3, [r7, #20]
 1630 00cc 1B68     		ldr	r3, [r3]
 1631              		.loc 1 374 46
 1632 00ce DB00     		lsls	r3, r3, #3
 1633              		.loc 1 374 33
 1634 00d0 1344     		add	r3, r3, r2
 1635              		.loc 1 374 22
 1636 00d2 1A46     		mov	r2, r3
 1637              		.loc 1 374 63
 1638 00d4 FB68     		ldr	r3, [r7, #12]
 1639 00d6 D118     		adds	r1, r2, r3
 373:Src/nvm.c     ****                     ((uintptr_t)&target->data[target->index]) + offset, 
 1640              		.loc 1 373 17
 1641 00d8 BB68     		ldr	r3, [r7, #8]
 1642 00da D3E90023 		ldrd	r2, [r3]
 1643 00de 0120     		movs	r0, #1
 1644 00e0 FFF7FEFF 		bl	HAL_FLASH_Program
 1645 00e4 0346     		mov	r3, r0
 373:Src/nvm.c     ****                     ((uintptr_t)&target->data[target->index]) + offset, 
 1646              		.loc 1 373 16
 1647 00e6 002B     		cmp	r3, #0
 1648 00e8 30D1     		bne	.L79
 1649              	.L73:
 364:Src/nvm.c     ****         if (length == 8) {
 1650              		.loc 1 364 30
 1651 00ea BB68     		ldr	r3, [r7, #8]
 1652 00ec 0833     		adds	r3, r3, #8
 1653 00ee BB60     		str	r3, [r7, #8]
 364:Src/nvm.c     ****         if (length == 8) {
 1654              		.loc 1 364 43
 1655 00f0 FB68     		ldr	r3, [r7, #12]
 1656 00f2 0833     		adds	r3, r3, #8
ARM GAS  /tmp/ccYYtTab.s 			page 37


 1657 00f4 FB60     		str	r3, [r7, #12]
 364:Src/nvm.c     ****         if (length == 8) {
 1658              		.loc 1 364 56
 1659 00f6 7B68     		ldr	r3, [r7, #4]
 1660 00f8 083B     		subs	r3, r3, #8
 1661 00fa 7B60     		str	r3, [r7, #4]
 1662              	.L71:
 364:Src/nvm.c     ****         if (length == 8) {
 1663              		.loc 1 364 5 discriminator 1
 1664 00fc 7B68     		ldr	r3, [r7, #4]
 1665 00fe 072B     		cmp	r3, #7
 1666 0100 CBD8     		bhi	.L74
 375:Src/nvm.c     ****                     *(uint64_t*)data) != HAL_OK)
 376:Src/nvm.c     ****                 goto fail;
 377:Src/nvm.c     ****         }
 378:Src/nvm.c     ****     }
 379:Src/nvm.c     **** 
 380:Src/nvm.c     ****     // Handle remaining bytes with doubleword writes
 381:Src/nvm.c     ****     for (; length; ++data, ++offset, --length)
 1667              		.loc 1 381 5
 1668 0102 1AE0     		b	.L75
 1669              	.L77:
 382:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 383:Src/nvm.c     ****                 ((uintptr_t)&target->data[target->index]) + offset, 
 1670              		.loc 1 383 36
 1671 0104 7B69     		ldr	r3, [r7, #20]
 1672 0106 5A69     		ldr	r2, [r3, #20]
 1673              		.loc 1 383 49
 1674 0108 7B69     		ldr	r3, [r7, #20]
 1675 010a 1B68     		ldr	r3, [r3]
 1676              		.loc 1 383 42
 1677 010c DB00     		lsls	r3, r3, #3
 1678              		.loc 1 383 29
 1679 010e 1344     		add	r3, r3, r2
 1680              		.loc 1 383 18
 1681 0110 1A46     		mov	r2, r3
 1682              		.loc 1 383 59
 1683 0112 FB68     		ldr	r3, [r7, #12]
 1684 0114 D118     		adds	r1, r2, r3
 382:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 1685              		.loc 1 382 13
 1686 0116 BB68     		ldr	r3, [r7, #8]
 1687 0118 D3E90023 		ldrd	r2, [r3]
 1688 011c 0020     		movs	r0, #0
 1689 011e FFF7FEFF 		bl	HAL_FLASH_Program
 1690 0122 0346     		mov	r3, r0
 382:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 1691              		.loc 1 382 12
 1692 0124 002B     		cmp	r3, #0
 1693 0126 13D1     		bne	.L80
 381:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 1694              		.loc 1 381 20
 1695 0128 BB68     		ldr	r3, [r7, #8]
 1696 012a 0133     		adds	r3, r3, #1
 1697 012c BB60     		str	r3, [r7, #8]
 381:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 1698              		.loc 1 381 28
ARM GAS  /tmp/ccYYtTab.s 			page 38


 1699 012e FB68     		ldr	r3, [r7, #12]
 1700 0130 0133     		adds	r3, r3, #1
 1701 0132 FB60     		str	r3, [r7, #12]
 381:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 1702              		.loc 1 381 38
 1703 0134 7B68     		ldr	r3, [r7, #4]
 1704 0136 013B     		subs	r3, r3, #1
 1705 0138 7B60     		str	r3, [r7, #4]
 1706              	.L75:
 381:Src/nvm.c     ****         if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 1707              		.loc 1 381 5 discriminator 1
 1708 013a 7B68     		ldr	r3, [r7, #4]
 1709 013c 002B     		cmp	r3, #0
 1710 013e E1D1     		bne	.L77
 384:Src/nvm.c     ****                 *(uint64_t*)data) != HAL_OK)
 385:Src/nvm.c     ****             goto fail;
 386:Src/nvm.c     **** 
 387:Src/nvm.c     **** 
 388:Src/nvm.c     ****     HAL_FLASH_Lock();
 1711              		.loc 1 388 5
 1712 0140 FFF7FEFF 		bl	HAL_FLASH_Lock
 389:Src/nvm.c     ****     return 0;
 1713              		.loc 1 389 12
 1714 0144 0023     		movs	r3, #0
 1715 0146 09E0     		b	.L65
 1716              	.L78:
 361:Src/nvm.c     **** 
 1717              		.loc 1 361 13
 1718 0148 00BF     		nop
 1719 014a 02E0     		b	.L68
 1720              	.L79:
 376:Src/nvm.c     ****         }
 1721              		.loc 1 376 17
 1722 014c 00BF     		nop
 1723 014e 00E0     		b	.L68
 1724              	.L80:
 385:Src/nvm.c     **** 
 1725              		.loc 1 385 13
 1726 0150 00BF     		nop
 1727              	.L68:
 390:Src/nvm.c     **** fail:
 391:Src/nvm.c     ****     HAL_FLASH_Lock();
 1728              		.loc 1 391 5
 1729 0152 FFF7FEFF 		bl	HAL_FLASH_Lock
 392:Src/nvm.c     ****     return HAL_FLASH_GetError(); // non-zero
 1730              		.loc 1 392 12
 1731 0156 FFF7FEFF 		bl	HAL_FLASH_GetError
 1732 015a 0346     		mov	r3, r0
 1733              	.L65:
 393:Src/nvm.c     **** }
 1734              		.loc 1 393 1
 1735 015c 1846     		mov	r0, r3
 1736 015e 1837     		adds	r7, r7, #24
 1737              	.LCFI49:
 1738              		.cfi_def_cfa_offset 8
 1739 0160 BD46     		mov	sp, r7
 1740              	.LCFI50:
ARM GAS  /tmp/ccYYtTab.s 			page 39


 1741              		.cfi_def_cfa_register 13
 1742              		@ sp needed
 1743 0162 80BD     		pop	{r7, pc}
 1744              	.L82:
 1745              		.align	2
 1746              	.L81:
 1747 0164 00000000 		.word	n_staging_area_
 1748 0168 00000000 		.word	read_sector_
 1749 016c 00000000 		.word	sectors
 1750 0170 00200240 		.word	1073881088
 1751              		.cfi_endproc
 1752              	.LFE141:
 1754              		.section	.text.NVM_commit,"ax",%progbits
 1755              		.align	1
 1756              		.global	NVM_commit
 1757              		.syntax unified
 1758              		.thumb
 1759              		.thumb_func
 1760              		.fpu fpv4-sp-d16
 1762              	NVM_commit:
 1763              	.LFB142:
 394:Src/nvm.c     **** 
 395:Src/nvm.c     **** // @brief Commits the new data to NVM atomically.
 396:Src/nvm.c     **** int NVM_commit(void) {
 1764              		.loc 1 396 22
 1765              		.cfi_startproc
 1766              		@ args = 0, pretend = 0, frame = 16
 1767              		@ frame_needed = 1, uses_anonymous_args = 0
 1768 0000 80B5     		push	{r7, lr}
 1769              	.LCFI51:
 1770              		.cfi_def_cfa_offset 8
 1771              		.cfi_offset 7, -8
 1772              		.cfi_offset 14, -4
 1773 0002 84B0     		sub	sp, sp, #16
 1774              	.LCFI52:
 1775              		.cfi_def_cfa_offset 24
 1776 0004 00AF     		add	r7, sp, #0
 1777              	.LCFI53:
 1778              		.cfi_def_cfa_register 7
 397:Src/nvm.c     ****     sector_t *read_sector = &sectors[read_sector_];
 1779              		.loc 1 397 37
 1780 0006 2A4B     		ldr	r3, .L88
 1781 0008 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1782 000a 1A46     		mov	r2, r3
 1783              		.loc 1 397 15
 1784 000c 1346     		mov	r3, r2
 1785 000e 5B00     		lsls	r3, r3, #1
 1786 0010 1344     		add	r3, r3, r2
 1787 0012 DB00     		lsls	r3, r3, #3
 1788 0014 274A     		ldr	r2, .L88+4
 1789 0016 1344     		add	r3, r3, r2
 1790 0018 BB60     		str	r3, [r7, #8]
 398:Src/nvm.c     ****     sector_t *write_sector = &sectors[1 - read_sector_];
 1791              		.loc 1 398 41
 1792 001a 254B     		ldr	r3, .L88
 1793 001c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1794 001e C3F10102 		rsb	r2, r3, #1
ARM GAS  /tmp/ccYYtTab.s 			page 40


 1795              		.loc 1 398 15
 1796 0022 1346     		mov	r3, r2
 1797 0024 5B00     		lsls	r3, r3, #1
 1798 0026 1344     		add	r3, r3, r2
 1799 0028 DB00     		lsls	r3, r3, #3
 1800 002a 224A     		ldr	r2, .L88+4
 1801 002c 1344     		add	r3, r3, r2
 1802 002e 7B60     		str	r3, [r7, #4]
 399:Src/nvm.c     **** 
 400:Src/nvm.c     ****     // mark the newly-written fields as valid
 401:Src/nvm.c     ****     int status = set_allocation_state(write_sector, write_sector->index, n_staging_area_, VALID);
 1803              		.loc 1 401 18
 1804 0030 7B68     		ldr	r3, [r7, #4]
 1805 0032 1968     		ldr	r1, [r3]
 1806 0034 204B     		ldr	r3, .L88+8
 1807 0036 1A68     		ldr	r2, [r3]
 1808 0038 0023     		movs	r3, #0
 1809 003a 7868     		ldr	r0, [r7, #4]
 1810 003c FFF7FEFF 		bl	set_allocation_state
 1811 0040 F860     		str	r0, [r7, #12]
 402:Src/nvm.c     ****     if (status)
 1812              		.loc 1 402 8
 1813 0042 FB68     		ldr	r3, [r7, #12]
 1814 0044 002B     		cmp	r3, #0
 1815 0046 01D0     		beq	.L84
 403:Src/nvm.c     ****         return status;
 1816              		.loc 1 403 16
 1817 0048 FB68     		ldr	r3, [r7, #12]
 1818 004a 2DE0     		b	.L85
 1819              	.L84:
 404:Src/nvm.c     **** 
 405:Src/nvm.c     ****     write_sector->index += n_staging_area_;
 1820              		.loc 1 405 25
 1821 004c 7B68     		ldr	r3, [r7, #4]
 1822 004e 1A68     		ldr	r2, [r3]
 1823 0050 194B     		ldr	r3, .L88+8
 1824 0052 1B68     		ldr	r3, [r3]
 1825 0054 1A44     		add	r2, r2, r3
 1826 0056 7B68     		ldr	r3, [r7, #4]
 1827 0058 1A60     		str	r2, [r3]
 406:Src/nvm.c     ****     n_valid_ = n_staging_area_;
 1828              		.loc 1 406 14
 1829 005a 174B     		ldr	r3, .L88+8
 1830 005c 1B68     		ldr	r3, [r3]
 1831 005e 174A     		ldr	r2, .L88+12
 1832 0060 1360     		str	r3, [r2]
 407:Src/nvm.c     ****     n_staging_area_ = 0;
 1833              		.loc 1 407 21
 1834 0062 154B     		ldr	r3, .L88+8
 1835 0064 0022     		movs	r2, #0
 1836 0066 1A60     		str	r2, [r3]
 408:Src/nvm.c     ****     read_sector_ = 1 - read_sector_;
 1837              		.loc 1 408 22
 1838 0068 114B     		ldr	r3, .L88
 1839 006a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1840 006c C3F10103 		rsb	r3, r3, #1
 1841 0070 DAB2     		uxtb	r2, r3
ARM GAS  /tmp/ccYYtTab.s 			page 41


 1842              		.loc 1 408 18
 1843 0072 0F4B     		ldr	r3, .L88
 1844 0074 1A70     		strb	r2, [r3]
 409:Src/nvm.c     **** 
 410:Src/nvm.c     ****     // invalidate the other sector
 411:Src/nvm.c     ****     if (read_sector->index < read_sector->n_data) {
 1845              		.loc 1 411 20
 1846 0076 BB68     		ldr	r3, [r7, #8]
 1847 0078 1A68     		ldr	r2, [r3]
 1848              		.loc 1 411 41
 1849 007a BB68     		ldr	r3, [r7, #8]
 1850 007c 9B68     		ldr	r3, [r3, #8]
 1851              		.loc 1 411 8
 1852 007e 9A42     		cmp	r2, r3
 1853 0080 0DD2     		bcs	.L86
 412:Src/nvm.c     ****         status = set_allocation_state(read_sector, read_sector->index, 1, INVALID);
 1854              		.loc 1 412 18
 1855 0082 BB68     		ldr	r3, [r7, #8]
 1856 0084 1968     		ldr	r1, [r3]
 1857 0086 0123     		movs	r3, #1
 1858 0088 0122     		movs	r2, #1
 1859 008a B868     		ldr	r0, [r7, #8]
 1860 008c FFF7FEFF 		bl	set_allocation_state
 1861 0090 F860     		str	r0, [r7, #12]
 413:Src/nvm.c     ****         read_sector->index += 1;
 1862              		.loc 1 413 28
 1863 0092 BB68     		ldr	r3, [r7, #8]
 1864 0094 1B68     		ldr	r3, [r3]
 1865 0096 5A1C     		adds	r2, r3, #1
 1866 0098 BB68     		ldr	r3, [r7, #8]
 1867 009a 1A60     		str	r2, [r3]
 1868 009c 03E0     		b	.L87
 1869              	.L86:
 414:Src/nvm.c     ****     } else {
 415:Src/nvm.c     ****         status = erase(read_sector);
 1870              		.loc 1 415 18
 1871 009e B868     		ldr	r0, [r7, #8]
 1872 00a0 FFF7FEFF 		bl	erase
 1873 00a4 F860     		str	r0, [r7, #12]
 1874              	.L87:
 416:Src/nvm.c     ****     }
 417:Src/nvm.c     **** 
 418:Src/nvm.c     ****     return status;
 1875              		.loc 1 418 12
 1876 00a6 FB68     		ldr	r3, [r7, #12]
 1877              	.L85:
 419:Src/nvm.c     **** }
 1878              		.loc 1 419 1
 1879 00a8 1846     		mov	r0, r3
 1880 00aa 1037     		adds	r7, r7, #16
 1881              	.LCFI54:
 1882              		.cfi_def_cfa_offset 8
 1883 00ac BD46     		mov	sp, r7
 1884              	.LCFI55:
 1885              		.cfi_def_cfa_register 13
 1886              		@ sp needed
 1887 00ae 80BD     		pop	{r7, pc}
ARM GAS  /tmp/ccYYtTab.s 			page 42


 1888              	.L89:
 1889              		.align	2
 1890              	.L88:
 1891 00b0 00000000 		.word	read_sector_
 1892 00b4 00000000 		.word	sectors
 1893 00b8 00000000 		.word	n_staging_area_
 1894 00bc 00000000 		.word	n_valid_
 1895              		.cfi_endproc
 1896              	.LFE142:
 1898              		.section	.rodata
 1899              		.align	2
 1900              	.LC0:
 1901 0000 3D3D3D20 		.ascii	"=== NVM TEST ===\015\000"
 1901      4E564D20 
 1901      54455354 
 1901      203D3D3D 
 1901      0D00
 1902 0012 0000     		.align	2
 1903              	.LC1:
 1904 0014 4E564D20 		.ascii	"NVM contains %d valid bytes:\015\012\000"
 1904      636F6E74 
 1904      61696E73 
 1904      20256420 
 1904      76616C69 
 1905 0033 00       		.align	2
 1906              	.LC2:
 1907 0034 20253032 		.ascii	" %02x\000"
 1907      7800
 1908 003a 0000     		.align	2
 1909              	.LC3:
 1910 003c 0D00     		.ascii	"\015\000"
 1911 003e 0000     		.align	2
 1912              	.LC4:
 1913 0040 4E564D20 		.ascii	"NVM is empty\015\000"
 1913      69732065 
 1913      6D707479 
 1913      0D00
 1914 004e 0000     		.align	2
 1915              	.LC5:
 1916 0050 77726974 		.ascii	"write 0x%02x, ..., 0x%02x to NVM\015\012\000"
 1916      65203078 
 1916      25303278 
 1916      2C202E2E 
 1916      2E2C2030 
 1917 0073 00       		.align	2
 1918              	.LC6:
 1919 0074 6E657720 		.ascii	"new data committed to NVM\015\000"
 1919      64617461 
 1919      20636F6D 
 1919      6D697474 
 1919      65642074 
 1920 008f 00       		.align	2
 1921              	.LC7:
 1922 0090 4E564D20 		.ascii	"NVM test failed at %d!\015\012\000"
 1922      74657374 
 1922      20666169 
 1922      6C656420 
ARM GAS  /tmp/ccYYtTab.s 			page 43


 1922      61742025 
 1923              		.section	.text.NVM_demo,"ax",%progbits
 1924              		.align	1
 1925              		.global	NVM_demo
 1926              		.syntax unified
 1927              		.thumb
 1928              		.thumb_func
 1929              		.fpu fpv4-sp-d16
 1931              	NVM_demo:
 1932              	.LFB148:
 420:Src/nvm.c     **** 
 421:Src/nvm.c     **** 
 422:Src/nvm.c     **** #include <cmsis_os.h>
 423:Src/nvm.c     **** /** @brief Call this at startup to test/demo the NVM driver
 424:Src/nvm.c     **** 
 425:Src/nvm.c     ****  Expected output when starting with a fully erased NVM
 426:Src/nvm.c     **** 
 427:Src/nvm.c     ****     [1st boot]
 428:Src/nvm.c     ****     === NVM TEST ===
 429:Src/nvm.c     ****     NVM is empty
 430:Src/nvm.c     ****     write 0x00, ..., 0x25 to NVM
 431:Src/nvm.c     ****     new data committed to NVM
 432:Src/nvm.c     ****     
 433:Src/nvm.c     ****     [2nd boot]
 434:Src/nvm.c     ****     === NVM TEST ===
 435:Src/nvm.c     ****     NVM contains 40 valid bytes:
 436:Src/nvm.c     ****     00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f
 437:Src/nvm.c     ****     10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f
 438:Src/nvm.c     ****     20 21 22 23 24 25 ff ff
 439:Src/nvm.c     ****     write 0xbd, ..., 0xe2 to NVM
 440:Src/nvm.c     ****     new data committed to NVM
 441:Src/nvm.c     **** 
 442:Src/nvm.c     ****     [3rd boot]
 443:Src/nvm.c     ****     === NVM TEST ===
 444:Src/nvm.c     ****     NVM contains 40 valid bytes:
 445:Src/nvm.c     ****     bd be bf c0 c1 c2 c3 c4 c5 c6 c7 c8 c9 ca cb cc
 446:Src/nvm.c     ****     cd ce cf d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 da db dc
 447:Src/nvm.c     ****     dd de df e0 e1 e2 ff ff
 448:Src/nvm.c     ****     write 0xcb, ..., 0xf0 to NVM
 449:Src/nvm.c     ****     new data committed to NVM
 450:Src/nvm.c     **** */
 451:Src/nvm.c     **** void NVM_demo(void) {
 1933              		.loc 1 451 21
 1934              		.cfi_startproc
 1935              		@ args = 0, pretend = 0, frame = 40
 1936              		@ frame_needed = 1, uses_anonymous_args = 0
 1937 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1938              	.LCFI56:
 1939              		.cfi_def_cfa_offset 36
 1940              		.cfi_offset 4, -36
 1941              		.cfi_offset 5, -32
 1942              		.cfi_offset 6, -28
 1943              		.cfi_offset 7, -24
 1944              		.cfi_offset 8, -20
 1945              		.cfi_offset 9, -16
 1946              		.cfi_offset 10, -12
 1947              		.cfi_offset 11, -8
ARM GAS  /tmp/ccYYtTab.s 			page 44


 1948              		.cfi_offset 14, -4
 1949 0004 8BB0     		sub	sp, sp, #44
 1950              	.LCFI57:
 1951              		.cfi_def_cfa_offset 80
 1952 0006 00AF     		add	r7, sp, #0
 1953              	.LCFI58:
 1954              		.cfi_def_cfa_register 7
 1955              		.loc 1 451 21
 1956 0008 6B46     		mov	r3, sp
 1957 000a 1E46     		mov	r6, r3
 452:Src/nvm.c     ****     const size_t len = 38;
 1958              		.loc 1 452 18
 1959 000c 2623     		movs	r3, #38
 1960 000e 7B61     		str	r3, [r7, #20]
 453:Src/nvm.c     ****     uint8_t data[len];
 1961              		.loc 1 453 13
 1962 0010 7B69     		ldr	r3, [r7, #20]
 1963 0012 013B     		subs	r3, r3, #1
 1964 0014 3B61     		str	r3, [r7, #16]
 1965 0016 7B69     		ldr	r3, [r7, #20]
 1966 0018 0022     		movs	r2, #0
 1967 001a 9A46     		mov	r10, r3
 1968 001c 9346     		mov	fp, r2
 1969 001e 4FF00002 		mov	r2, #0
 1970 0022 4FF00003 		mov	r3, #0
 1971 0026 4FEACB03 		lsl	r3, fp, #3
 1972 002a 43EA5A73 		orr	r3, r3, r10, lsr #29
 1973 002e 4FEACA02 		lsl	r2, r10, #3
 1974 0032 7B69     		ldr	r3, [r7, #20]
 1975 0034 0022     		movs	r2, #0
 1976 0036 1846     		mov	r0, r3
 1977 0038 1146     		mov	r1, r2
 1978 003a 4FF00002 		mov	r2, #0
 1979 003e 4FF00003 		mov	r3, #0
 1980 0042 CB00     		lsls	r3, r1, #3
 1981 0044 43EA5073 		orr	r3, r3, r0, lsr #29
 1982 0048 C200     		lsls	r2, r0, #3
 1983 004a 7B69     		ldr	r3, [r7, #20]
 1984 004c 0733     		adds	r3, r3, #7
 1985 004e DB08     		lsrs	r3, r3, #3
 1986 0050 DB00     		lsls	r3, r3, #3
 1987 0052 ADEB030D 		sub	sp, sp, r3
 1988 0056 6B46     		mov	r3, sp
 1989 0058 0033     		adds	r3, r3, #0
 1990 005a FB60     		str	r3, [r7, #12]
 454:Src/nvm.c     ****     int progress = 0;
 1991              		.loc 1 454 9
 1992 005c 0023     		movs	r3, #0
 1993 005e FB61     		str	r3, [r7, #28]
 455:Src/nvm.c     ****     uint8_t seed = 0;
 1994              		.loc 1 455 13
 1995 0060 0023     		movs	r3, #0
 1996 0062 87F82330 		strb	r3, [r7, #35]
 456:Src/nvm.c     **** 
 457:Src/nvm.c     ****     osDelay(100);
 1997              		.loc 1 457 5
 1998 0066 6420     		movs	r0, #100
ARM GAS  /tmp/ccYYtTab.s 			page 45


 1999 0068 FFF7FEFF 		bl	osDelay
 458:Src/nvm.c     ****     printf("=== NVM TEST ===\r\n"); osDelay(5);
 2000              		.loc 1 458 5
 2001 006c 7748     		ldr	r0, .L113
 2002 006e FFF7FEFF 		bl	puts
 2003              		.loc 1 458 37
 2004 0072 0520     		movs	r0, #5
 2005 0074 FFF7FEFF 		bl	osDelay
 459:Src/nvm.c     ****     //NVM_erase();
 460:Src/nvm.c     ****     if (progress++, NVM_init() != 0)
 2006              		.loc 1 460 17
 2007 0078 FB69     		ldr	r3, [r7, #28]
 2008 007a 0133     		adds	r3, r3, #1
 2009 007c FB61     		str	r3, [r7, #28]
 2010              		.loc 1 460 21
 2011 007e FFF7FEFF 		bl	NVM_init
 2012 0082 0346     		mov	r3, r0
 2013              		.loc 1 460 8
 2014 0084 002B     		cmp	r3, #0
 2015 0086 40F0CF80 		bne	.L108
 461:Src/nvm.c     ****         goto fail;
 462:Src/nvm.c     ****     
 463:Src/nvm.c     ****     // load bytes from NVM and print them
 464:Src/nvm.c     ****     size_t available = NVM_get_max_read_length();
 2016              		.loc 1 464 24
 2017 008a FFF7FEFF 		bl	NVM_get_max_read_length
 2018 008e B860     		str	r0, [r7, #8]
 465:Src/nvm.c     ****     if (available) {
 2019              		.loc 1 465 8
 2020 0090 BB68     		ldr	r3, [r7, #8]
 2021 0092 002B     		cmp	r3, #0
 2022 0094 67D0     		beq	.L93
 2023              	.LBB3:
 2024              		.loc 1 465 20 discriminator 1
 2025 0096 6B46     		mov	r3, sp
 2026 0098 9A46     		mov	r10, r3
 466:Src/nvm.c     ****         printf("NVM contains %d valid bytes:\r\n", available); osDelay(5);
 2027              		.loc 1 466 9 discriminator 1
 2028 009a B968     		ldr	r1, [r7, #8]
 2029 009c 6C48     		ldr	r0, .L113+4
 2030 009e FFF7FEFF 		bl	printf
 2031              		.loc 1 466 64 discriminator 1
 2032 00a2 0520     		movs	r0, #5
 2033 00a4 FFF7FEFF 		bl	osDelay
 467:Src/nvm.c     ****         uint8_t buf[available];
 2034              		.loc 1 467 9 discriminator 1
 2035 00a8 B968     		ldr	r1, [r7, #8]
 2036              		.loc 1 467 17 discriminator 1
 2037 00aa 0B46     		mov	r3, r1
 2038 00ac 013B     		subs	r3, r3, #1
 2039 00ae 7B60     		str	r3, [r7, #4]
 2040 00b0 0023     		movs	r3, #0
 2041 00b2 8846     		mov	r8, r1
 2042 00b4 9946     		mov	r9, r3
 2043 00b6 4FF00002 		mov	r2, #0
 2044 00ba 4FF00003 		mov	r3, #0
 2045 00be 4FEAC903 		lsl	r3, r9, #3
ARM GAS  /tmp/ccYYtTab.s 			page 46


 2046 00c2 43EA5873 		orr	r3, r3, r8, lsr #29
 2047 00c6 4FEAC802 		lsl	r2, r8, #3
 2048 00ca 0023     		movs	r3, #0
 2049 00cc 0C46     		mov	r4, r1
 2050 00ce 1D46     		mov	r5, r3
 2051 00d0 4FF00002 		mov	r2, #0
 2052 00d4 4FF00003 		mov	r3, #0
 2053 00d8 EB00     		lsls	r3, r5, #3
 2054 00da 43EA5473 		orr	r3, r3, r4, lsr #29
 2055 00de E200     		lsls	r2, r4, #3
 2056 00e0 CB1D     		adds	r3, r1, #7
 2057 00e2 DB08     		lsrs	r3, r3, #3
 2058 00e4 DB00     		lsls	r3, r3, #3
 2059 00e6 ADEB030D 		sub	sp, sp, r3
 2060 00ea 6B46     		mov	r3, sp
 2061 00ec 0033     		adds	r3, r3, #0
 2062 00ee 3B60     		str	r3, [r7]
 468:Src/nvm.c     ****         if (progress++, NVM_read(0, buf, available) != 0)
 2063              		.loc 1 468 21 discriminator 1
 2064 00f0 FB69     		ldr	r3, [r7, #28]
 2065 00f2 0133     		adds	r3, r3, #1
 2066 00f4 FB61     		str	r3, [r7, #28]
 2067              		.loc 1 468 25 discriminator 1
 2068 00f6 BA68     		ldr	r2, [r7, #8]
 2069 00f8 3968     		ldr	r1, [r7]
 2070 00fa 0020     		movs	r0, #0
 2071 00fc FFF7FEFF 		bl	NVM_read
 2072 0100 0346     		mov	r3, r0
 2073              		.loc 1 468 12 discriminator 1
 2074 0102 002B     		cmp	r3, #0
 2075 0104 01D0     		beq	.L94
 2076 0106 D546     		mov	sp, r10
 2077 0108 97E0     		b	.L92
 2078              	.L94:
 2079              	.LBB4:
 469:Src/nvm.c     ****             goto fail;
 470:Src/nvm.c     ****         for (size_t pos = 0; pos < available; ++pos) {
 2080              		.loc 1 470 21
 2081 010a 0023     		movs	r3, #0
 2082 010c 7B62     		str	r3, [r7, #36]
 2083              		.loc 1 470 9
 2084 010e 24E0     		b	.L95
 2085              	.L98:
 471:Src/nvm.c     ****             seed += buf[pos];
 2086              		.loc 1 471 24
 2087 0110 3A68     		ldr	r2, [r7]
 2088 0112 7B6A     		ldr	r3, [r7, #36]
 2089 0114 1344     		add	r3, r3, r2
 2090 0116 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 2091              		.loc 1 471 18
 2092 0118 97F82330 		ldrb	r3, [r7, #35]
 2093 011c 1344     		add	r3, r3, r2
 2094 011e 87F82330 		strb	r3, [r7, #35]
 472:Src/nvm.c     ****             printf(" %02x", buf[pos]);
 2095              		.loc 1 472 32
 2096 0122 3A68     		ldr	r2, [r7]
 2097 0124 7B6A     		ldr	r3, [r7, #36]
ARM GAS  /tmp/ccYYtTab.s 			page 47


 2098 0126 1344     		add	r3, r3, r2
 2099 0128 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2100              		.loc 1 472 13
 2101 012a 1946     		mov	r1, r3
 2102 012c 4948     		ldr	r0, .L113+8
 2103 012e FFF7FEFF 		bl	printf
 473:Src/nvm.c     ****             if ((((pos + 1) % 16) == 0) || ((pos + 1) == available))
 2104              		.loc 1 473 24
 2105 0132 7B6A     		ldr	r3, [r7, #36]
 2106 0134 0133     		adds	r3, r3, #1
 2107              		.loc 1 473 29
 2108 0136 03F00F03 		and	r3, r3, #15
 2109              		.loc 1 473 16
 2110 013a 002B     		cmp	r3, #0
 2111 013c 04D0     		beq	.L96
 2112              		.loc 1 473 50 discriminator 1
 2113 013e 7B6A     		ldr	r3, [r7, #36]
 2114 0140 0133     		adds	r3, r3, #1
 2115              		.loc 1 473 41 discriminator 1
 2116 0142 BA68     		ldr	r2, [r7, #8]
 2117 0144 9A42     		cmp	r2, r3
 2118 0146 02D1     		bne	.L97
 2119              	.L96:
 474:Src/nvm.c     ****                 printf("\r\n");
 2120              		.loc 1 474 17
 2121 0148 4348     		ldr	r0, .L113+12
 2122 014a FFF7FEFF 		bl	puts
 2123              	.L97:
 475:Src/nvm.c     ****             osDelay(2);
 2124              		.loc 1 475 13 discriminator 2
 2125 014e 0220     		movs	r0, #2
 2126 0150 FFF7FEFF 		bl	osDelay
 470:Src/nvm.c     ****             seed += buf[pos];
 2127              		.loc 1 470 47 discriminator 2
 2128 0154 7B6A     		ldr	r3, [r7, #36]
 2129 0156 0133     		adds	r3, r3, #1
 2130 0158 7B62     		str	r3, [r7, #36]
 2131              	.L95:
 470:Src/nvm.c     ****             seed += buf[pos];
 2132              		.loc 1 470 9 discriminator 1
 2133 015a 7A6A     		ldr	r2, [r7, #36]
 2134 015c BB68     		ldr	r3, [r7, #8]
 2135 015e 9A42     		cmp	r2, r3
 2136 0160 D6D3     		bcc	.L98
 2137 0162 D546     		mov	sp, r10
 2138              	.LBE4:
 2139 0164 05E0     		b	.L99
 2140              	.L93:
 2141              	.LBE3:
 476:Src/nvm.c     ****         }
 477:Src/nvm.c     ****     } else {
 478:Src/nvm.c     ****         printf("NVM is empty\r\n"); osDelay(5);
 2142              		.loc 1 478 9
 2143 0166 3D48     		ldr	r0, .L113+16
 2144 0168 FFF7FEFF 		bl	puts
 2145              		.loc 1 478 37
 2146 016c 0520     		movs	r0, #5
ARM GAS  /tmp/ccYYtTab.s 			page 48


 2147 016e FFF7FEFF 		bl	osDelay
 2148              	.L99:
 479:Src/nvm.c     ****     }
 480:Src/nvm.c     **** 
 481:Src/nvm.c     ****     // store new bytes in NVM (data based on seed)
 482:Src/nvm.c     ****     printf("write 0x%02x, ..., 0x%02x to NVM\r\n", seed, seed + len - 1); osDelay(5);
 2149              		.loc 1 482 5
 2150 0172 97F82310 		ldrb	r1, [r7, #35]	@ zero_extendqisi2
 2151              		.loc 1 482 63
 2152 0176 97F82320 		ldrb	r2, [r7, #35]	@ zero_extendqisi2
 2153 017a 7B69     		ldr	r3, [r7, #20]
 2154 017c 1344     		add	r3, r3, r2
 2155              		.loc 1 482 5
 2156 017e 013B     		subs	r3, r3, #1
 2157 0180 1A46     		mov	r2, r3
 2158 0182 3748     		ldr	r0, .L113+20
 2159 0184 FFF7FEFF 		bl	printf
 2160              		.loc 1 482 75
 2161 0188 0520     		movs	r0, #5
 2162 018a FFF7FEFF 		bl	osDelay
 2163              	.LBB5:
 483:Src/nvm.c     ****     for (size_t i = 0; i < len; i++)
 2164              		.loc 1 483 17
 2165 018e 0023     		movs	r3, #0
 2166 0190 BB61     		str	r3, [r7, #24]
 2167              		.loc 1 483 5
 2168 0192 0BE0     		b	.L100
 2169              	.L101:
 484:Src/nvm.c     ****         data[i] = seed++;
 2170              		.loc 1 484 23 discriminator 3
 2171 0194 97F82330 		ldrb	r3, [r7, #35]	@ zero_extendqisi2
 2172 0198 5A1C     		adds	r2, r3, #1
 2173 019a 87F82320 		strb	r2, [r7, #35]
 2174              		.loc 1 484 17 discriminator 3
 2175 019e F968     		ldr	r1, [r7, #12]
 2176 01a0 BA69     		ldr	r2, [r7, #24]
 2177 01a2 0A44     		add	r2, r2, r1
 2178 01a4 1370     		strb	r3, [r2]
 483:Src/nvm.c     ****     for (size_t i = 0; i < len; i++)
 2179              		.loc 1 483 34 discriminator 3
 2180 01a6 BB69     		ldr	r3, [r7, #24]
 2181 01a8 0133     		adds	r3, r3, #1
 2182 01aa BB61     		str	r3, [r7, #24]
 2183              	.L100:
 483:Src/nvm.c     ****     for (size_t i = 0; i < len; i++)
 2184              		.loc 1 483 5 discriminator 1
 2185 01ac BA69     		ldr	r2, [r7, #24]
 2186 01ae 7B69     		ldr	r3, [r7, #20]
 2187 01b0 9A42     		cmp	r2, r3
 2188 01b2 EFD3     		bcc	.L101
 2189              	.LBE5:
 485:Src/nvm.c     ****     if (progress++, NVM_start_write(len) != 0)
 2190              		.loc 1 485 17
 2191 01b4 FB69     		ldr	r3, [r7, #28]
 2192 01b6 0133     		adds	r3, r3, #1
 2193 01b8 FB61     		str	r3, [r7, #28]
 2194              		.loc 1 485 21
ARM GAS  /tmp/ccYYtTab.s 			page 49


 2195 01ba 7869     		ldr	r0, [r7, #20]
 2196 01bc FFF7FEFF 		bl	NVM_start_write
 2197 01c0 0346     		mov	r3, r0
 2198              		.loc 1 485 8
 2199 01c2 002B     		cmp	r3, #0
 2200 01c4 32D1     		bne	.L109
 486:Src/nvm.c     ****         goto fail;
 487:Src/nvm.c     ****     if (progress++, NVM_write(0, data, len / 2))
 2201              		.loc 1 487 17
 2202 01c6 FB69     		ldr	r3, [r7, #28]
 2203 01c8 0133     		adds	r3, r3, #1
 2204 01ca FB61     		str	r3, [r7, #28]
 2205              		.loc 1 487 21
 2206 01cc 7B69     		ldr	r3, [r7, #20]
 2207 01ce 5B08     		lsrs	r3, r3, #1
 2208 01d0 1A46     		mov	r2, r3
 2209 01d2 F968     		ldr	r1, [r7, #12]
 2210 01d4 0020     		movs	r0, #0
 2211 01d6 FFF7FEFF 		bl	NVM_write
 2212 01da 0346     		mov	r3, r0
 2213              		.loc 1 487 8
 2214 01dc 002B     		cmp	r3, #0
 2215 01de 27D1     		bne	.L110
 488:Src/nvm.c     ****         goto fail;
 489:Src/nvm.c     ****     if (progress++, NVM_write(len / 2, &data[len / 2], len - (len / 2)))
 2216              		.loc 1 489 17
 2217 01e0 FB69     		ldr	r3, [r7, #28]
 2218 01e2 0133     		adds	r3, r3, #1
 2219 01e4 FB61     		str	r3, [r7, #28]
 2220              		.loc 1 489 21
 2221 01e6 7B69     		ldr	r3, [r7, #20]
 2222 01e8 5808     		lsrs	r0, r3, #1
 2223              		.loc 1 489 50
 2224 01ea 7B69     		ldr	r3, [r7, #20]
 2225 01ec 5B08     		lsrs	r3, r3, #1
 2226              		.loc 1 489 21
 2227 01ee FA68     		ldr	r2, [r7, #12]
 2228 01f0 D118     		adds	r1, r2, r3
 2229              		.loc 1 489 67
 2230 01f2 7B69     		ldr	r3, [r7, #20]
 2231 01f4 5B08     		lsrs	r3, r3, #1
 2232              		.loc 1 489 21
 2233 01f6 7A69     		ldr	r2, [r7, #20]
 2234 01f8 D31A     		subs	r3, r2, r3
 2235 01fa 1A46     		mov	r2, r3
 2236 01fc FFF7FEFF 		bl	NVM_write
 2237 0200 0346     		mov	r3, r0
 2238              		.loc 1 489 8
 2239 0202 002B     		cmp	r3, #0
 2240 0204 16D1     		bne	.L111
 490:Src/nvm.c     ****         goto fail;
 491:Src/nvm.c     ****     if (progress++, NVM_commit())
 2241              		.loc 1 491 17
 2242 0206 FB69     		ldr	r3, [r7, #28]
 2243 0208 0133     		adds	r3, r3, #1
 2244 020a FB61     		str	r3, [r7, #28]
 2245              		.loc 1 491 21
ARM GAS  /tmp/ccYYtTab.s 			page 50


 2246 020c FFF7FEFF 		bl	NVM_commit
 2247 0210 0346     		mov	r3, r0
 2248              		.loc 1 491 8
 2249 0212 002B     		cmp	r3, #0
 2250 0214 10D1     		bne	.L112
 492:Src/nvm.c     ****         goto fail;
 493:Src/nvm.c     ****     printf("new data committed to NVM\r\n"); osDelay(5);
 2251              		.loc 1 493 5
 2252 0216 1348     		ldr	r0, .L113+24
 2253 0218 FFF7FEFF 		bl	puts
 2254              		.loc 1 493 46
 2255 021c 0520     		movs	r0, #5
 2256 021e FFF7FEFF 		bl	osDelay
 494:Src/nvm.c     **** 
 495:Src/nvm.c     ****     return;
 2257              		.loc 1 495 5
 2258 0222 00BF     		nop
 2259 0224 B546     		mov	sp, r6
 2260 0226 0DE0     		b	.L90
 2261              	.L108:
 461:Src/nvm.c     ****     
 2262              		.loc 1 461 9
 2263 0228 00BF     		nop
 2264 022a 06E0     		b	.L92
 2265              	.L109:
 486:Src/nvm.c     ****     if (progress++, NVM_write(0, data, len / 2))
 2266              		.loc 1 486 9
 2267 022c 00BF     		nop
 2268 022e 04E0     		b	.L92
 2269              	.L110:
 488:Src/nvm.c     ****     if (progress++, NVM_write(len / 2, &data[len / 2], len - (len / 2)))
 2270              		.loc 1 488 9
 2271 0230 00BF     		nop
 2272 0232 02E0     		b	.L92
 2273              	.L111:
 490:Src/nvm.c     ****     if (progress++, NVM_commit())
 2274              		.loc 1 490 9
 2275 0234 00BF     		nop
 2276 0236 00E0     		b	.L92
 2277              	.L112:
 492:Src/nvm.c     ****     printf("new data committed to NVM\r\n"); osDelay(5);
 2278              		.loc 1 492 9
 2279 0238 00BF     		nop
 2280              	.L92:
 496:Src/nvm.c     **** 
 497:Src/nvm.c     **** fail:
 498:Src/nvm.c     ****     printf("NVM test failed at %d!\r\n", progress);
 2281              		.loc 1 498 5
 2282 023a F969     		ldr	r1, [r7, #28]
 2283 023c 0A48     		ldr	r0, .L113+28
 2284 023e FFF7FEFF 		bl	printf
 2285 0242 B546     		mov	sp, r6
 2286              	.L90:
 499:Src/nvm.c     **** }
 2287              		.loc 1 499 1
 2288 0244 2C37     		adds	r7, r7, #44
 2289              	.LCFI59:
ARM GAS  /tmp/ccYYtTab.s 			page 51


 2290              		.cfi_def_cfa_offset 36
 2291 0246 BD46     		mov	sp, r7
 2292              	.LCFI60:
 2293              		.cfi_def_cfa_register 13
 2294              		@ sp needed
 2295 0248 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2296              	.L114:
 2297              		.align	2
 2298              	.L113:
 2299 024c 00000000 		.word	.LC0
 2300 0250 14000000 		.word	.LC1
 2301 0254 34000000 		.word	.LC2
 2302 0258 3C000000 		.word	.LC3
 2303 025c 40000000 		.word	.LC4
 2304 0260 50000000 		.word	.LC5
 2305 0264 74000000 		.word	.LC6
 2306 0268 90000000 		.word	.LC7
 2307              		.cfi_endproc
 2308              	.LFE148:
 2310              		.text
 2311              	.Letext0:
 2312              		.file 2 "/usr/share/gcc-arm-none-eabi-10-2020-q4-major/arm-none-eabi/include/machine/_default_type
 2313              		.file 3 "/usr/share/gcc-arm-none-eabi-10-2020-q4-major/arm-none-eabi/include/sys/_stdint.h"
 2314              		.file 4 "/usr/share/gcc-arm-none-eabi-10-2020-q4-major/lib/gcc/arm-none-eabi/10.2.1/include/stddef
 2315              		.file 5 "Drivers/CMSIS/Device/ST/STM32G4xx/Include/stm32g431xx.h"
 2316              		.file 6 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_flash.h"
 2317              		.file 7 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_def.h"
 2318              		.file 8 "<built-in>"
ARM GAS  /tmp/ccYYtTab.s 			page 52


DEFINED SYMBOLS
                            *ABS*:0000000000000000 nvm.c
     /tmp/ccYYtTab.s:22     .data.sectors:0000000000000000 sectors
     /tmp/ccYYtTab.s:19     .data.sectors:0000000000000000 $d
     /tmp/ccYYtTab.s:39     .bss.read_sector_:0000000000000000 read_sector_
     /tmp/ccYYtTab.s:40     .bss.read_sector_:0000000000000000 $d
     /tmp/ccYYtTab.s:46     .bss.n_staging_area_:0000000000000000 n_staging_area_
     /tmp/ccYYtTab.s:43     .bss.n_staging_area_:0000000000000000 $d
     /tmp/ccYYtTab.s:53     .bss.n_valid_:0000000000000000 n_valid_
     /tmp/ccYYtTab.s:50     .bss.n_valid_:0000000000000000 $d
     /tmp/ccYYtTab.s:56     .text.erase:0000000000000000 $t
     /tmp/ccYYtTab.s:64     .text.erase:0000000000000000 erase
     /tmp/ccYYtTab.s:150    .text.erase:000000000000006c $d
     /tmp/ccYYtTab.s:155    .text.set_allocation_state:0000000000000000 $t
     /tmp/ccYYtTab.s:162    .text.set_allocation_state:0000000000000000 set_allocation_state
     /tmp/ccYYtTab.s:277    .text.set_allocation_state:00000000000000c0 $d
     /tmp/ccYYtTab.s:280    .text.set_allocation_state:00000000000000c4 $t
     /tmp/ccYYtTab.s:733    .text.scan_allocation_table:0000000000000000 $t
     /tmp/ccYYtTab.s:740    .text.scan_allocation_table:0000000000000000 scan_allocation_table
     /tmp/ccYYtTab.s:933    .text.NVM_init:0000000000000000 $t
     /tmp/ccYYtTab.s:940    .text.NVM_init:0000000000000000 NVM_init
     /tmp/ccYYtTab.s:1044   .text.NVM_init:0000000000000084 $d
     /tmp/ccYYtTab.s:1053   .text.NVM_erase:0000000000000000 $t
     /tmp/ccYYtTab.s:1060   .text.NVM_erase:0000000000000000 NVM_erase
     /tmp/ccYYtTab.s:1127   .text.NVM_erase:0000000000000048 $d
     /tmp/ccYYtTab.s:1134   .text.NVM_get_max_read_length:0000000000000000 $t
     /tmp/ccYYtTab.s:1141   .text.NVM_get_max_read_length:0000000000000000 NVM_get_max_read_length
     /tmp/ccYYtTab.s:1173   .text.NVM_get_max_read_length:0000000000000014 $d
     /tmp/ccYYtTab.s:1178   .text.NVM_get_max_write_length:0000000000000000 $t
     /tmp/ccYYtTab.s:1185   .text.NVM_get_max_write_length:0000000000000000 NVM_get_max_write_length
     /tmp/ccYYtTab.s:1241   .text.NVM_get_max_write_length:0000000000000034 $d
     /tmp/ccYYtTab.s:1247   .text.NVM_read:0000000000000000 $t
     /tmp/ccYYtTab.s:1254   .text.NVM_read:0000000000000000 NVM_read
     /tmp/ccYYtTab.s:1340   .text.NVM_read:0000000000000064 $d
     /tmp/ccYYtTab.s:1347   .text.NVM_start_write:0000000000000000 $t
     /tmp/ccYYtTab.s:1354   .text.NVM_start_write:0000000000000000 NVM_start_write
     /tmp/ccYYtTab.s:1469   .text.NVM_start_write:000000000000008c $d
     /tmp/ccYYtTab.s:1476   .text.NVM_write:0000000000000000 $t
     /tmp/ccYYtTab.s:1483   .text.NVM_write:0000000000000000 NVM_write
     /tmp/ccYYtTab.s:1747   .text.NVM_write:0000000000000164 $d
     /tmp/ccYYtTab.s:1755   .text.NVM_commit:0000000000000000 $t
     /tmp/ccYYtTab.s:1762   .text.NVM_commit:0000000000000000 NVM_commit
     /tmp/ccYYtTab.s:1891   .text.NVM_commit:00000000000000b0 $d
     /tmp/ccYYtTab.s:1899   .rodata:0000000000000000 $d
     /tmp/ccYYtTab.s:1924   .text.NVM_demo:0000000000000000 $t
     /tmp/ccYYtTab.s:1931   .text.NVM_demo:0000000000000000 NVM_demo
     /tmp/ccYYtTab.s:2299   .text.NVM_demo:000000000000024c $d

UNDEFINED SYMBOLS
HAL_FLASH_Unlock
HAL_FLASHEx_Erase
HAL_FLASH_Lock
HAL_FLASH_GetError
HAL_FLASH_Program
memcpy
osDelay
puts
ARM GAS  /tmp/ccYYtTab.s 			page 53


printf
