ARM GAS  /tmp/cc9hWwcq.s 			page 1


   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 2
  13              		.file	"mc_interface.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.rodata.OFFSET_TAB_CCMRx,"a"
  18              		.align	2
  21              	OFFSET_TAB_CCMRx:
  22 0000 00000000 		.ascii	"\000\000\000\000\004\004\004\00488"
  22      04040404 
  22      3838
  23              		.section	.rodata.SHIFT_TAB_OCxx,"a"
  24              		.align	2
  27              	SHIFT_TAB_OCxx:
  28 0000 00000800 		.ascii	"\000\000\010\000\000\000\010\000\000\010"
  28      00000800 
  28      0008
  29              		.section	.rodata.SHIFT_TAB_ICxx,"a"
  30              		.align	2
  33              	SHIFT_TAB_ICxx:
  34 0000 00000800 		.ascii	"\000\000\010\000\000\000\010\000\000\000"
  34      00000800 
  34      0000
  35              		.section	.rodata.SHIFT_TAB_CCxP,"a"
  36              		.align	2
  39              	SHIFT_TAB_CCxP:
  40 0000 00020406 		.ascii	"\000\002\004\006\010\012\014\016\020\024"
  40      080A0C0E 
  40      1014
  41              		.section	.rodata.SHIFT_TAB_OISx,"a"
  42              		.align	2
  45              	SHIFT_TAB_OISx:
  46 0000 00010203 		.ascii	"\000\001\002\003\004\005\006\007\010\012"
  46      04050607 
  46      080A
  47              		.section	.rodata.USART_PRESCALER_TAB,"a"
  48              		.align	2
  51              	USART_PRESCALER_TAB:
  52 0000 01000000 		.word	1
  53 0004 02000000 		.word	2
  54 0008 04000000 		.word	4
  55 000c 06000000 		.word	6
  56 0010 08000000 		.word	8
  57 0014 0A000000 		.word	10
  58 0018 0C000000 		.word	12
  59 001c 10000000 		.word	16
ARM GAS  /tmp/cc9hWwcq.s 			page 2


  60 0020 20000000 		.word	32
  61 0024 40000000 		.word	64
  62 0028 80000000 		.word	128
  63 002c 00010000 		.word	256
  64              		.section	.rodata.CHANNEL_OFFSET_TAB,"a"
  65              		.align	2
  68              	CHANNEL_OFFSET_TAB:
  69 0000 081C3044 		.ascii	"\010\0340DXl"
  69      586C
  70              		.section	.text.LL_CORDIC_IsActiveFlag_RRDY,"ax",%progbits
  71              		.align	1
  72              		.arch armv7e-m
  73              		.syntax unified
  74              		.thumb
  75              		.thumb_func
  76              		.fpu fpv4-sp-d16
  78              	LL_CORDIC_IsActiveFlag_RRDY:
  79              	.LFB1427:
  80              		.file 1 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h"
   1:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
   2:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   ******************************************************************************
   3:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @file    stm32g4xx_ll_cordic.h
   4:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @author  MCD Application Team
   5:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief   Header file of CORDIC LL module.
   6:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   ******************************************************************************
   7:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @attention
   8:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *
   9:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * Copyright (c) 2019 STMicroelectronics.
  10:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * All rights reserved.
  11:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *
  12:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * This software is licensed under terms that can be found in the LICENSE file
  13:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * in the root directory of this software component.
  14:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * If no LICENSE file comes with this software, it is provided AS-IS.
  15:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *
  16:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   ******************************************************************************
  17:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
  18:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
  19:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /* Define to prevent recursive inclusion -------------------------------------*/
  20:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #ifndef STM32G4xx_LL_CORDIC_H
  21:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define STM32G4xx_LL_CORDIC_H
  22:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
  23:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #ifdef __cplusplus
  24:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** extern "C" {
  25:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #endif
  26:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
  27:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /* Includes ------------------------------------------------------------------*/
  28:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #include "stm32g4xx.h"
  29:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
  30:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /** @addtogroup STM32G4xx_LL_Driver
  31:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @{
  32:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
  33:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
  34:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #if defined(CORDIC)
  35:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
  36:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /** @defgroup CORDIC_LL CORDIC
  37:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @{
  38:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
ARM GAS  /tmp/cc9hWwcq.s 			page 3


  39:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
  40:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /* Private variables ---------------------------------------------------------*/
  41:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
  42:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /* Private constants ---------------------------------------------------------*/
  43:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
  44:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /* Private macros ------------------------------------------------------------*/
  45:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
  46:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /* Exported types ------------------------------------------------------------*/
  47:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
  48:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /* Exported constants --------------------------------------------------------*/
  49:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /** @defgroup CORDIC_LL_Exported_Constants CORDIC Exported Constants
  50:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @{
  51:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
  52:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
  53:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /** @defgroup CORDIC_LL_EC_GET_FLAG Get Flags Defines
  54:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief    Flags defines which can be used with LL_CORDIC_ReadReg function.
  55:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @{
  56:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
  57:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_FLAG_RRDY                CORDIC_CSR_RRDY
  58:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
  59:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @}
  60:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
  61:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
  62:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /** @defgroup CORDIC_LL_EC_IT IT Defines
  63:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief    IT defines which can be used with LL_CORDIC_ReadReg and LL_CORDIC_WriteReg functions.
  64:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @{
  65:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
  66:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_IT_IEN                   CORDIC_CSR_IEN            /*!< Result Ready interrupt en
  67:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
  68:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @}
  69:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
  70:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
  71:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /** @defgroup CORDIC_LL_EC_FUNCTION FUNCTION
  72:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @{
  73:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
  74:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_FUNCTION_COSINE          (0x00000000U)                                           
  75:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_FUNCTION_SINE            ((uint32_t)(CORDIC_CSR_FUNC_0))                         
  76:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_FUNCTION_PHASE           ((uint32_t)(CORDIC_CSR_FUNC_1))                         
  77:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_FUNCTION_MODULUS         ((uint32_t)(CORDIC_CSR_FUNC_1 | CORDIC_CSR_FUNC_0))     
  78:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_FUNCTION_ARCTANGENT      ((uint32_t)(CORDIC_CSR_FUNC_2))                         
  79:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_FUNCTION_HCOSINE         ((uint32_t)(CORDIC_CSR_FUNC_2 | CORDIC_CSR_FUNC_0))     
  80:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_FUNCTION_HSINE           ((uint32_t)(CORDIC_CSR_FUNC_2 | CORDIC_CSR_FUNC_1))     
  81:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_FUNCTION_HARCTANGENT     ((uint32_t)(CORDIC_CSR_FUNC_2 | CORDIC_CSR_FUNC_1 | CORD
  82:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_FUNCTION_NATURALLOG      ((uint32_t)(CORDIC_CSR_FUNC_3))                         
  83:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_FUNCTION_SQUAREROOT      ((uint32_t)(CORDIC_CSR_FUNC_3 | CORDIC_CSR_FUNC_0))     
  84:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
  85:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @}
  86:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
  87:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
  88:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /** @defgroup CORDIC_LL_EC_PRECISION PRECISION
  89:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @{
  90:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
  91:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_PRECISION_1CYCLE         ((uint32_t)(CORDIC_CSR_PRECISION_0))
  92:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_PRECISION_2CYCLES        ((uint32_t)(CORDIC_CSR_PRECISION_1))
  93:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_PRECISION_3CYCLES        ((uint32_t)(CORDIC_CSR_PRECISION_1 | CORDIC_CSR_PRECISIO
  94:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_PRECISION_4CYCLES        ((uint32_t)(CORDIC_CSR_PRECISION_2))
  95:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_PRECISION_5CYCLES        ((uint32_t)(CORDIC_CSR_PRECISION_2 | CORDIC_CSR_PRECISIO
ARM GAS  /tmp/cc9hWwcq.s 			page 4


  96:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_PRECISION_6CYCLES        ((uint32_t)(CORDIC_CSR_PRECISION_2 | CORDIC_CSR_PRECISIO
  97:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_PRECISION_7CYCLES        ((uint32_t)(CORDIC_CSR_PRECISION_2\
  98:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****                                                        | CORDIC_CSR_PRECISION_1 | CORDIC_CSR_PRECIS
  99:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_PRECISION_8CYCLES        ((uint32_t)(CORDIC_CSR_PRECISION_3))
 100:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_PRECISION_9CYCLES        ((uint32_t)(CORDIC_CSR_PRECISION_3 | CORDIC_CSR_PRECISIO
 101:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_PRECISION_10CYCLES       ((uint32_t)(CORDIC_CSR_PRECISION_3 | CORDIC_CSR_PRECISIO
 102:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_PRECISION_11CYCLES       ((uint32_t)(CORDIC_CSR_PRECISION_3\
 103:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****                                                        | CORDIC_CSR_PRECISION_1 | CORDIC_CSR_PRECIS
 104:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_PRECISION_12CYCLES       ((uint32_t)(CORDIC_CSR_PRECISION_3 | CORDIC_CSR_PRECISIO
 105:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_PRECISION_13CYCLES       ((uint32_t)(CORDIC_CSR_PRECISION_3\
 106:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****                                                        | CORDIC_CSR_PRECISION_2 | CORDIC_CSR_PRECIS
 107:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_PRECISION_14CYCLES       ((uint32_t)(CORDIC_CSR_PRECISION_3\
 108:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****                                                        | CORDIC_CSR_PRECISION_2 | CORDIC_CSR_PRECIS
 109:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_PRECISION_15CYCLES       ((uint32_t)(CORDIC_CSR_PRECISION_3\
 110:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****                                                        | CORDIC_CSR_PRECISION_2 | CORDIC_CSR_PRECIS
 111:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****                                                        | CORDIC_CSR_PRECISION_0))
 112:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 113:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @}
 114:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 115:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 116:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /** @defgroup CORDIC_LL_EC_SCALE SCALE
 117:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @{
 118:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 119:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_SCALE_0                  (0x00000000U)
 120:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_SCALE_1                  ((uint32_t)(CORDIC_CSR_SCALE_0))
 121:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_SCALE_2                  ((uint32_t)(CORDIC_CSR_SCALE_1))
 122:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_SCALE_3                  ((uint32_t)(CORDIC_CSR_SCALE_1 | CORDIC_CSR_SCALE_0))
 123:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_SCALE_4                  ((uint32_t)(CORDIC_CSR_SCALE_2))
 124:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_SCALE_5                  ((uint32_t)(CORDIC_CSR_SCALE_2 | CORDIC_CSR_SCALE_0))
 125:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_SCALE_6                  ((uint32_t)(CORDIC_CSR_SCALE_2 | CORDIC_CSR_SCALE_1))
 126:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_SCALE_7                  ((uint32_t)(CORDIC_CSR_SCALE_2 | CORDIC_CSR_SCALE_1 | CO
 127:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 128:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @}
 129:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 130:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 131:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /** @defgroup CORDIC_LL_EC_NBWRITE NBWRITE
 132:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @{
 133:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 134:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_NBWRITE_1                (0x00000000U)             /*!< One 32-bits write contain
 135:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****                                                                           32-bit data input (Q1.31 
 136:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****                                                                           16-bit data input (Q1.15 
 137:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****                                                                           in one 32 bits Data */
 138:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_NBWRITE_2                CORDIC_CSR_NARGS          /*!< Two 32-bit write containi
 139:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****                                                                           (Q1.31 format) */
 140:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 141:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @}
 142:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 143:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 144:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /** @defgroup CORDIC_LL_EC_NBREAD NBREAD
 145:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @{
 146:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 147:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_NBREAD_1                 (0x00000000U)             /*!< One 32-bits read containi
 148:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****                                                                           32-bit data output (Q1.31
 149:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****                                                                           16-bit data output (Q1.15
 150:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****                                                                           in one 32 bits Data */
 151:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_NBREAD_2                 CORDIC_CSR_NRES           /*!< Two 32-bit Data containin
 152:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****                                                                           (Q1.31 format) */
ARM GAS  /tmp/cc9hWwcq.s 			page 5


 153:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 154:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @}
 155:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 156:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 157:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /** @defgroup CORDIC_LL_EC_INSIZE INSIZE
 158:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @{
 159:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 160:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_INSIZE_32BITS            (0x00000000U)             /*!< 32 bits input data size (
 161:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_INSIZE_16BITS            CORDIC_CSR_ARGSIZE        /*!< 16 bits input data size (
 162:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 163:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @}
 164:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 165:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 166:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /** @defgroup CORDIC_LL_EC_OUTSIZE OUTSIZE
 167:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @{
 168:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 169:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_OUTSIZE_32BITS           (0x00000000U)             /*!< 32 bits output data size 
 170:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_OUTSIZE_16BITS           CORDIC_CSR_RESSIZE        /*!< 16 bits output data size 
 171:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 172:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @}
 173:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 174:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 175:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /** @defgroup CORDIC_LL_EC_DMA_REG_DATA DMA register data
 176:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @{
 177:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 178:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_DMA_REG_DATA_IN          (0x00000000U)             /*!< Get address of input data
 179:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_DMA_REG_DATA_OUT         (0x00000001U)             /*!< Get address of output dat
 180:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 181:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @}
 182:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 183:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 184:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 185:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @}
 186:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 187:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 188:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /* Exported macro ------------------------------------------------------------*/
 189:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /** @defgroup CORDIC_LL_Exported_Macros CORDIC Exported Macros
 190:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @{
 191:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 192:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 193:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /** @defgroup CORDIC_LL_EM_WRITE_READ Common Write and read registers Macros
 194:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @{
 195:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 196:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 197:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 198:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief  Write a value in CORDIC register.
 199:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  __INSTANCE__ CORDIC Instance
 200:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  __REG__ Register to be written
 201:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  __VALUE__ Value to be written in the register
 202:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @retval None
 203:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 204:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_WriteReg(__INSTANCE__, __REG__, __VALUE__) WRITE_REG(__INSTANCE__->__REG__, (__VA
 205:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 206:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 207:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief  Read a value in CORDIC register.
 208:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  __INSTANCE__ CORDIC Instance
 209:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  __REG__ Register to be read
ARM GAS  /tmp/cc9hWwcq.s 			page 6


 210:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @retval Register value
 211:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 212:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** #define LL_CORDIC_ReadReg(__INSTANCE__, __REG__) READ_REG(__INSTANCE__->__REG__)
 213:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 214:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @}
 215:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 216:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 217:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 218:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @}
 219:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 220:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 221:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 222:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /* Exported functions --------------------------------------------------------*/
 223:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 224:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /** @defgroup CORDIC_LL_Exported_Functions CORDIC Exported Functions
 225:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @{
 226:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 227:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 228:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /** @defgroup CORDIC_LL_EF_Configuration CORDIC Configuration functions
 229:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @{
 230:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 231:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 232:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 233:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief  Configure the CORDIC processing.
 234:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @note   This function set all parameters of CORDIC processing.
 235:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         These parameters can also be set individually using
 236:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         dedicated functions:
 237:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         - @ref LL_CORDIC_SetFunction()
 238:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         - @ref LL_CORDIC_SetPrecision()
 239:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         - @ref LL_CORDIC_SetScale()
 240:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         - @ref LL_CORDIC_SetNbWrite()
 241:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         - @ref LL_CORDIC_SetNbRead()
 242:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         - @ref LL_CORDIC_SetInSize()
 243:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         - @ref LL_CORDIC_SetOutSize()
 244:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @rmtoll CSR          FUNC          LL_CORDIC_Config\n
 245:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         CSR          PRECISION     LL_CORDIC_Config\n
 246:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         CSR          SCALE         LL_CORDIC_Config\n
 247:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         CSR          NARGS         LL_CORDIC_Config\n
 248:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         CSR          NRES          LL_CORDIC_Config\n
 249:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         CSR          ARGSIZE       LL_CORDIC_Config\n
 250:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         CSR          RESIZE        LL_CORDIC_Config
 251:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  CORDICx CORDIC instance
 252:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  Function parameter can be one of the following values:
 253:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_FUNCTION_COSINE
 254:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_FUNCTION_SINE
 255:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_FUNCTION_PHASE
 256:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_FUNCTION_MODULUS
 257:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_FUNCTION_ARCTANGENT
 258:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_FUNCTION_HCOSINE
 259:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_FUNCTION_HSINE
 260:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_FUNCTION_HARCTANGENT
 261:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_FUNCTION_NATURALLOG
 262:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_FUNCTION_SQUAREROOT
 263:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  Precision parameter can be one of the following values:
 264:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_1CYCLE
 265:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_2CYCLES
 266:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_3CYCLES
ARM GAS  /tmp/cc9hWwcq.s 			page 7


 267:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_4CYCLES
 268:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_5CYCLES
 269:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_6CYCLES
 270:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_7CYCLES
 271:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_8CYCLES
 272:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_9CYCLES
 273:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_10CYCLES
 274:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_11CYCLES
 275:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_12CYCLES
 276:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_13CYCLES
 277:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_14CYCLES
 278:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_15CYCLES
 279:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  Scale parameter can be one of the following values:
 280:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_SCALE_0
 281:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_SCALE_1
 282:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_SCALE_2
 283:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_SCALE_3
 284:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_SCALE_4
 285:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_SCALE_5
 286:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_SCALE_6
 287:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_SCALE_7
 288:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  NbWrite parameter can be one of the following values:
 289:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_NBWRITE_1
 290:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_NBWRITE_2
 291:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  NbRead parameter can be one of the following values:
 292:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_NBREAD_1
 293:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_NBREAD_2
 294:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  InSize parameter can be one of the following values:
 295:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_INSIZE_32BITS
 296:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_INSIZE_16BITS
 297:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  OutSize parameter can be one of the following values:
 298:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_OUTSIZE_32BITS
 299:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_OUTSIZE_16BITS
 300:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @retval None
 301:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 302:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** __STATIC_INLINE void LL_CORDIC_Config(CORDIC_TypeDef *CORDICx, uint32_t Function, uint32_t Precisio
 303:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****                                       uint32_t NbWrite, uint32_t NbRead, uint32_t InSize, uint32_t 
 304:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** {
 305:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   MODIFY_REG(CORDICx->CSR,
 306:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****              CORDIC_CSR_FUNC | CORDIC_CSR_PRECISION | CORDIC_CSR_SCALE |
 307:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****              CORDIC_CSR_NARGS | CORDIC_CSR_NRES | CORDIC_CSR_ARGSIZE | CORDIC_CSR_RESSIZE,
 308:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****              Function | Precision | Scale |
 309:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****              NbWrite | NbRead | InSize | OutSize);
 310:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** }
 311:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 312:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 313:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief  Configure function.
 314:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @rmtoll CSR          FUNC          LL_CORDIC_SetFunction
 315:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  CORDICx CORDIC Instance
 316:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  Function parameter can be one of the following values:
 317:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_FUNCTION_COSINE
 318:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_FUNCTION_SINE
 319:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_FUNCTION_PHASE
 320:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_FUNCTION_MODULUS
 321:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_FUNCTION_ARCTANGENT
 322:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_FUNCTION_HCOSINE
 323:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_FUNCTION_HSINE
ARM GAS  /tmp/cc9hWwcq.s 			page 8


 324:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_FUNCTION_HARCTANGENT
 325:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_FUNCTION_NATURALLOG
 326:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_FUNCTION_SQUAREROOT
 327:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @retval None
 328:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 329:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** __STATIC_INLINE void LL_CORDIC_SetFunction(CORDIC_TypeDef *CORDICx, uint32_t Function)
 330:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** {
 331:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   MODIFY_REG(CORDICx->CSR, CORDIC_CSR_FUNC, Function);
 332:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** }
 333:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 334:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 335:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief  Return function.
 336:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @rmtoll CSR          FUNC          LL_CORDIC_GetFunction
 337:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  CORDICx CORDIC Instance
 338:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @retval Returned value can be one of the following values:
 339:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_FUNCTION_COSINE
 340:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_FUNCTION_SINE
 341:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_FUNCTION_PHASE
 342:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_FUNCTION_MODULUS
 343:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_FUNCTION_ARCTANGENT
 344:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_FUNCTION_HCOSINE
 345:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_FUNCTION_HSINE
 346:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_FUNCTION_HARCTANGENT
 347:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_FUNCTION_NATURALLOG
 348:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_FUNCTION_SQUAREROOT
 349:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 350:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** __STATIC_INLINE uint32_t LL_CORDIC_GetFunction(const CORDIC_TypeDef *CORDICx)
 351:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** {
 352:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   return (uint32_t)(READ_BIT(CORDICx->CSR, CORDIC_CSR_FUNC));
 353:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** }
 354:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 355:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 356:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief  Configure precision in cycles number.
 357:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @rmtoll CSR          PRECISION     LL_CORDIC_SetPrecision
 358:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  CORDICx CORDIC Instance
 359:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  Precision parameter can be one of the following values:
 360:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_1CYCLE
 361:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_2CYCLES
 362:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_3CYCLES
 363:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_4CYCLES
 364:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_5CYCLES
 365:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_6CYCLES
 366:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_7CYCLES
 367:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_8CYCLES
 368:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_9CYCLES
 369:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_10CYCLES
 370:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_11CYCLES
 371:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_12CYCLES
 372:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_13CYCLES
 373:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_14CYCLES
 374:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_15CYCLES
 375:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @retval None
 376:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 377:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** __STATIC_INLINE void LL_CORDIC_SetPrecision(CORDIC_TypeDef *CORDICx, uint32_t Precision)
 378:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** {
 379:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   MODIFY_REG(CORDICx->CSR, CORDIC_CSR_PRECISION, Precision);
 380:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** }
ARM GAS  /tmp/cc9hWwcq.s 			page 9


 381:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 382:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 383:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief  Return precision in cycles number.
 384:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @rmtoll CSR          PRECISION     LL_CORDIC_GetPrecision
 385:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  CORDICx CORDIC Instance
 386:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @retval Returned value can be one of the following values:
 387:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_1CYCLE
 388:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_2CYCLES
 389:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_3CYCLES
 390:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_4CYCLES
 391:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_5CYCLES
 392:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_6CYCLES
 393:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_7CYCLES
 394:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_8CYCLES
 395:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_9CYCLES
 396:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_10CYCLES
 397:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_11CYCLES
 398:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_12CYCLES
 399:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_13CYCLES
 400:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_14CYCLES
 401:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_PRECISION_15CYCLES
 402:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 403:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** __STATIC_INLINE uint32_t LL_CORDIC_GetPrecision(const CORDIC_TypeDef *CORDICx)
 404:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** {
 405:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   return (uint32_t)(READ_BIT(CORDICx->CSR, CORDIC_CSR_PRECISION));
 406:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** }
 407:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 408:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 409:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief  Configure scaling factor.
 410:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @rmtoll CSR          SCALE         LL_CORDIC_SetScale
 411:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  CORDICx CORDIC Instance
 412:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  Scale parameter can be one of the following values:
 413:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_SCALE_0
 414:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_SCALE_1
 415:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_SCALE_2
 416:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_SCALE_3
 417:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_SCALE_4
 418:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_SCALE_5
 419:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_SCALE_6
 420:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_SCALE_7
 421:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @retval None
 422:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 423:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** __STATIC_INLINE void LL_CORDIC_SetScale(CORDIC_TypeDef *CORDICx, uint32_t Scale)
 424:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** {
 425:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   MODIFY_REG(CORDICx->CSR, CORDIC_CSR_SCALE, Scale);
 426:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** }
 427:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 428:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 429:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief  Return scaling factor.
 430:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @rmtoll CSR          SCALE         LL_CORDIC_GetScale
 431:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  CORDICx CORDIC Instance
 432:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @retval Returned value can be one of the following values:
 433:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_SCALE_0
 434:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_SCALE_1
 435:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_SCALE_2
 436:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_SCALE_3
 437:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_SCALE_4
ARM GAS  /tmp/cc9hWwcq.s 			page 10


 438:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_SCALE_5
 439:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_SCALE_6
 440:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_SCALE_7
 441:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 442:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** __STATIC_INLINE uint32_t LL_CORDIC_GetScale(const CORDIC_TypeDef *CORDICx)
 443:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** {
 444:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   return (uint32_t)(READ_BIT(CORDICx->CSR, CORDIC_CSR_SCALE));
 445:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** }
 446:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 447:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 448:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief  Configure number of 32-bit write expected for one calculation.
 449:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @rmtoll CSR          NARGS         LL_CORDIC_SetNbWrite
 450:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  CORDICx CORDIC Instance
 451:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  NbWrite parameter can be one of the following values:
 452:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_NBWRITE_1
 453:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_NBWRITE_2
 454:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @retval None
 455:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 456:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** __STATIC_INLINE void LL_CORDIC_SetNbWrite(CORDIC_TypeDef *CORDICx, uint32_t NbWrite)
 457:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** {
 458:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   MODIFY_REG(CORDICx->CSR, CORDIC_CSR_NARGS, NbWrite);
 459:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** }
 460:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 461:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 462:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief  Return number of 32-bit write expected for one calculation.
 463:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @rmtoll CSR          NARGS         LL_CORDIC_GetNbWrite
 464:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  CORDICx CORDIC Instance
 465:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @retval Returned value can be one of the following values:
 466:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_NBWRITE_1
 467:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_NBWRITE_2
 468:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 469:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** __STATIC_INLINE uint32_t LL_CORDIC_GetNbWrite(const CORDIC_TypeDef *CORDICx)
 470:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** {
 471:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   return (uint32_t)(READ_BIT(CORDICx->CSR, CORDIC_CSR_NARGS));
 472:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** }
 473:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 474:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 475:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief  Configure number of 32-bit read expected after one calculation.
 476:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @rmtoll CSR          NRES          LL_CORDIC_SetNbRead
 477:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  CORDICx CORDIC Instance
 478:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  NbRead parameter can be one of the following values:
 479:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_NBREAD_1
 480:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_NBREAD_2
 481:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @retval None
 482:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 483:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** __STATIC_INLINE void LL_CORDIC_SetNbRead(CORDIC_TypeDef *CORDICx, uint32_t NbRead)
 484:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** {
 485:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   MODIFY_REG(CORDICx->CSR, CORDIC_CSR_NRES, NbRead);
 486:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** }
 487:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 488:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 489:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief  Return number of 32-bit read expected after one calculation.
 490:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @rmtoll CSR          NRES          LL_CORDIC_GetNbRead
 491:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  CORDICx CORDIC Instance
 492:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @retval Returned value can be one of the following values:
 493:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_NBREAD_1
 494:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_NBREAD_2
ARM GAS  /tmp/cc9hWwcq.s 			page 11


 495:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 496:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** __STATIC_INLINE uint32_t LL_CORDIC_GetNbRead(const CORDIC_TypeDef *CORDICx)
 497:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** {
 498:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   return (uint32_t)(READ_BIT(CORDICx->CSR, CORDIC_CSR_NRES));
 499:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** }
 500:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 501:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 502:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief  Configure width of input data.
 503:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @rmtoll CSR          ARGSIZE       LL_CORDIC_SetInSize
 504:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  CORDICx CORDIC Instance
 505:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  InSize parameter can be one of the following values:
 506:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_INSIZE_32BITS
 507:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_INSIZE_16BITS
 508:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @retval None
 509:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 510:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** __STATIC_INLINE void LL_CORDIC_SetInSize(CORDIC_TypeDef *CORDICx, uint32_t InSize)
 511:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** {
 512:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   MODIFY_REG(CORDICx->CSR, CORDIC_CSR_ARGSIZE, InSize);
 513:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** }
 514:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 515:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 516:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief  Return width of input data.
 517:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @rmtoll CSR          ARGSIZE       LL_CORDIC_GetInSize
 518:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  CORDICx CORDIC Instance
 519:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @retval Returned value can be one of the following values:
 520:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_INSIZE_32BITS
 521:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_INSIZE_16BITS
 522:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 523:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** __STATIC_INLINE uint32_t LL_CORDIC_GetInSize(const CORDIC_TypeDef *CORDICx)
 524:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** {
 525:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   return (uint32_t)(READ_BIT(CORDICx->CSR, CORDIC_CSR_ARGSIZE));
 526:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** }
 527:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 528:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 529:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief  Configure width of output data.
 530:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @rmtoll CSR          RESIZE       LL_CORDIC_SetOutSize
 531:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  CORDICx CORDIC Instance
 532:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  OutSize parameter can be one of the following values:
 533:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_OUTSIZE_32BITS
 534:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_OUTSIZE_16BITS
 535:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @retval None
 536:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 537:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** __STATIC_INLINE void LL_CORDIC_SetOutSize(CORDIC_TypeDef *CORDICx, uint32_t OutSize)
 538:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** {
 539:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   MODIFY_REG(CORDICx->CSR, CORDIC_CSR_RESSIZE, OutSize);
 540:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** }
 541:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 542:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 543:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief  Return width of output data.
 544:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @rmtoll CSR          RESIZE       LL_CORDIC_GetOutSize
 545:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  CORDICx CORDIC Instance
 546:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @retval Returned value can be one of the following values:
 547:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_OUTSIZE_32BITS
 548:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_OUTSIZE_16BITS
 549:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 550:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** __STATIC_INLINE uint32_t LL_CORDIC_GetOutSize(const CORDIC_TypeDef *CORDICx)
 551:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** {
ARM GAS  /tmp/cc9hWwcq.s 			page 12


 552:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   return (uint32_t)(READ_BIT(CORDICx->CSR, CORDIC_CSR_RESSIZE));
 553:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** }
 554:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 555:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 556:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @}
 557:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 558:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 559:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /** @defgroup CORDIC_LL_EF_IT_Management IT_Management
 560:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @{
 561:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 562:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 563:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 564:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief  Enable CORDIC result ready interrupt
 565:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @rmtoll CSR          IEN           LL_CORDIC_EnableIT
 566:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  CORDICx CORDIC Instance
 567:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @retval None
 568:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 569:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** __STATIC_INLINE void LL_CORDIC_EnableIT(CORDIC_TypeDef *CORDICx)
 570:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** {
 571:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   SET_BIT(CORDICx->CSR, CORDIC_CSR_IEN);
 572:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** }
 573:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 574:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 575:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief  Disable CORDIC result ready interrupt
 576:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @rmtoll CSR          IEN           LL_CORDIC_DisableIT
 577:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  CORDICx CORDIC Instance
 578:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @retval None
 579:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 580:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** __STATIC_INLINE void LL_CORDIC_DisableIT(CORDIC_TypeDef *CORDICx)
 581:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** {
 582:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   CLEAR_BIT(CORDICx->CSR, CORDIC_CSR_IEN);
 583:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** }
 584:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 585:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 586:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief  Check CORDIC result ready interrupt state.
 587:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @rmtoll CSR          IEN           LL_CORDIC_IsEnabledIT
 588:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  CORDICx CORDIC Instance
 589:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @retval State of bit (1 or 0).
 590:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 591:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** __STATIC_INLINE uint32_t LL_CORDIC_IsEnabledIT(const CORDIC_TypeDef *CORDICx)
 592:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** {
 593:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   return ((READ_BIT(CORDICx->CSR, CORDIC_CSR_IEN) == (CORDIC_CSR_IEN)) ? 1U : 0U);
 594:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** }
 595:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 596:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 597:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @}
 598:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 599:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 600:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /** @defgroup CORDIC_LL_EF_DMA_Management DMA_Management
 601:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @{
 602:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 603:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 604:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 605:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief  Enable CORDIC DMA read channel request.
 606:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @rmtoll CSR          DMAREN        LL_CORDIC_EnableDMAReq_RD
 607:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  CORDICx CORDIC Instance
 608:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @retval None
ARM GAS  /tmp/cc9hWwcq.s 			page 13


 609:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 610:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** __STATIC_INLINE void LL_CORDIC_EnableDMAReq_RD(CORDIC_TypeDef *CORDICx)
 611:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** {
 612:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   SET_BIT(CORDICx->CSR, CORDIC_CSR_DMAREN);
 613:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** }
 614:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 615:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 616:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief  Disable CORDIC DMA read channel request.
 617:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @rmtoll CSR          DMAREN        LL_CORDIC_DisableDMAReq_RD
 618:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  CORDICx CORDIC Instance
 619:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @retval None
 620:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 621:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** __STATIC_INLINE void LL_CORDIC_DisableDMAReq_RD(CORDIC_TypeDef *CORDICx)
 622:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** {
 623:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   CLEAR_BIT(CORDICx->CSR, CORDIC_CSR_DMAREN);
 624:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** }
 625:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 626:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 627:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief  Check CORDIC DMA read channel request state.
 628:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @rmtoll CSR          DMAREN        LL_CORDIC_IsEnabledDMAReq_RD
 629:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  CORDICx CORDIC Instance
 630:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @retval State of bit (1 or 0).
 631:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 632:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** __STATIC_INLINE uint32_t LL_CORDIC_IsEnabledDMAReq_RD(const CORDIC_TypeDef *CORDICx)
 633:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** {
 634:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   return ((READ_BIT(CORDICx->CSR, CORDIC_CSR_DMAREN) == (CORDIC_CSR_DMAREN)) ? 1U : 0U);
 635:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** }
 636:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 637:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 638:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief  Enable CORDIC DMA write channel request.
 639:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @rmtoll CSR          DMAWEN        LL_CORDIC_EnableDMAReq_WR
 640:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  CORDICx CORDIC Instance
 641:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @retval None
 642:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 643:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** __STATIC_INLINE void LL_CORDIC_EnableDMAReq_WR(CORDIC_TypeDef *CORDICx)
 644:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** {
 645:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   SET_BIT(CORDICx->CSR, CORDIC_CSR_DMAWEN);
 646:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** }
 647:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 648:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 649:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief  Disable CORDIC DMA write channel request.
 650:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @rmtoll CSR          DMAWEN        LL_CORDIC_DisableDMAReq_WR
 651:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  CORDICx CORDIC Instance
 652:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @retval None
 653:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 654:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** __STATIC_INLINE void LL_CORDIC_DisableDMAReq_WR(CORDIC_TypeDef *CORDICx)
 655:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** {
 656:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   CLEAR_BIT(CORDICx->CSR, CORDIC_CSR_DMAWEN);
 657:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** }
 658:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 659:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 660:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief  Check CORDIC DMA write channel request state.
 661:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @rmtoll CSR          DMAWEN        LL_CORDIC_IsEnabledDMAReq_WR
 662:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  CORDICx CORDIC Instance
 663:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @retval State of bit (1 or 0).
 664:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 665:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** __STATIC_INLINE uint32_t LL_CORDIC_IsEnabledDMAReq_WR(const CORDIC_TypeDef *CORDICx)
ARM GAS  /tmp/cc9hWwcq.s 			page 14


 666:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** {
 667:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   return ((READ_BIT(CORDICx->CSR, CORDIC_CSR_DMAWEN) == (CORDIC_CSR_DMAWEN)) ? 1U : 0U);
 668:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** }
 669:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 670:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 671:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief  Get the CORDIC data register address used for DMA transfer.
 672:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @rmtoll RDATA        RES           LL_CORDIC_DMA_GetRegAddr\n
 673:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @rmtoll WDATA        ARG           LL_CORDIC_DMA_GetRegAddr
 674:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  CORDICx CORDIC Instance
 675:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  Direction parameter can be one of the following values:
 676:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_DMA_REG_DATA_IN
 677:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   *         @arg @ref LL_CORDIC_DMA_REG_DATA_OUT
 678:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @retval Address of data register
 679:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 680:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** __STATIC_INLINE uint32_t LL_CORDIC_DMA_GetRegAddr(const CORDIC_TypeDef *CORDICx, uint32_t Direction
 681:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** {
 682:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   uint32_t data_reg_addr;
 683:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 684:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   if (Direction == LL_CORDIC_DMA_REG_DATA_OUT)
 685:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   {
 686:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****     /* return address of RDATA register */
 687:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****     data_reg_addr = (uint32_t) &(CORDICx->RDATA);
 688:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   }
 689:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   else
 690:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   {
 691:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****     /* return address of WDATA register */
 692:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****     data_reg_addr = (uint32_t) &(CORDICx->WDATA);
 693:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   }
 694:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 695:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   return data_reg_addr;
 696:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** }
 697:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 698:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 699:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @}
 700:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 701:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 702:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /** @defgroup CORDIC_LL_EF_FLAG_Management FLAG_Management
 703:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @{
 704:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 705:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 706:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 707:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief  Check CORDIC result ready flag state.
 708:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @rmtoll CSR          RRDY          LL_CORDIC_IsActiveFlag_RRDY
 709:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  CORDICx CORDIC Instance
 710:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @retval State of bit (1 or 0).
 711:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 712:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** __STATIC_INLINE uint32_t LL_CORDIC_IsActiveFlag_RRDY(const CORDIC_TypeDef *CORDICx)
 713:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** {
  81              		.loc 1 713 1
  82              		.cfi_startproc
  83              		@ args = 0, pretend = 0, frame = 8
  84              		@ frame_needed = 1, uses_anonymous_args = 0
  85              		@ link register save eliminated.
  86 0000 80B4     		push	{r7}
  87              	.LCFI0:
  88              		.cfi_def_cfa_offset 4
  89              		.cfi_offset 7, -4
ARM GAS  /tmp/cc9hWwcq.s 			page 15


  90 0002 83B0     		sub	sp, sp, #12
  91              	.LCFI1:
  92              		.cfi_def_cfa_offset 16
  93 0004 00AF     		add	r7, sp, #0
  94              	.LCFI2:
  95              		.cfi_def_cfa_register 7
  96 0006 7860     		str	r0, [r7, #4]
 714:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   return ((READ_BIT(CORDICx->CSR, CORDIC_CSR_RRDY) == (CORDIC_CSR_RRDY)) ? 1U : 0U);
  97              		.loc 1 714 12
  98 0008 7B68     		ldr	r3, [r7, #4]
  99 000a 1B68     		ldr	r3, [r3]
 100 000c 03F00043 		and	r3, r3, #-2147483648
 101              		.loc 1 714 79
 102 0010 B3F1004F 		cmp	r3, #-2147483648
 103 0014 01D1     		bne	.L2
 104              		.loc 1 714 79 is_stmt 0 discriminator 1
 105 0016 0123     		movs	r3, #1
 106 0018 00E0     		b	.L4
 107              	.L2:
 108              		.loc 1 714 79 discriminator 2
 109 001a 0023     		movs	r3, #0
 110              	.L4:
 715:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** }
 111              		.loc 1 715 1 is_stmt 1 discriminator 5
 112 001c 1846     		mov	r0, r3
 113 001e 0C37     		adds	r7, r7, #12
 114              	.LCFI3:
 115              		.cfi_def_cfa_offset 4
 116 0020 BD46     		mov	sp, r7
 117              	.LCFI4:
 118              		.cfi_def_cfa_register 13
 119              		@ sp needed
 120 0022 5DF8047B 		ldr	r7, [sp], #4
 121              	.LCFI5:
 122              		.cfi_restore 7
 123              		.cfi_def_cfa_offset 0
 124 0026 7047     		bx	lr
 125              		.cfi_endproc
 126              	.LFE1427:
 128              		.section	.text.LL_CORDIC_WriteData,"ax",%progbits
 129              		.align	1
 130              		.syntax unified
 131              		.thumb
 132              		.thumb_func
 133              		.fpu fpv4-sp-d16
 135              	LL_CORDIC_WriteData:
 136              	.LFB1428:
 716:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 717:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
 718:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @}
 719:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 720:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 721:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /** @defgroup CORDIC_LL_EF_Data_Management Data_Management
 722:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @{
 723:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 724:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 725:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
ARM GAS  /tmp/cc9hWwcq.s 			page 16


 726:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief  Write 32-bit input data for the CORDIC processing.
 727:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @rmtoll WDATA        ARG           LL_CORDIC_WriteData
 728:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  CORDICx CORDIC Instance
 729:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  InData 0 .. 0xFFFFFFFF : 32-bit value to be provided as input data for CORDIC processin
 730:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @retval None
 731:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 732:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** __STATIC_INLINE void LL_CORDIC_WriteData(CORDIC_TypeDef *CORDICx, uint32_t InData)
 733:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** {
 137              		.loc 1 733 1
 138              		.cfi_startproc
 139              		@ args = 0, pretend = 0, frame = 8
 140              		@ frame_needed = 1, uses_anonymous_args = 0
 141              		@ link register save eliminated.
 142 0000 80B4     		push	{r7}
 143              	.LCFI6:
 144              		.cfi_def_cfa_offset 4
 145              		.cfi_offset 7, -4
 146 0002 83B0     		sub	sp, sp, #12
 147              	.LCFI7:
 148              		.cfi_def_cfa_offset 16
 149 0004 00AF     		add	r7, sp, #0
 150              	.LCFI8:
 151              		.cfi_def_cfa_register 7
 152 0006 7860     		str	r0, [r7, #4]
 153 0008 3960     		str	r1, [r7]
 734:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   WRITE_REG(CORDICx->WDATA, InData);
 154              		.loc 1 734 3
 155 000a 7B68     		ldr	r3, [r7, #4]
 156 000c 3A68     		ldr	r2, [r7]
 157 000e 5A60     		str	r2, [r3, #4]
 735:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** }
 158              		.loc 1 735 1
 159 0010 00BF     		nop
 160 0012 0C37     		adds	r7, r7, #12
 161              	.LCFI9:
 162              		.cfi_def_cfa_offset 4
 163 0014 BD46     		mov	sp, r7
 164              	.LCFI10:
 165              		.cfi_def_cfa_register 13
 166              		@ sp needed
 167 0016 5DF8047B 		ldr	r7, [sp], #4
 168              	.LCFI11:
 169              		.cfi_restore 7
 170              		.cfi_def_cfa_offset 0
 171 001a 7047     		bx	lr
 172              		.cfi_endproc
 173              	.LFE1428:
 175              		.section	.text.LL_CORDIC_ReadData,"ax",%progbits
 176              		.align	1
 177              		.syntax unified
 178              		.thumb
 179              		.thumb_func
 180              		.fpu fpv4-sp-d16
 182              	LL_CORDIC_ReadData:
 183              	.LFB1429:
 736:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** 
 737:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** /**
ARM GAS  /tmp/cc9hWwcq.s 			page 17


 738:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @brief  Return 32-bit output data of CORDIC processing.
 739:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @rmtoll RDATA        RES           LL_CORDIC_ReadData
 740:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @param  CORDICx CORDIC Instance
 741:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   * @retval 32-bit output data of CORDIC processing.
 742:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   */
 743:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** __STATIC_INLINE uint32_t LL_CORDIC_ReadData(const CORDIC_TypeDef *CORDICx)
 744:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** {
 184              		.loc 1 744 1
 185              		.cfi_startproc
 186              		@ args = 0, pretend = 0, frame = 8
 187              		@ frame_needed = 1, uses_anonymous_args = 0
 188              		@ link register save eliminated.
 189 0000 80B4     		push	{r7}
 190              	.LCFI12:
 191              		.cfi_def_cfa_offset 4
 192              		.cfi_offset 7, -4
 193 0002 83B0     		sub	sp, sp, #12
 194              	.LCFI13:
 195              		.cfi_def_cfa_offset 16
 196 0004 00AF     		add	r7, sp, #0
 197              	.LCFI14:
 198              		.cfi_def_cfa_register 7
 199 0006 7860     		str	r0, [r7, #4]
 745:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h ****   return (uint32_t)(READ_REG(CORDICx->RDATA));
 200              		.loc 1 745 10
 201 0008 7B68     		ldr	r3, [r7, #4]
 202 000a 9B68     		ldr	r3, [r3, #8]
 746:Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_cordic.h **** }
 203              		.loc 1 746 1
 204 000c 1846     		mov	r0, r3
 205 000e 0C37     		adds	r7, r7, #12
 206              	.LCFI15:
 207              		.cfi_def_cfa_offset 4
 208 0010 BD46     		mov	sp, r7
 209              	.LCFI16:
 210              		.cfi_def_cfa_register 13
 211              		@ sp needed
 212 0012 5DF8047B 		ldr	r7, [sp], #4
 213              	.LCFI17:
 214              		.cfi_restore 7
 215              		.cfi_def_cfa_offset 0
 216 0016 7047     		bx	lr
 217              		.cfi_endproc
 218              	.LFE1429:
 220              		.section	.text.MCM_Modulus,"ax",%progbits
 221              		.align	1
 222              		.syntax unified
 223              		.thumb
 224              		.thumb_func
 225              		.fpu fpv4-sp-d16
 227              	MCM_Modulus:
 228              	.LFB1435:
 229              		.file 2 "Inc/mc_math.h"
   1:Inc/mc_math.h **** 
   2:Inc/mc_math.h **** /**
   3:Inc/mc_math.h ****   ******************************************************************************
   4:Inc/mc_math.h ****   * @file    mc_math.h
ARM GAS  /tmp/cc9hWwcq.s 			page 18


   5:Inc/mc_math.h ****   * @author  Motor Control SDK Team, ST Microelectronics
   6:Inc/mc_math.h ****   * @brief   This file provides mathematics functions useful for and specific to
   7:Inc/mc_math.h ****   *          Motor Control.
   8:Inc/mc_math.h ****   *
   9:Inc/mc_math.h ****   ******************************************************************************
  10:Inc/mc_math.h ****   * @attention
  11:Inc/mc_math.h ****   *
  12:Inc/mc_math.h ****   * <h2><center>&copy; Copyright (c) 2024 STMicroelectronics.
  13:Inc/mc_math.h ****   * All rights reserved.</center></h2>
  14:Inc/mc_math.h ****   *
  15:Inc/mc_math.h ****   * This software component is licensed by ST under Ultimate Liberty license
  16:Inc/mc_math.h ****   * SLA0044, the "License"; You may not use this file except in compliance with
  17:Inc/mc_math.h ****   * the License. You may obtain a copy of the License at:
  18:Inc/mc_math.h ****   *                             www.st.com/SLA0044
  19:Inc/mc_math.h ****   *
  20:Inc/mc_math.h ****   ******************************************************************************
  21:Inc/mc_math.h ****   * @ingroup MC_Math
  22:Inc/mc_math.h ****   */
  23:Inc/mc_math.h **** /* Define to prevent recursive inclusion -------------------------------------*/
  24:Inc/mc_math.h **** #ifndef MC_MATH_H
  25:Inc/mc_math.h **** #define MC_MATH_H
  26:Inc/mc_math.h **** 
  27:Inc/mc_math.h **** /* Includes ------------------------------------------------------------------*/
  28:Inc/mc_math.h **** #include "mc_type.h"
  29:Inc/mc_math.h **** 
  30:Inc/mc_math.h **** /** @addtogroup MCSDK
  31:Inc/mc_math.h ****   * @{
  32:Inc/mc_math.h ****   */
  33:Inc/mc_math.h **** 
  34:Inc/mc_math.h **** /** @addtogroup MC_Math
  35:Inc/mc_math.h ****   * @{
  36:Inc/mc_math.h ****   */
  37:Inc/mc_math.h **** #define SQRT_2  1.4142
  38:Inc/mc_math.h **** #define SQRT_3  1.732
  39:Inc/mc_math.h **** 
  40:Inc/mc_math.h **** /* CORDIC coprocessor configuration register settings */
  41:Inc/mc_math.h **** 
  42:Inc/mc_math.h **** /* CORDIC FUNCTION: PHASE q1.31 (Electrical Angle computation) */
  43:Inc/mc_math.h **** #define CORDIC_CONFIG_PHASE     (LL_CORDIC_FUNCTION_PHASE | LL_CORDIC_PRECISION_6CYCLES | LL_CORDIC
  44:Inc/mc_math.h ****          LL_CORDIC_NBWRITE_2 | LL_CORDIC_NBREAD_1 |\
  45:Inc/mc_math.h ****          LL_CORDIC_INSIZE_32BITS | LL_CORDIC_OUTSIZE_32BITS)
  46:Inc/mc_math.h **** 
  47:Inc/mc_math.h **** /* CORDIC FUNCTION: SQUAREROOT q1.31 */
  48:Inc/mc_math.h **** #define CORDIC_CONFIG_SQRT      (LL_CORDIC_FUNCTION_SQUAREROOT | LL_CORDIC_PRECISION_6CYCLES | LL_C
  49:Inc/mc_math.h ****          LL_CORDIC_NBWRITE_1 | LL_CORDIC_NBREAD_1 |\
  50:Inc/mc_math.h ****          LL_CORDIC_INSIZE_32BITS | LL_CORDIC_OUTSIZE_32BITS)
  51:Inc/mc_math.h **** 
  52:Inc/mc_math.h **** /* CORDIC FUNCTION: COSINE q1.15 */
  53:Inc/mc_math.h **** #define CORDIC_CONFIG_COSINE    (LL_CORDIC_FUNCTION_COSINE | LL_CORDIC_PRECISION_6CYCLES | LL_CORDI
  54:Inc/mc_math.h ****          LL_CORDIC_NBWRITE_1 | LL_CORDIC_NBREAD_1 |\
  55:Inc/mc_math.h ****          LL_CORDIC_INSIZE_16BITS | LL_CORDIC_OUTSIZE_16BITS)
  56:Inc/mc_math.h **** 
  57:Inc/mc_math.h **** /* CORDIC FUNCTION: MODULUS q1.15 */
  58:Inc/mc_math.h **** #define CORDIC_CONFIG_MODULUS   (LL_CORDIC_FUNCTION_MODULUS | LL_CORDIC_PRECISION_6CYCLES | LL_CORD
  59:Inc/mc_math.h ****          LL_CORDIC_NBWRITE_1 | LL_CORDIC_NBREAD_1 |\
  60:Inc/mc_math.h ****          LL_CORDIC_INSIZE_16BITS | LL_CORDIC_OUTSIZE_16BITS)
  61:Inc/mc_math.h **** 
ARM GAS  /tmp/cc9hWwcq.s 			page 19


  62:Inc/mc_math.h **** /**
  63:Inc/mc_math.h ****   * @brief  Macro to compute logarithm of two
  64:Inc/mc_math.h ****   */
  65:Inc/mc_math.h **** #define LOG2(x) \
  66:Inc/mc_math.h ****   (((x) == 65535 ) ? 16 : \
  67:Inc/mc_math.h ****    (((x) == (2*2*2*2*2*2*2*2*2*2*2*2*2*2*2)) ? 15 : \
  68:Inc/mc_math.h ****     (((x) == (2*2*2*2*2*2*2*2*2*2*2*2*2*2)) ? 14 : \
  69:Inc/mc_math.h ****      (((x) == (2*2*2*2*2*2*2*2*2*2*2*2*2)) ? 13 : \
  70:Inc/mc_math.h ****       (((x) == (2*2*2*2*2*2*2*2*2*2*2*2)) ? 12 : \
  71:Inc/mc_math.h ****        (((x) == (2*2*2*2*2*2*2*2*2*2*2)) ? 11 : \
  72:Inc/mc_math.h ****         (((x) == (2*2*2*2*2*2*2*2*2*2)) ? 10 : \
  73:Inc/mc_math.h ****          (((x) == (2*2*2*2*2*2*2*2*2)) ? 9 : \
  74:Inc/mc_math.h ****           (((x) == (2*2*2*2*2*2*2*2)) ? 8 : \
  75:Inc/mc_math.h ****            (((x) == (2*2*2*2*2*2*2)) ? 7 : \
  76:Inc/mc_math.h ****             (((x) == (2*2*2*2*2*2)) ? 6 : \
  77:Inc/mc_math.h ****              (((x) == (2*2*2*2*2)) ? 5 : \
  78:Inc/mc_math.h ****               (((x) == (2*2*2*2)) ? 4 : \
  79:Inc/mc_math.h ****                (((x) == (2*2*2)) ? 3 : \
  80:Inc/mc_math.h ****                 (((x) == (2*2)) ? 2 : \
  81:Inc/mc_math.h ****                  (((x) == 2) ? 1 : \
  82:Inc/mc_math.h ****                   (((x) == 1) ? 0 : -1)))))))))))))))))
  83:Inc/mc_math.h **** 
  84:Inc/mc_math.h **** /**
  85:Inc/mc_math.h ****   * @brief  Trigonometrical functions type definition
  86:Inc/mc_math.h ****   */
  87:Inc/mc_math.h **** typedef struct
  88:Inc/mc_math.h **** {
  89:Inc/mc_math.h ****   int16_t hCos;
  90:Inc/mc_math.h ****   int16_t hSin;
  91:Inc/mc_math.h **** } Trig_Components;
  92:Inc/mc_math.h **** 
  93:Inc/mc_math.h **** /**
  94:Inc/mc_math.h ****   * @brief  This function transforms stator currents Ia and qIb (which are
  95:Inc/mc_math.h ****   *         directed along axes each displaced by 120 degrees) into currents
  96:Inc/mc_math.h ****   *         Ialpha and Ibeta in a stationary qd reference frame.
  97:Inc/mc_math.h ****   *                               Ialpha = Ia
  98:Inc/mc_math.h ****   *                       Ibeta = -(2*Ib+Ia)/sqrt(3)
  99:Inc/mc_math.h ****   * @param  Curr_Input: stator current Ia and Ib in ab_t format.
 100:Inc/mc_math.h ****   * @retval Stator current Ialpha and Ibeta in alphabeta_t format.
 101:Inc/mc_math.h ****   */
 102:Inc/mc_math.h **** alphabeta_t MCM_Clarke(ab_t Input);
 103:Inc/mc_math.h **** 
 104:Inc/mc_math.h **** /**
 105:Inc/mc_math.h ****   * @brief  This function transforms stator values alpha and beta, which
 106:Inc/mc_math.h ****   *         belong to a stationary qd reference frame, to a rotor flux
 107:Inc/mc_math.h ****   *         synchronous reference frame (properly oriented), so as Iq and Id.
 108:Inc/mc_math.h ****   *                   Id= Ialpha *sin(theta)+qIbeta *cos(Theta)
 109:Inc/mc_math.h ****   *                   Iq=qIalpha *cos(Theta)-qIbeta *sin(Theta)
 110:Inc/mc_math.h ****   * @param  Curr_Input: stator values alpha and beta in alphabeta_t format.
 111:Inc/mc_math.h ****   * @param  Theta: rotating frame angular position in q1.15 format.
 112:Inc/mc_math.h ****   * @retval Stator current q and d in qd_t format.
 113:Inc/mc_math.h ****   */
 114:Inc/mc_math.h **** qd_t MCM_Park(alphabeta_t Input, int16_t Theta);
 115:Inc/mc_math.h **** 
 116:Inc/mc_math.h **** /**
 117:Inc/mc_math.h ****   * @brief  This function transforms stator voltage qVq and qVd, that belong to
 118:Inc/mc_math.h ****   *         a rotor flux synchronous rotating frame, to a stationary reference
ARM GAS  /tmp/cc9hWwcq.s 			page 20


 119:Inc/mc_math.h ****   *         frame, so as to obtain qValpha and qVbeta:
 120:Inc/mc_math.h ****   *                  Valfa= Vq*Cos(theta)+ Vd*Sin(theta)
 121:Inc/mc_math.h ****   *                  Vbeta=-Vq*Sin(theta)+ Vd*Cos(theta)
 122:Inc/mc_math.h ****   * @param  Curr_Input: stator voltage Vq and Vd in qd_t format.
 123:Inc/mc_math.h ****   * @param  Theta: rotating frame angular position in q1.15 format.
 124:Inc/mc_math.h ****   * @retval Stator values alpha and beta in alphabeta_t format.
 125:Inc/mc_math.h ****   */
 126:Inc/mc_math.h **** alphabeta_t MCM_Rev_Park(qd_t Input, int16_t Theta);
 127:Inc/mc_math.h **** 
 128:Inc/mc_math.h **** /**
 129:Inc/mc_math.h ****   * @brief  This function returns cosine and sine functions of the angle fed in input.
 130:Inc/mc_math.h ****   * @param  hAngle: angle in q1.15 format.
 131:Inc/mc_math.h ****   * @retval Trig_Components Cos(angle) and Sin(angle) in Trig_Components format.
 132:Inc/mc_math.h ****   */
 133:Inc/mc_math.h **** Trig_Components MCM_Trig_Functions(int16_t hAngle);
 134:Inc/mc_math.h **** 
 135:Inc/mc_math.h **** /**
 136:Inc/mc_math.h ****   * @brief  It calculates the square root of a non-negative s32. It returns 0 for negative s32.
 137:Inc/mc_math.h ****   * @param  Input int32_t number.
 138:Inc/mc_math.h ****   * @retval int32_t Square root of Input (0 if Input<0).
 139:Inc/mc_math.h ****   */
 140:Inc/mc_math.h **** int32_t MCM_Sqrt(int32_t wInput);
 141:Inc/mc_math.h **** 
 142:Inc/mc_math.h **** /**
 143:Inc/mc_math.h ****   * @brief  Sqrt table used by Circle Limitation function
 144:Inc/mc_math.h ****   *         used for STM32F0/STM32G0 series only
 145:Inc/mc_math.h ****   */
 146:Inc/mc_math.h **** #define SQRT_CIRCLE_LIMITATION {\
 147:Inc/mc_math.h ****      0 , 1023 , 1448 , 1773 , 2047 , 2289 , 2508 , 2709,\
 148:Inc/mc_math.h ****      2896 , 3071 , 3238 , 3396 , 3547 , 3691 , 3831 , 3965,\
 149:Inc/mc_math.h ****      4095 , 4221 , 4344 , 4463 , 4579 , 4692 , 4802 , 4910,\
 150:Inc/mc_math.h ****      5016 , 5119 , 5221 , 5320 , 5418 , 5514 , 5608 , 5701,\
 151:Inc/mc_math.h ****      5792 , 5882 , 5970 , 6057 , 6143 , 6228 , 6312 , 6394,\
 152:Inc/mc_math.h ****      6476 , 6556 , 6636 , 6714 , 6792 , 6868 , 6944 , 7019,\
 153:Inc/mc_math.h ****      7094 , 7167 , 7240 , 7312 , 7383 , 7454 , 7524 , 7593,\
 154:Inc/mc_math.h ****      7662 , 7730 , 7798 , 7865 , 7931 , 7997 , 8062 , 8127,\
 155:Inc/mc_math.h ****      8191 , 8255 , 8318 , 8381 , 8443 , 8505 , 8567 , 8628,\
 156:Inc/mc_math.h ****      8688 , 8748 , 8808 , 8867 , 8926 , 8985 , 9043 , 9101,\
 157:Inc/mc_math.h ****      9158 , 9215 , 9272 , 9328 , 9384 , 9440 , 9495 , 9550,\
 158:Inc/mc_math.h ****      9605 , 9660 , 9714 , 9768 , 9821 , 9874 , 9927 , 9980,\
 159:Inc/mc_math.h ****      10032 , 10084 , 10136 , 10188 , 10239 , 10290 , 10341 , 10392,\
 160:Inc/mc_math.h ****      10442 , 10492 , 10542 , 10592 , 10641 , 10690 , 10739 , 10788,\
 161:Inc/mc_math.h ****      10836 , 10884 , 10932 , 10980 , 11028 , 11075 , 11123 , 11170,\
 162:Inc/mc_math.h ****      11217 , 11263 , 11310 , 11356 , 11402 , 11448 , 11494 , 11539,\
 163:Inc/mc_math.h ****      11584 , 11630 , 11675 , 11719 , 11764 , 11808 , 11853 , 11897,\
 164:Inc/mc_math.h ****      11941 , 11985 , 12028 , 12072 , 12115 , 12158 , 12201 , 12244,\
 165:Inc/mc_math.h ****      12287 , 12330 , 12372 , 12414 , 12457 , 12499 , 12541 , 12582,\
 166:Inc/mc_math.h ****      12624 , 12665 , 12707 , 12748 , 12789 , 12830 , 12871 , 12911,\
 167:Inc/mc_math.h ****      12952 , 12992 , 13032 , 13073 , 13113 , 13153 , 13192 , 13232,\
 168:Inc/mc_math.h ****      13272 , 13311 , 13350 , 13390 , 13429 , 13468 , 13507 , 13545,\
 169:Inc/mc_math.h ****      13584 , 13623 , 13661 , 13699 , 13737 , 13776 , 13814 , 13851,\
 170:Inc/mc_math.h ****      13889 , 13927 , 13965 , 14002 , 14039 , 14077 , 14114 , 14151,\
 171:Inc/mc_math.h ****      14188 , 14225 , 14262 , 14298 , 14335 , 14372 , 14408 , 14444,\
 172:Inc/mc_math.h ****      14481 , 14517 , 14553 , 14589 , 14625 , 14661 , 14696 , 14732,\
 173:Inc/mc_math.h ****      14767 , 14803 , 14838 , 14874 , 14909 , 14944 , 14979 , 15014,\
 174:Inc/mc_math.h ****      15049 , 15084 , 15118 , 15153 , 15187 , 15222 , 15256 , 15291,\
 175:Inc/mc_math.h ****      15325 , 15359 , 15393 , 15427 , 15461 , 15495 , 15529 , 15562,\
ARM GAS  /tmp/cc9hWwcq.s 			page 21


 176:Inc/mc_math.h ****      15596 , 15630 , 15663 , 15697 , 15730 , 15763 , 15797 , 15830,\
 177:Inc/mc_math.h ****      15863 , 15896 , 15929 , 15962 , 15994 , 16027 , 16060 , 16092,\
 178:Inc/mc_math.h ****      16125 , 16157 , 16190 , 16222 , 16254 , 16287 , 16319 , 16351,\
 179:Inc/mc_math.h ****      16383 , 16415 , 16447 , 16479 , 16510 , 16542 , 16574 , 16605,\
 180:Inc/mc_math.h ****      16637 , 16669 , 16700 , 16731 , 16763 , 16794 , 16825 , 16856,\
 181:Inc/mc_math.h ****      16887 , 16918 , 16949 , 16980 , 17011 , 17042 , 17072 , 17103,\
 182:Inc/mc_math.h ****      17134 , 17164 , 17195 , 17225 , 17256 , 17286 , 17316 , 17347,\
 183:Inc/mc_math.h ****      17377 , 17407 , 17437 , 17467 , 17497 , 17527 , 17557 , 17587,\
 184:Inc/mc_math.h ****      17617 , 17646 , 17676 , 17706 , 17735 , 17765 , 17794 , 17824,\
 185:Inc/mc_math.h ****      17853 , 17882 , 17912 , 17941 , 17970 , 17999 , 18028 , 18057,\
 186:Inc/mc_math.h ****      18086 , 18115 , 18144 , 18173 , 18202 , 18231 , 18259 , 18288,\
 187:Inc/mc_math.h ****      18317 , 18345 , 18374 , 18402 , 18431 , 18459 , 18488 , 18516,\
 188:Inc/mc_math.h ****      18544 , 18573 , 18601 , 18629 , 18657 , 18685 , 18713 , 18741,\
 189:Inc/mc_math.h ****      18769 , 18797 , 18825 , 18853 , 18881 , 18908 , 18936 , 18964,\
 190:Inc/mc_math.h ****      18991 , 19019 , 19046 , 19074 , 19101 , 19129 , 19156 , 19184,\
 191:Inc/mc_math.h ****      19211 , 19238 , 19265 , 19293 , 19320 , 19347 , 19374 , 19401,\
 192:Inc/mc_math.h ****      19428 , 19455 , 19482 , 19509 , 19536 , 19562 , 19589 , 19616,\
 193:Inc/mc_math.h ****      19643 , 19669 , 19696 , 19723 , 19749 , 19776 , 19802 , 19829,\
 194:Inc/mc_math.h ****      19855 , 19881 , 19908 , 19934 , 19960 , 19987 , 20013 , 20039,\
 195:Inc/mc_math.h ****      20065 , 20091 , 20117 , 20143 , 20169 , 20235 , 20231 , 20247,\
 196:Inc/mc_math.h ****      20273 , 20299 , 20325 , 20350 , 20376 , 20402 , 20428 , 20453,\
 197:Inc/mc_math.h ****      20479 , 20504 , 20530 , 20556 , 20581 , 20606 , 20632 , 20657,\
 198:Inc/mc_math.h ****      20683 , 20708 , 20733 , 20759 , 20784 , 20809 , 20834 , 20859,\
 199:Inc/mc_math.h ****      20884 , 20910 , 20935 , 20960 , 20985 , 21010 , 21035 , 21059,\
 200:Inc/mc_math.h ****      21084 , 21109 , 21134 , 21159 , 21184 , 21208 , 21233 , 21258,\
 201:Inc/mc_math.h ****      21282 , 21307 , 21331 , 21356 , 21381 , 21405 , 21430 , 21454,\
 202:Inc/mc_math.h ****      21478 , 21503 , 21527 , 21552 , 21576 , 21600 , 21624 , 21649,\
 203:Inc/mc_math.h ****      21673 , 21697 , 21721 , 21745 , 21769 , 21793 , 21817 , 21841,\
 204:Inc/mc_math.h ****      21865 , 21889 , 21913 , 21937 , 21961 , 21985 , 22009 , 22033,\
 205:Inc/mc_math.h ****      22056 , 22080 , 22104 , 22128 , 22151 , 22175 , 22199 , 22222,\
 206:Inc/mc_math.h ****      22246 , 22269 , 22293 , 22316 , 22340 , 22363 , 22387 , 22410,\
 207:Inc/mc_math.h ****      22434 , 22457 , 22480 , 22504 , 22527 , 22550 , 22573 , 22597,\
 208:Inc/mc_math.h ****      22620 , 22643 , 22666 , 22689 , 22712 , 22735 , 22758 , 22781,\
 209:Inc/mc_math.h ****      22804 , 22827 , 22850 , 22873 , 22896 , 22919 , 22942 , 22965,\
 210:Inc/mc_math.h ****      22988 , 23010 , 23033 , 23056 , 23079 , 23101 , 23124 , 23147,\
 211:Inc/mc_math.h ****      23169 , 23192 , 23214 , 23237 , 23260 , 23282 , 23305 , 23327,\
 212:Inc/mc_math.h ****      23350 , 23372 , 23394 , 23417 , 23439 , 23462 , 23484 , 23506,\
 213:Inc/mc_math.h ****      23529 , 23551 , 23573 , 23595 , 23617 , 23640 , 23662 , 23684,\
 214:Inc/mc_math.h ****      23706 , 23728 , 23750 , 23772 , 23794 , 23816 , 23838 , 23860,\
 215:Inc/mc_math.h ****      23882 , 23904 , 23926 , 23948 , 23970 , 23992 , 24014 , 24036,\
 216:Inc/mc_math.h ****      24057 , 24079 , 24101 , 24123 , 24144 , 24166 , 24188 , 24209,\
 217:Inc/mc_math.h ****      24231 , 24253 , 24274 , 24296 , 24317 , 24339 , 24360 , 24382,\
 218:Inc/mc_math.h ****      24403 , 24425 , 24446 , 24468 , 24489 , 24511 , 24532 , 24553,\
 219:Inc/mc_math.h ****      24575 , 24596 , 24617 , 24639 , 24660 , 24681 , 24702 , 24724,\
 220:Inc/mc_math.h ****      24745 , 24766 , 24787 , 24808 , 24829 , 24851 , 24872 , 24893,\
 221:Inc/mc_math.h ****      24914 , 24935 , 24956 , 24977 , 24998 , 25019 , 25040 , 25061,\
 222:Inc/mc_math.h ****      25082 , 25102 , 25123 , 25144 , 25165 , 25186 , 25207 , 25227,\
 223:Inc/mc_math.h ****      25248 , 25269 , 25290 , 25310 , 25331 , 25352 , 25372 , 25393,\
 224:Inc/mc_math.h ****      25414 , 25434 , 25455 , 25476 , 25496 , 25517 , 25537 , 25558,\
 225:Inc/mc_math.h ****      25578 , 25599 , 25619 , 25640 , 25660 , 25681 , 25701 , 25721,\
 226:Inc/mc_math.h ****      25742 , 25762 , 25782 , 25803 , 25823 , 25843 , 25864 , 25884,\
 227:Inc/mc_math.h ****      25904 , 25924 , 25945 , 25965 , 25985 , 26005 , 26025 , 26045,\
 228:Inc/mc_math.h ****      26065 , 26086 , 26106 , 26126 , 26146 , 26166 , 26186 , 26206,\
 229:Inc/mc_math.h ****      26226 , 26246 , 26266 , 26286 , 26306 , 26326 , 26346 , 26365,\
 230:Inc/mc_math.h ****      26385 , 26405 , 26425 , 26445 , 26465 , 26484 , 26504 , 26524,\
 231:Inc/mc_math.h ****      26544 , 26564 , 26583 , 26603 , 26623 , 26642 , 26662 , 26682,\
 232:Inc/mc_math.h ****      26701 , 26721 , 26741 , 26760 , 26780 , 26799 , 26819 , 26838,\
ARM GAS  /tmp/cc9hWwcq.s 			page 22


 233:Inc/mc_math.h ****      26858 , 26877 , 26897 , 26916 , 26936 , 26955 , 26975 , 26994,\
 234:Inc/mc_math.h ****      27014 , 27033 , 27052 , 27072 , 27091 , 27111 , 27130 , 27149,\
 235:Inc/mc_math.h ****      27168 , 27188 , 27207 , 27226 , 27246 , 27265 , 27284 , 27303,\
 236:Inc/mc_math.h ****      27322 , 27342 , 27361 , 27380 , 27399 , 27418 , 27437 , 27456,\
 237:Inc/mc_math.h ****      27475 , 27495 , 27514 , 27533 , 27552 , 27571 , 27590 , 27609,\
 238:Inc/mc_math.h ****      27628 , 27647 , 27666 , 27685 , 27703 , 27722 , 27741 , 27760,\
 239:Inc/mc_math.h ****      27779 , 27798 , 27817 , 27836 , 27854 , 27873 , 27892 , 27911,\
 240:Inc/mc_math.h ****      27930 , 27948 , 27967 , 27986 , 28005 , 28023 , 28042 , 28061,\
 241:Inc/mc_math.h ****      28079 , 28098 , 28117 , 28135 , 28154 , 28173 , 28191 , 28210,\
 242:Inc/mc_math.h ****      28228 , 28247 , 28265 , 28284 , 28303 , 28321 , 28340 , 28358,\
 243:Inc/mc_math.h ****      28377 , 28395 , 28413 , 28432 , 28450 , 28469 , 28487 , 28506,\
 244:Inc/mc_math.h ****      28524 , 28542 , 28561 , 28579 , 28597 , 28616 , 28634 , 28652,\
 245:Inc/mc_math.h ****      28671 , 28689 , 28707 , 28725 , 28744 , 28762 , 28780 , 28798,\
 246:Inc/mc_math.h ****      28817 , 28835 , 28853 , 28871 , 28889 , 28907 , 28925 , 28944,\
 247:Inc/mc_math.h ****      28962 , 28980 , 28998 , 29016 , 29034 , 29052 , 29070 , 29088,\
 248:Inc/mc_math.h ****      29106 , 29124 , 29142 , 29160 , 29178 , 29196 , 29214 , 29232,\
 249:Inc/mc_math.h ****      29250 , 29268 , 29286 , 29304 , 29322 , 29339 , 29357 , 29375,\
 250:Inc/mc_math.h ****      29393 , 29411 , 29429 , 29446 , 29464 , 29482 , 29500 , 29518,\
 251:Inc/mc_math.h ****      29535 , 29553 , 29571 , 29588 , 29606 , 29624 , 29642 , 29659,\
 252:Inc/mc_math.h ****      29677 , 29695 , 29712 , 29730 , 29748 , 29765 , 29783 , 29800,\
 253:Inc/mc_math.h ****      29818 , 29835 , 29853 , 29871 , 29888 , 29906 , 29923 , 29941,\
 254:Inc/mc_math.h ****      29958 , 29976 , 29993 , 30011 , 30028 , 30046 , 30063 , 30080,\
 255:Inc/mc_math.h ****      30098 , 30115 , 30133 , 30150 , 30168 , 30185 , 30202 , 30220,\
 256:Inc/mc_math.h ****      30237 , 30254 , 30272 , 30289 , 30306 , 30324 , 30341 , 30358,\
 257:Inc/mc_math.h ****      30375 , 30393 , 30410 , 30427 , 30444 , 30461 , 30479 , 30496,\
 258:Inc/mc_math.h ****      30513 , 30530 , 30547 , 30565 , 30582 , 30599 , 30616 , 30633,\
 259:Inc/mc_math.h ****      30650 , 30667 , 30684 , 30701 , 30719 , 30736 , 30753 , 30770,\
 260:Inc/mc_math.h ****      30787 , 30804 , 30821 , 30838 , 30855 , 30872 , 30889 , 30906,\
 261:Inc/mc_math.h ****      30923 , 30940 , 30957 , 30973 , 30990 , 31007 , 31024 , 31041,\
 262:Inc/mc_math.h ****      31058 , 31075 , 31092 , 31109 , 31125 , 31142 , 31159 , 31176,\
 263:Inc/mc_math.h ****      31193 , 31210 , 31226 , 31243 , 31260 , 31277 , 31293 , 31310,\
 264:Inc/mc_math.h ****      31327 , 31344 , 31360 , 31377 , 31394 , 31410 , 31427 , 31444,\
 265:Inc/mc_math.h ****      31461 , 31477 , 31494 , 31510 , 31527 , 31544 , 31560 , 31577,\
 266:Inc/mc_math.h ****      31594 , 31610 , 31627 , 31643 , 31660 , 31676 , 31693 , 31709,\
 267:Inc/mc_math.h ****      31726 , 31743 , 31759 , 31776 , 31792 , 31809 , 31825 , 31841,\
 268:Inc/mc_math.h ****      31858 , 31874 , 31891 , 31907 , 31924 , 31940 , 31957 , 31973,\
 269:Inc/mc_math.h ****      31989 , 32006 , 32023 , 32038 , 32055 , 32071 , 32087 , 32104,\
 270:Inc/mc_math.h ****      32120 , 32136 , 32153 , 32169 , 32185 , 32202 , 32218 , 32234,\
 271:Inc/mc_math.h ****      32250 , 32267 , 32283 , 32299 , 32315 , 32332 , 32348 , 32364,\
 272:Inc/mc_math.h ****      32380 , 32396 , 32413 , 32429 , 32445 , 32461 , 32477 , 32493,\
 273:Inc/mc_math.h ****      32509 , 32526 , 32542 , 32558 , 32574 , 32590 , 32606 , 32622,\
 274:Inc/mc_math.h ****      32638 , 32654 , 32670 , 32686 , 32702 , 32718 , 32734 , 32750,\
 275:Inc/mc_math.h ****      32767 }
 276:Inc/mc_math.h **** 
 277:Inc/mc_math.h **** #define ATAN1DIV1     (int16_t)8192
 278:Inc/mc_math.h **** #define ATAN1DIV2     (int16_t)4836
 279:Inc/mc_math.h **** #define ATAN1DIV4     (int16_t)2555
 280:Inc/mc_math.h **** #define ATAN1DIV8     (int16_t)1297
 281:Inc/mc_math.h **** #define ATAN1DIV16    (int16_t)651
 282:Inc/mc_math.h **** #define ATAN1DIV32    (int16_t)326
 283:Inc/mc_math.h **** #define ATAN1DIV64    (int16_t)163
 284:Inc/mc_math.h **** #define ATAN1DIV128   (int16_t)81
 285:Inc/mc_math.h **** #define ATAN1DIV256   (int16_t)41
 286:Inc/mc_math.h **** #define ATAN1DIV512   (int16_t)20
 287:Inc/mc_math.h **** #define ATAN1DIV1024  (int16_t)10
 288:Inc/mc_math.h **** #define ATAN1DIV2048  (int16_t)5
 289:Inc/mc_math.h **** #define ATAN1DIV4096  (int16_t)3
ARM GAS  /tmp/cc9hWwcq.s 			page 23


 290:Inc/mc_math.h **** #define ATAN1DIV8192  (int16_t)1
 291:Inc/mc_math.h **** 
 292:Inc/mc_math.h **** /**
 293:Inc/mc_math.h ****   * @brief  It executes Modulus algorithm.
 294:Inc/mc_math.h ****   * @param  alpha component,
 295:Inc/mc_math.h ****   *         beta component.
 296:Inc/mc_math.h ****   * @retval int16_t Modulus.
 297:Inc/mc_math.h ****   */
 298:Inc/mc_math.h **** static inline int16_t MCM_Modulus(int16_t alpha, int16_t beta)
 299:Inc/mc_math.h **** {
 230              		.loc 2 299 1
 231              		.cfi_startproc
 232              		@ args = 0, pretend = 0, frame = 16
 233              		@ frame_needed = 1, uses_anonymous_args = 0
 234 0000 80B5     		push	{r7, lr}
 235              	.LCFI18:
 236              		.cfi_def_cfa_offset 8
 237              		.cfi_offset 7, -8
 238              		.cfi_offset 14, -4
 239 0002 84B0     		sub	sp, sp, #16
 240              	.LCFI19:
 241              		.cfi_def_cfa_offset 24
 242 0004 00AF     		add	r7, sp, #0
 243              	.LCFI20:
 244              		.cfi_def_cfa_register 7
 245 0006 0346     		mov	r3, r0
 246 0008 0A46     		mov	r2, r1
 247 000a FB80     		strh	r3, [r7, #6]	@ movhi
 248 000c 1346     		mov	r3, r2	@ movhi
 249 000e BB80     		strh	r3, [r7, #4]	@ movhi
 250              	.LBB6:
 251              	.LBB7:
 252              		.file 3 "Drivers/CMSIS/Include/cmsis_gcc.h"
   1:Drivers/CMSIS/Include/cmsis_gcc.h **** /**************************************************************************//**
   2:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @version  V5.2.0
   5:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @date     08. May 2019
   6:Drivers/CMSIS/Include/cmsis_gcc.h ****  ******************************************************************************/
   7:Drivers/CMSIS/Include/cmsis_gcc.h **** /*
   8:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Copyright (c) 2009-2019 Arm Limited. All rights reserved.
   9:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  10:Drivers/CMSIS/Include/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  12:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:Drivers/CMSIS/Include/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:Drivers/CMSIS/Include/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  16:Drivers/CMSIS/Include/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  18:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:Drivers/CMSIS/Include/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:Drivers/CMSIS/Include/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:Drivers/CMSIS/Include/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:Drivers/CMSIS/Include/cmsis_gcc.h ****  * limitations under the License.
  23:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  24:Drivers/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/cc9hWwcq.s 			page 24


  25:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  28:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  34:Drivers/CMSIS/Include/cmsis_gcc.h **** /* Fallback for __has_builtin */
  35:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __has_builtin
  36:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  38:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  39:Drivers/CMSIS/Include/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ASM
  41:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __ASM                                  __asm
  42:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  43:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __INLINE
  44:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __INLINE                               inline
  45:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  46:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
  48:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  49:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_FORCEINLINE                 
  50:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_FORCEINLINE                   __attribute__((always_inline)) static inline
  51:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif                                           
  52:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __NO_RETURN
  53:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((__noreturn__))
  54:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  55:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __USED
  56:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
  57:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  58:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __WEAK
  59:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  60:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  61:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED
  62:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  63:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  64:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  65:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
  66:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  67:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_UNION
  68:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
  69:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  70:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  71:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  72:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  73:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  74:Drivers/CMSIS/Include/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  75:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  76:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  77:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  78:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  79:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  80:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  81:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
ARM GAS  /tmp/cc9hWwcq.s 			page 25


  82:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  83:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  84:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  85:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  86:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
  87:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  88:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  89:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  90:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  91:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  92:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  93:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  94:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
  95:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  96:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  97:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  98:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  99:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 100:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
 101:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 102:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
 103:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
 104:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
 105:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 106:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 107:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 108:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 109:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 110:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ALIGNED
 111:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 112:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 113:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __RESTRICT
 114:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 115:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 116:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __COMPILER_BARRIER
 117:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __COMPILER_BARRIER()                   __ASM volatile("":::"memory")
 118:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 119:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 120:Drivers/CMSIS/Include/cmsis_gcc.h **** /* #########################  Startup and Lowlevel Init  ######################## */
 121:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 122:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __PROGRAM_START
 123:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 124:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 125:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Initializes data and bss sections
 126:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details This default implementations initialized all data and additional bss
 127:Drivers/CMSIS/Include/cmsis_gcc.h ****            sections relying on .copy.table and .zero.table specified properly
 128:Drivers/CMSIS/Include/cmsis_gcc.h ****            in the used linker script.
 129:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 130:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 131:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE __NO_RETURN void __cmsis_start(void)
 132:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 133:Drivers/CMSIS/Include/cmsis_gcc.h ****   extern void _start(void) __NO_RETURN;
 134:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 135:Drivers/CMSIS/Include/cmsis_gcc.h ****   typedef struct {
 136:Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t const* src;
 137:Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t* dest;
 138:Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t  wlen;
ARM GAS  /tmp/cc9hWwcq.s 			page 26


 139:Drivers/CMSIS/Include/cmsis_gcc.h ****   } __copy_table_t;
 140:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 141:Drivers/CMSIS/Include/cmsis_gcc.h ****   typedef struct {
 142:Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t* dest;
 143:Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t  wlen;
 144:Drivers/CMSIS/Include/cmsis_gcc.h ****   } __zero_table_t;
 145:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 146:Drivers/CMSIS/Include/cmsis_gcc.h ****   extern const __copy_table_t __copy_table_start__;
 147:Drivers/CMSIS/Include/cmsis_gcc.h ****   extern const __copy_table_t __copy_table_end__;
 148:Drivers/CMSIS/Include/cmsis_gcc.h ****   extern const __zero_table_t __zero_table_start__;
 149:Drivers/CMSIS/Include/cmsis_gcc.h ****   extern const __zero_table_t __zero_table_end__;
 150:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 151:Drivers/CMSIS/Include/cmsis_gcc.h ****   for (__copy_table_t const* pTable = &__copy_table_start__; pTable < &__copy_table_end__; ++pTable
 152:Drivers/CMSIS/Include/cmsis_gcc.h ****     for(uint32_t i=0u; i<pTable->wlen; ++i) {
 153:Drivers/CMSIS/Include/cmsis_gcc.h ****       pTable->dest[i] = pTable->src[i];
 154:Drivers/CMSIS/Include/cmsis_gcc.h ****     }
 155:Drivers/CMSIS/Include/cmsis_gcc.h ****   }
 156:Drivers/CMSIS/Include/cmsis_gcc.h ****  
 157:Drivers/CMSIS/Include/cmsis_gcc.h ****   for (__zero_table_t const* pTable = &__zero_table_start__; pTable < &__zero_table_end__; ++pTable
 158:Drivers/CMSIS/Include/cmsis_gcc.h ****     for(uint32_t i=0u; i<pTable->wlen; ++i) {
 159:Drivers/CMSIS/Include/cmsis_gcc.h ****       pTable->dest[i] = 0u;
 160:Drivers/CMSIS/Include/cmsis_gcc.h ****     }
 161:Drivers/CMSIS/Include/cmsis_gcc.h ****   }
 162:Drivers/CMSIS/Include/cmsis_gcc.h ****  
 163:Drivers/CMSIS/Include/cmsis_gcc.h ****   _start();
 164:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 165:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 166:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __PROGRAM_START           __cmsis_start
 167:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 168:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 169:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __INITIAL_SP
 170:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __INITIAL_SP              __StackTop
 171:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 172:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 173:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __STACK_LIMIT
 174:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __STACK_LIMIT             __StackLimit
 175:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 176:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 177:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __VECTOR_TABLE
 178:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __VECTOR_TABLE            __Vectors
 179:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 180:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 181:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __VECTOR_TABLE_ATTRIBUTE
 182:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __VECTOR_TABLE_ATTRIBUTE  __attribute((used, section(".vectors")))
 183:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 184:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 185:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
 186:Drivers/CMSIS/Include/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 187:Drivers/CMSIS/Include/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 188:Drivers/CMSIS/Include/cmsis_gcc.h ****   @{
 189:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 190:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 191:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 192:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
 193:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
 194:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 195:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
ARM GAS  /tmp/cc9hWwcq.s 			page 27


 196:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_irq(void)
 197:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 198:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 199:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 200:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 201:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 202:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 203:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 204:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
 205:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 206:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 207:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_irq(void)
 208:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 209:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 253              		.loc 3 209 3
 254              		.syntax unified
 255              	@ 209 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 256 0010 72B6     		cpsid i
 257              	@ 0 "" 2
 210:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 258              		.loc 3 210 1
 259              		.thumb
 260              		.syntax unified
 261 0012 00BF     		nop
 262              	.LBE7:
 263              	.LBE6:
 300:Inc/mc_math.h ****   uint32_t temp_val;
 301:Inc/mc_math.h ****   __disable_irq();
 302:Inc/mc_math.h ****   /* Configure and call to CORDIC- */
 303:Inc/mc_math.h ****   WRITE_REG(CORDIC->CSR,CORDIC_CONFIG_MODULUS);
 264              		.loc 2 303 3
 265 0014 114B     		ldr	r3, .L11
 266 0016 124A     		ldr	r2, .L11+4
 267 0018 1A60     		str	r2, [r3]
 304:Inc/mc_math.h ****   LL_CORDIC_WriteData(CORDIC, (((uint32_t)beta << 16U) | (((uint32_t)alpha) & 0x0000FFFFU)));
 268              		.loc 2 304 33
 269 001a B7F90430 		ldrsh	r3, [r7, #4]
 270              		.loc 2 304 48
 271 001e 1A04     		lsls	r2, r3, #16
 272              		.loc 2 304 60
 273 0020 B7F90630 		ldrsh	r3, [r7, #6]
 274              		.loc 2 304 77
 275 0024 9BB2     		uxth	r3, r3
 276              		.loc 2 304 3
 277 0026 1343     		orrs	r3, r3, r2
 278 0028 1946     		mov	r1, r3
 279 002a 0C48     		ldr	r0, .L11
 280 002c FFF7FEFF 		bl	LL_CORDIC_WriteData
 305:Inc/mc_math.h ****   /* Wait for result */
 306:Inc/mc_math.h ****   while(LL_CORDIC_IsActiveFlag_RRDY(CORDIC) == 0U)
 281              		.loc 2 306 8
 282 0030 00BF     		nop
 283              	.L9:
 284              		.loc 2 306 9 discriminator 1
 285 0032 0A48     		ldr	r0, .L11
 286 0034 FFF7FEFF 		bl	LL_CORDIC_IsActiveFlag_RRDY
 287 0038 0346     		mov	r3, r0
ARM GAS  /tmp/cc9hWwcq.s 			page 28


 288              		.loc 2 306 8 discriminator 1
 289 003a 002B     		cmp	r3, #0
 290 003c F9D0     		beq	.L9
 307:Inc/mc_math.h ****   {
 308:Inc/mc_math.h ****     /* Nothing to do */
 309:Inc/mc_math.h ****   }
 310:Inc/mc_math.h ****   /* Read computed modulus */
 311:Inc/mc_math.h ****   temp_val = ((LL_CORDIC_ReadData(CORDIC) << 16U) >> 16U); /* Avoid Over/underflow when cast to int
 291              		.loc 2 311 16
 292 003e 0748     		ldr	r0, .L11
 293 0040 FFF7FEFF 		bl	LL_CORDIC_ReadData
 294 0044 0346     		mov	r3, r0
 295              		.loc 2 311 12
 296 0046 9BB2     		uxth	r3, r3
 297 0048 FB60     		str	r3, [r7, #12]
 298              	.LBB8:
 299              	.LBB9:
 198:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 300              		.loc 3 198 3
 301              		.syntax unified
 302              	@ 198 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 303 004a 62B6     		cpsie i
 304              	@ 0 "" 2
 199:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 305              		.loc 3 199 1
 306              		.thumb
 307              		.syntax unified
 308 004c 00BF     		nop
 309              	.LBE9:
 310              	.LBE8:
 312:Inc/mc_math.h ****   __enable_irq();
 313:Inc/mc_math.h ****   return ((int16_t)temp_val);
 311              		.loc 2 313 11
 312 004e FB68     		ldr	r3, [r7, #12]
 313 0050 1BB2     		sxth	r3, r3
 314:Inc/mc_math.h **** 
 315:Inc/mc_math.h **** }
 314              		.loc 2 315 1
 315 0052 1846     		mov	r0, r3
 316 0054 1037     		adds	r7, r7, #16
 317              	.LCFI21:
 318              		.cfi_def_cfa_offset 8
 319 0056 BD46     		mov	sp, r7
 320              	.LCFI22:
 321              		.cfi_def_cfa_register 13
 322              		@ sp needed
 323 0058 80BD     		pop	{r7, pc}
 324              	.L12:
 325 005a 00BF     		.align	2
 326              	.L11:
 327 005c 000C0240 		.word	1073875968
 328 0060 63006000 		.word	6291555
 329              		.cfi_endproc
 330              	.LFE1435:
 332              		.section	.text.SPD_Check,"ax",%progbits
 333              		.align	1
 334              		.syntax unified
ARM GAS  /tmp/cc9hWwcq.s 			page 29


 335              		.thumb
 336              		.thumb_func
 337              		.fpu fpv4-sp-d16
 339              	SPD_Check:
 340              	.LFB1441:
 341              		.file 4 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h"
   1:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** /**
   2:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   ******************************************************************************
   3:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @file    speed_pos_fdbk.h
   4:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @author  Motor Control SDK Team, ST Microelectronics
   5:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @brief   This file provides all definitions and functions prototypes
   6:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   *          of the Speed & Position Feedback component of the Motor Control SDK.
   7:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   *
   8:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   ******************************************************************************
   9:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @attention
  10:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   *
  11:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * <h2><center>&copy; Copyright (c) 2024 STMicroelectronics.
  12:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * All rights reserved.</center></h2>
  13:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   *
  14:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * This software component is licensed by ST under Ultimate Liberty license
  15:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * SLA0044, the "License"; You may not use this file except in compliance with
  16:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * the License. You may obtain a copy of the License at:
  17:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   *                             www.st.com/SLA0044
  18:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   *
  19:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   ******************************************************************************
  20:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @ingroup SpeednPosFdbk
  21:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   */
  22:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
  23:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** /* Define to prevent recursive inclusion -------------------------------------*/
  24:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** #ifndef SPEEDNPOSFDBK_H
  25:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** #define SPEEDNPOSFDBK_H
  26:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
  27:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** #ifdef __cplusplus
  28:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** extern "C" {
  29:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** #endif /* __cplusplus */
  30:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
  31:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** /* Includes ------------------------------------------------------------------*/
  32:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** /* Already into mc_type.h */
  33:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** /* #include "stdint.h" */
  34:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** #include "mc_type.h"
  35:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
  36:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** /** @addtogroup MCSDK
  37:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @{
  38:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   */
  39:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
  40:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** /** @addtogroup SpeednPosFdbk
  41:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @{
  42:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   */
  43:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
  44:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** /* Exported types ------------------------------------------------------------*/
  45:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** /**
  46:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @brief  SpeednPosFdbk  handles definitions of mechanical and electrical speed, mechanical accel
  47:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   *                        and electrical angle and all constants and scale values for a reliable m
  48:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   *                        computation in appropriated unit.
  49:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   */
  50:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** typedef struct
  51:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** {
ARM GAS  /tmp/cc9hWwcq.s 			page 30


  52:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
  53:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   uint8_t bSpeedErrorNumber;          /*!< Number of time the average mechanical speed is not valid
  54:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   uint8_t bElToMecRatio;              /*!< Coefficient used to transform electrical to mechanical q
  55:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****                                            viceversa. It usually coincides with motor pole pairs nu
  56:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   uint8_t SpeedUnit;                  /*!< The speed unit value is defined into mc_stm_types.h by
  57:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****                                            [SPEED_UNIT](measurement_units.md) in tenth of Hertz.*/
  58:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   uint8_t bMaximumSpeedErrorsNumber;  /*!< Maximum value of not valid speed measurements before an 
  59:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   int16_t hElAngle;                   /*!< Estimated electrical angle reported by the implemented s
  60:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****                                            method. */
  61:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   int16_t hMecAngle;                  /*!< Instantaneous measure of rotor mechanical angle. */
  62:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   int32_t wMecAngle;                  /*!< Mechanical angle frame based on coefficient #bElToMecRat
  63:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   int16_t hAvrMecSpeedUnit;           /*!< Average mechanical speed expressed in the unit defined b
  64:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****                                            [SPEED_UNIT](measurement_units.md). */
  65:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   int16_t hElSpeedDpp;                /*!< Instantaneous electrical speed expressed in Digit Per co
  66:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****                                            ([dpp](measurement_units.md)),
  67:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****                                            expresses the angular speed as the variation of the elec
  68:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   int16_t InstantaneousElSpeedDpp;    /*!< Instantaneous computed electrical speed, expressed in
  69:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****                                            [dpp](measurement_units.md). */
  70:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   int16_t hMecAccelUnitP;             /*!< Average mechanical acceleration expressed in the unit de
  71:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****                                            only reported with encoder implementation */
  72:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   uint16_t hMaxReliableMecSpeedUnit;  /*!< Maximum value of measured mechanical speed that is consi
  73:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****                                            Expressed in the unit defined by [SPEED_UNIT](measuremen
  74:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   uint16_t hMinReliableMecSpeedUnit;  /*!< Minimum value of measured mechanical speed that is consi
  75:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****                                            Expressed in the unit defined by [SPEED_UNIT](measuremen
  76:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   uint16_t hMaxReliableMecAccelUnitP; /*!< Maximum value of measured acceleration that is considere
  77:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****                                            Constant value equal to 65535, expressed in the unit def
  78:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****                                            [SPEED_UNIT](measurement_units.md). */
  79:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   uint16_t hMeasurementFrequency;     /*!< Frequency at which the user will request a measurement o
  80:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****                                            electrical angle. Expressed in PWM_FREQ_SCALING * Hz. */
  81:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   uint32_t DPPConvFactor;             /*!< Conversion factor (65536/#PWM_FREQ_SCALING) used to conv
  82:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****                                            from the unit defined by [SPEED_UNIT](measurement_units.
  83:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****                                            [dpp](measurement_units.md). */
  84:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
  85:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
  86:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** } SpeednPosFdbk_Handle_t;
  87:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
  88:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** /**
  89:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @brief input structure type definition for SPD_CalcAngle
  90:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   */
  91:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** typedef struct
  92:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** {
  93:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   alphabeta_t  Valfa_beta;            /*!< Voltage Components in alfa beta reference frame */
  94:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   alphabeta_t  Ialfa_beta;            /*!< Current Components in alfa beta reference frame */
  95:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   uint16_t     Vbus;                  /*!< Virtual Bus Voltage information */
  96:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** } Observer_Inputs_t;
  97:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
  98:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
  99:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** int32_t SPD_GetMecAngle(const SpeednPosFdbk_Handle_t *pHandle);
 100:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
 101:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** int16_t SPD_GetAvrgMecSpeedUnit(const SpeednPosFdbk_Handle_t *pHandle);
 102:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
 103:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** int16_t SPD_GetElSpeedDpp(const SpeednPosFdbk_Handle_t *pHandle);
 104:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
 105:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** bool SPD_IsMecSpeedReliable(SpeednPosFdbk_Handle_t *pHandle, const int16_t *pMecSpeedUnit);
 106:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
 107:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** int16_t SPD_GetS16Speed(const SpeednPosFdbk_Handle_t *pHandle);
 108:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
ARM GAS  /tmp/cc9hWwcq.s 			page 31


 109:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** uint8_t SPD_GetElToMecRatio(const SpeednPosFdbk_Handle_t *pHandle);
 110:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
 111:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** void SPD_SetElToMecRatio(SpeednPosFdbk_Handle_t *pHandle, uint8_t bPP);
 112:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
 113:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** /**
 114:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @brief  Returns the last computed rotor electrical angle, expressed in [s16degrees](measurement
 115:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @param  pHandle: handler of the current instance of the SpeednPosFdbk component.
 116:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @retval int16_t rotor electrical angle.
 117:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   */
 118:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** static inline int16_t SPD_GetElAngle(const SpeednPosFdbk_Handle_t *pHandle)
 119:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** {
 120:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** #ifdef NULL_PTR_CHECK_SPD_POS_FBK
 121:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   return ((MC_NULL == pHandle) ? 0 : pHandle->hElAngle);
 122:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** #else
 123:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   return (pHandle->hElAngle);
 124:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** #endif
 125:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** }
 126:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
 127:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** /**
 128:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @brief  Returns the last instantaneous computed electrical speed, expressed in [dpp](measuremen
 129:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @param  pHandle: handler of the current instance of the SpeednPosFdbk component.
 130:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @retval int16_t rotor instantaneous electrical speed ([dpp](measurement_units.md)).
 131:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   *
 132:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * - The control period is the period on which the rotor electrical angle is computed thanks to HA
 133:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   *   functions.
 134:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * - Called during FOC drive control for Iqd currents regulation.
 135:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   */
 136:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** static inline int16_t SPD_GetInstElSpeedDpp(const SpeednPosFdbk_Handle_t *pHandle)
 137:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** {
 138:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** #ifdef NULL_PTR_CHECK_SPD_POS_FBK
 139:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   return ((MC_NULL == pHandle) ? 0 : pHandle->InstantaneousElSpeedDpp);
 140:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** #else
 141:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   return (pHandle->InstantaneousElSpeedDpp);
 142:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** #endif
 143:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** }
 144:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** 
 145:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** /**
 146:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @brief  Returns the result of the last reliability check performed.
 147:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @param  pHandle: handler of the current instance of the SpeednPosFdbk component.
 148:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @retval bool sensor reliability state.
 149:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   *
 150:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * - Reliability is measured with reference to parameters
 151:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @ref SpeednPosFdbk_Handle_t::hMaxReliableMecSpeedUnit "hMaxReliableMecSpeedUnit",
 152:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @ref SpeednPosFdbk_Handle_t::hMinReliableMecSpeedUnit "hMaxReliableMecSpeedUnit",
 153:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * @ref SpeednPosFdbk_Handle_t::bMaximumSpeedErrorsNumber "bMaximumSpeedErrorsNumber".
 154:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * - If the number of time the average mechanical speed is not valid matches the
 155:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   *  maximum value of not valid speed measurements, sensor information is not reliable.
 156:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * - Embedded into construction of the MC_GetSpeedSensorReliabilityMotor API.
 157:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * - The return value is a boolean that expresses:\n
 158:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * -- true  = sensor information is reliable.\n
 159:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   * -- false = sensor information is not reliable.
 160:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   */
 161:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** static inline bool SPD_Check(const SpeednPosFdbk_Handle_t *pHandle)
 162:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** {
 342              		.loc 4 162 1
 343              		.cfi_startproc
 344              		@ args = 0, pretend = 0, frame = 16
ARM GAS  /tmp/cc9hWwcq.s 			page 32


 345              		@ frame_needed = 1, uses_anonymous_args = 0
 346              		@ link register save eliminated.
 347 0000 80B4     		push	{r7}
 348              	.LCFI23:
 349              		.cfi_def_cfa_offset 4
 350              		.cfi_offset 7, -4
 351 0002 85B0     		sub	sp, sp, #20
 352              	.LCFI24:
 353              		.cfi_def_cfa_offset 24
 354 0004 00AF     		add	r7, sp, #0
 355              	.LCFI25:
 356              		.cfi_def_cfa_register 7
 357 0006 7860     		str	r0, [r7, #4]
 163:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   bool SpeedSensorReliability = true;
 358              		.loc 4 163 8
 359 0008 0123     		movs	r3, #1
 360 000a FB73     		strb	r3, [r7, #15]
 164:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** #ifdef NULL_PTR_CHECK_SPD_POS_FBK
 165:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   if ((MC_NULL == pHandle) || (pHandle->bSpeedErrorNumber == pHandle->bMaximumSpeedErrorsNumber))
 166:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** #else
 167:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   if (pHandle->bSpeedErrorNumber == pHandle->bMaximumSpeedErrorsNumber)
 361              		.loc 4 167 14
 362 000c 7B68     		ldr	r3, [r7, #4]
 363 000e 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 364              		.loc 4 167 44
 365 0010 7B68     		ldr	r3, [r7, #4]
 366 0012 DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 367              		.loc 4 167 6
 368 0014 9A42     		cmp	r2, r3
 369 0016 01D1     		bne	.L14
 168:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** #endif
 169:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   {
 170:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****     SpeedSensorReliability = false;
 370              		.loc 4 170 28
 371 0018 0023     		movs	r3, #0
 372 001a FB73     		strb	r3, [r7, #15]
 373              	.L14:
 171:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   }
 172:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   else
 173:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   {
 174:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****     /* Nothing to do */
 175:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   }
 176:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h ****   return (SpeedSensorReliability);
 374              		.loc 4 176 10
 375 001c FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 177:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h **** }
 376              		.loc 4 177 1
 377 001e 1846     		mov	r0, r3
 378 0020 1437     		adds	r7, r7, #20
 379              	.LCFI26:
 380              		.cfi_def_cfa_offset 4
 381 0022 BD46     		mov	sp, r7
 382              	.LCFI27:
 383              		.cfi_def_cfa_register 13
 384              		@ sp needed
 385 0024 5DF8047B 		ldr	r7, [sp], #4
 386              	.LCFI28:
ARM GAS  /tmp/cc9hWwcq.s 			page 33


 387              		.cfi_restore 7
 388              		.cfi_def_cfa_offset 0
 389 0028 7047     		bx	lr
 390              		.cfi_endproc
 391              	.LFE1441:
 393              		.section	.text.STC_StopRamp,"ax",%progbits
 394              		.align	1
 395              		.syntax unified
 396              		.thumb
 397              		.thumb_func
 398              		.fpu fpv4-sp-d16
 400              	STC_StopRamp:
 401              	.LFB1443:
 402              		.file 5 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h"
   1:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** /**
   2:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   ******************************************************************************
   3:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * @file    speed_torq_ctrl.h
   4:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * @author  Motor Control SDK Team, ST Microelectronics
   5:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * @brief   This file contains all definitions and functions prototypes for the
   6:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   *          Speed & Torque Control component of the Motor Control SDK.
   7:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   ******************************************************************************
   8:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * @attention
   9:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   *
  10:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * <h2><center>&copy; Copyright (c) 2024 STMicroelectronics.
  11:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * All rights reserved.</center></h2>
  12:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   *
  13:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * This software component is licensed by ST under Ultimate Liberty license
  14:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * SLA0044, the "License"; You may not use this file except in compliance with
  15:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * the License. You may obtain a copy of the License at:
  16:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   *                             www.st.com/SLA0044
  17:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   *
  18:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   ******************************************************************************
  19:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * @ingroup SpeednTorqCtrlClassic
  20:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   */
  21:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** 
  22:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** /* Define to prevent recursive inclusion -------------------------------------*/
  23:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** #ifndef SPEEDNTORQCTRLCLASS_H
  24:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** #define SPEEDNTORQCTRLCLASS_H
  25:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** 
  26:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** #ifdef __cplusplus
  27:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** extern "C" {
  28:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** #endif /* __cplusplus */
  29:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** 
  30:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** /* Includes ------------------------------------------------------------------*/
  31:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** #include "mc_type.h"
  32:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** #include "pid_regulator.h"
  33:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** #include "speed_pos_fdbk.h"
  34:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** 
  35:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** /** @addtogroup MCSDK
  36:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * @{
  37:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   */
  38:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** 
  39:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** /** @addtogroup SpeednTorqCtrl
  40:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * @{
  41:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   */
  42:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** 
  43:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** /** @addtogroup SpeednTorqCtrlClassic
ARM GAS  /tmp/cc9hWwcq.s 			page 34


  44:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * @{
  45:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   */
  46:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** 
  47:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** /* Exported types ------------------------------------------------------------*/
  48:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** 
  49:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** /**
  50:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * @brief  Speed & Torque Control parameters definition
  51:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   */
  52:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** typedef struct
  53:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** {
  54:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   MC_ControlMode_t Mode;               /*!< Modality of STC. It can be one of these two settings:
  55:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****                                            MCM_TORQUE_MODE to enable the Torque mode or
  56:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****                                            MCM_SPEED_MODE to enable the Speed mode. */
  57:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   int16_t TargetFinal;                 /*!< Backup of #hTargetFinal to be applied in the last step.
  58:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   int32_t SpeedRefUnitExt;             /*!< Current mechanical rotor speed reference expressed in
  59:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****                                             [SPEED_UNIT](measurement_units.md) multiplied by 65536.
  60:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   int32_t TorqueRef;                   /*!< Current motor torque reference. This value represents a
  61:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****                                             the Iq current expressed in digit multiplied by 65536. 
  62:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   uint32_t RampRemainingStep;          /*!< Number of steps remaining to complete the ramp. */
  63:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   PID_Handle_t *PISpeed;               /*!< The regulator used to perform the speed control loop. *
  64:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   SpeednPosFdbk_Handle_t *SPD;         /*!< The speed sensor used to perform the speed regulation. 
  65:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   int32_t IncDecAmount;                /*!< Increment/decrement amount to be applied to the referen
  66:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****                                             #CalcTorqueReference. */
  67:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   uint16_t STCFrequencyHz;             /*!< Frequency on which the user updates the torque referenc
  68:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****                                             #STC_CalcTorqueReference method expressed in Hz */
  69:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   uint16_t MaxAppPositiveMecSpeedUnit; /*!< Application maximum positive value of the rotor mechani
  70:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****                                             Expressed in the unit defined by [SPEED_UNIT](measureme
  71:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   uint16_t MinAppPositiveMecSpeedUnit; /*!< Application minimum positive value of the rotor mechani
  72:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****                                             Expressed in the unit defined by [SPEED_UNIT](measureme
  73:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   int16_t MaxAppNegativeMecSpeedUnit;  /*!< Application maximum negative value of the rotor mechani
  74:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****                                             Expressed in the unit defined by [SPEED_UNIT](measureme
  75:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   int16_t MinAppNegativeMecSpeedUnit;  /*!< Application minimum negative value of the rotor mechani
  76:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****                                             Expressed in the unit defined by [SPEED_UNIT](measureme
  77:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   uint16_t MaxPositiveTorque;          /*!< Maximum positive value of motor torque. This value repr
  78:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****                                             the maximum Iq current expressed in digit. */
  79:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   int16_t MinNegativeTorque;           /*!< Minimum negative value of motor torque. This value repr
  80:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****                                             the maximum Iq current expressed in digit. */
  81:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   MC_ControlMode_t ModeDefault;        /*!< Default STC modality. */
  82:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   int16_t MecSpeedRefUnitDefault;      /*!< Default mechanical rotor speed reference expressed in t
  83:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****                                             [SPEED_UNIT](measurement_units.md). */
  84:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   int16_t TorqueRefDefault;            /*!< Default motor torque reference. This value represents a
  85:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****                                             current reference expressed in digit. */
  86:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   int16_t IdrefDefault;                /*!< Default Id current reference expressed in digit. */
  87:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** } SpeednTorqCtrl_Handle_t;
  88:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** 
  89:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** 
  90:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** 
  91:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** /* Initializes all the object variables */
  92:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** void STC_Init(SpeednTorqCtrl_Handle_t *pHandle, PID_Handle_t *pPI, SpeednPosFdbk_Handle_t *SPD_Hand
  93:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** 
  94:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** /* Resets the integral term of speed regulator */
  95:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** void STC_Clear(SpeednTorqCtrl_Handle_t *pHandle);
  96:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** 
  97:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** /* Gets the current mechanical rotor speed reference */
  98:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** int16_t STC_GetMecSpeedRefUnit(SpeednTorqCtrl_Handle_t *pHandle);
  99:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** 
 100:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** /* Sets the mode of the speed and torque controller (Torque mode or Speed mode) */
ARM GAS  /tmp/cc9hWwcq.s 			page 35


 101:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** void STC_SetControlMode(SpeednTorqCtrl_Handle_t *pHandle, MC_ControlMode_t bMode);
 102:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** 
 103:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** /* Starts the execution of a ramp using new target and duration */
 104:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** bool STC_ExecRamp(SpeednTorqCtrl_Handle_t *pHandle, int16_t hTargetFinal, uint32_t hDurationms);
 105:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** 
 106:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** /* Computes the new value of motor torque reference */
 107:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** int16_t STC_CalcTorqueReference(SpeednTorqCtrl_Handle_t *pHandle);
 108:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** 
 109:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** /* Gets the Default mechanical rotor speed reference */
 110:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** int16_t STC_GetMecSpeedRefUnitDefault(SpeednTorqCtrl_Handle_t *pHandle);
 111:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** 
 112:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** /* Returns the Application maximum positive rotor mechanical speed */
 113:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** uint16_t STC_GetMaxAppPositiveMecSpeedUnit(SpeednTorqCtrl_Handle_t *pHandle);
 114:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** 
 115:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** /* Returns the Application minimum negative rotor mechanical speed */
 116:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** int16_t STC_GetMinAppNegativeMecSpeedUnit(SpeednTorqCtrl_Handle_t *pHandle);
 117:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** 
 118:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** /* Stops the execution of speed ramp */
 119:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** bool STC_StopSpeedRamp(SpeednTorqCtrl_Handle_t *pHandle);
 120:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** 
 121:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** /* Sets in real time the speed sensor utilized by the FOC */
 122:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** void STC_SetSpeedSensor(SpeednTorqCtrl_Handle_t *pHandle, SpeednPosFdbk_Handle_t *SPD_Handle);
 123:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** 
 124:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** /* It returns the default values of Iqdref */
 125:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** qd_t STC_GetDefaultIqdref(SpeednTorqCtrl_Handle_t *pHandle);
 126:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** 
 127:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** /* Forces the speed reference to the current speed */
 128:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** void STC_ForceSpeedReferenceToCurrentSpeed(SpeednTorqCtrl_Handle_t *pHandle);
 129:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** 
 130:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** /**
 131:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * @brief  Gets the modality of the speed and torque controller
 132:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   *           @ref SpeednTorqCtrl_Handle_t::Mode "Mode".
 133:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * @param  pHandle: handler of the current instance of the SpeednTorqCtrl component.
 134:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * @retval MC_ControlMode_t  modality of STC. It can be one of
 135:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   *         these two values: MCM_TORQUE_MODE or MCM_SPEED_MODE.
 136:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   *
 137:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * - Called by @ref SpeedRegulatorPotentiometer Speed potentiometer component to manage new speed 
 138:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   */
 139:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** static inline MC_ControlMode_t STC_GetControlMode(SpeednTorqCtrl_Handle_t *pHandle)
 140:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** {
 141:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** #ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
 142:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   return ((MC_NULL == pHandle) ? MCM_TORQUE_MODE : pHandle->Mode);
 143:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** #else
 144:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   return (pHandle->Mode);
 145:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** #endif
 146:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** }
 147:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** 
 148:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** /**
 149:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * @brief  Interrupts the execution of any previous ramp command in particular by clearing
 150:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   *         the number of steps remaining to complete the ramp
 151:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   *         @ref SpeednTorqCtrl_Handle_t::RampRemainingStep "RampRemainingStep".
 152:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * @param  pHandle: handler of the current instance of the SpeednTorqCtrl component.
 153:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * @retval none
 154:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   *
 155:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * - If STC has been set in Torque mode the last value of Iq is maintained.\n
 156:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * - If STC has been set in Speed mode the last value of mechanical
 157:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * rotor speed reference is maintained.
ARM GAS  /tmp/cc9hWwcq.s 			page 36


 158:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * - Called by MCI_StopSpeedRamp execution command.
 159:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   */
 160:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** static inline void STC_StopRamp(SpeednTorqCtrl_Handle_t *pHandle)
 161:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** {
 403              		.loc 5 161 1
 404              		.cfi_startproc
 405              		@ args = 0, pretend = 0, frame = 8
 406              		@ frame_needed = 1, uses_anonymous_args = 0
 407              		@ link register save eliminated.
 408 0000 80B4     		push	{r7}
 409              	.LCFI29:
 410              		.cfi_def_cfa_offset 4
 411              		.cfi_offset 7, -4
 412 0002 83B0     		sub	sp, sp, #12
 413              	.LCFI30:
 414              		.cfi_def_cfa_offset 16
 415 0004 00AF     		add	r7, sp, #0
 416              	.LCFI31:
 417              		.cfi_def_cfa_register 7
 418 0006 7860     		str	r0, [r7, #4]
 162:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** #ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
 163:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   if (MC_NULL == pHandle)
 164:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   {
 165:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****     /* Nothing to do */
 166:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   }
 167:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   else
 168:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   {
 169:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** #endif
 170:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****     pHandle->RampRemainingStep = 0U;
 419              		.loc 5 170 32
 420 0008 7B68     		ldr	r3, [r7, #4]
 421 000a 0022     		movs	r2, #0
 422 000c DA60     		str	r2, [r3, #12]
 171:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****     pHandle->IncDecAmount = 0;
 423              		.loc 5 171 27
 424 000e 7B68     		ldr	r3, [r7, #4]
 425 0010 0022     		movs	r2, #0
 426 0012 9A61     		str	r2, [r3, #24]
 172:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** #ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
 173:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   }
 174:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** #endif
 175:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** }
 427              		.loc 5 175 1
 428 0014 00BF     		nop
 429 0016 0C37     		adds	r7, r7, #12
 430              	.LCFI32:
 431              		.cfi_def_cfa_offset 4
 432 0018 BD46     		mov	sp, r7
 433              	.LCFI33:
 434              		.cfi_def_cfa_register 13
 435              		@ sp needed
 436 001a 5DF8047B 		ldr	r7, [sp], #4
 437              	.LCFI34:
 438              		.cfi_restore 7
 439              		.cfi_def_cfa_offset 0
 440 001e 7047     		bx	lr
 441              		.cfi_endproc
ARM GAS  /tmp/cc9hWwcq.s 			page 37


 442              	.LFE1443:
 444              		.section	.text.STC_RampCompleted,"ax",%progbits
 445              		.align	1
 446              		.syntax unified
 447              		.thumb
 448              		.thumb_func
 449              		.fpu fpv4-sp-d16
 451              	STC_RampCompleted:
 452              	.LFB1444:
 176:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** 
 177:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** /**
 178:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * @brief  Checks if the settled speed or torque ramp has been completed by checking zero value of
 179:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   *           @ref SpeednTorqCtrl_Handle_t::RampRemainingStep "RampRemainingStep".
 180:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * @param  pHandle: handler of the current instance of the SpeednTorqCtrl component.
 181:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * @retval bool returning true if the ramp is completed, false otherwise.
 182:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   *
 183:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * - Called during motor profiler tuning of HALL sensor.
 184:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   */
 185:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** static inline bool STC_RampCompleted(SpeednTorqCtrl_Handle_t *pHandle)
 186:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** {
 453              		.loc 5 186 1
 454              		.cfi_startproc
 455              		@ args = 0, pretend = 0, frame = 16
 456              		@ frame_needed = 1, uses_anonymous_args = 0
 457              		@ link register save eliminated.
 458 0000 80B4     		push	{r7}
 459              	.LCFI35:
 460              		.cfi_def_cfa_offset 4
 461              		.cfi_offset 7, -4
 462 0002 85B0     		sub	sp, sp, #20
 463              	.LCFI36:
 464              		.cfi_def_cfa_offset 24
 465 0004 00AF     		add	r7, sp, #0
 466              	.LCFI37:
 467              		.cfi_def_cfa_register 7
 468 0006 7860     		str	r0, [r7, #4]
 187:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   bool retVal = false;
 469              		.loc 5 187 8
 470 0008 0023     		movs	r3, #0
 471 000a FB73     		strb	r3, [r7, #15]
 188:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** #ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
 189:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   if (MC_NULL == pHandle)
 190:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   {
 191:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****     /* Nothing to do */
 192:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   }
 193:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   else
 194:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   {
 195:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** #endif
 196:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****     if (0U == pHandle->RampRemainingStep)
 472              		.loc 5 196 22
 473 000c 7B68     		ldr	r3, [r7, #4]
 474 000e DB68     		ldr	r3, [r3, #12]
 475              		.loc 5 196 8
 476 0010 002B     		cmp	r3, #0
 477 0012 01D1     		bne	.L18
 197:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****     {
 198:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****       retVal = true;
ARM GAS  /tmp/cc9hWwcq.s 			page 38


 478              		.loc 5 198 14
 479 0014 0123     		movs	r3, #1
 480 0016 FB73     		strb	r3, [r7, #15]
 481              	.L18:
 199:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****     }
 200:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** #ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
 201:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   }
 202:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** #endif
 203:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   return (retVal);
 482              		.loc 5 203 10
 483 0018 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 204:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** }
 484              		.loc 5 204 1
 485 001a 1846     		mov	r0, r3
 486 001c 1437     		adds	r7, r7, #20
 487              	.LCFI38:
 488              		.cfi_def_cfa_offset 4
 489 001e BD46     		mov	sp, r7
 490              	.LCFI39:
 491              		.cfi_def_cfa_register 13
 492              		@ sp needed
 493 0020 5DF8047B 		ldr	r7, [sp], #4
 494              	.LCFI40:
 495              		.cfi_restore 7
 496              		.cfi_def_cfa_offset 0
 497 0024 7047     		bx	lr
 498              		.cfi_endproc
 499              	.LFE1444:
 501              		.section	.text.STC_GetSpeedSensor,"ax",%progbits
 502              		.align	1
 503              		.syntax unified
 504              		.thumb
 505              		.thumb_func
 506              		.fpu fpv4-sp-d16
 508              	STC_GetSpeedSensor:
 509              	.LFB1446:
 205:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** 
 206:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** /**
 207:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * @brief  Changes the nominal current by setting new values of
 208:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   *         @ref SpeednTorqCtrl_Handle_t::MaxPositiveTorque "MaxPositiveTorque" and
 209:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   *         @ref SpeednTorqCtrl_Handle_t::MinNegativeTorque "MinNegativeTorque".
 210:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * @param  pHandle: handler of the current instance of the SpeednTorqCtrl component.
 211:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * @param  hNominalCurrent: represents actually the maximum Iq current expressed in digit.
 212:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * @retval none
 213:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   *
 214:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * - Not used into current implementation.
 215:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   */
 216:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** static inline void STC_SetNominalCurrent(SpeednTorqCtrl_Handle_t *pHandle, uint16_t hNominalCurrent
 217:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** {
 218:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** #ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
 219:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   if (MC_NULL == pHandle)
 220:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   {
 221:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****     /* Nothing to do */
 222:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   }
 223:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   else
 224:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   {
 225:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** #endif
ARM GAS  /tmp/cc9hWwcq.s 			page 39


 226:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****     pHandle->MaxPositiveTorque = hNominalCurrent;
 227:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****     pHandle->MinNegativeTorque = -(int16_t)hNominalCurrent;
 228:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** #ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
 229:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   }
 230:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** #endif
 231:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** }
 232:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** 
 233:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** /**
 234:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * @brief Returns the speed sensor utilized by the FOC.
 235:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * @param pHandle: handler of the current instance of the SpeednTorqCtrl component.
 236:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * @retval SpeednPosFdbk_Handle_t speed sensor utilized by the FOC.
 237:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   *
 238:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   * - Called as soon as component parameters are required by MC FW.
 239:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   */
 240:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** static inline SpeednPosFdbk_Handle_t *STC_GetSpeedSensor(SpeednTorqCtrl_Handle_t *pHandle)
 241:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** {
 510              		.loc 5 241 1
 511              		.cfi_startproc
 512              		@ args = 0, pretend = 0, frame = 8
 513              		@ frame_needed = 1, uses_anonymous_args = 0
 514              		@ link register save eliminated.
 515 0000 80B4     		push	{r7}
 516              	.LCFI41:
 517              		.cfi_def_cfa_offset 4
 518              		.cfi_offset 7, -4
 519 0002 83B0     		sub	sp, sp, #12
 520              	.LCFI42:
 521              		.cfi_def_cfa_offset 16
 522 0004 00AF     		add	r7, sp, #0
 523              	.LCFI43:
 524              		.cfi_def_cfa_register 7
 525 0006 7860     		str	r0, [r7, #4]
 242:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** #ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
 243:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   return ((MC_NULL ==  pHandle) ? MC_NULL : pHandle->SPD);
 244:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** #else
 245:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h ****   return (pHandle->SPD);
 526              		.loc 5 245 18
 527 0008 7B68     		ldr	r3, [r7, #4]
 528 000a 5B69     		ldr	r3, [r3, #20]
 246:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** #endif
 247:MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h **** }
 529              		.loc 5 247 1
 530 000c 1846     		mov	r0, r3
 531 000e 0C37     		adds	r7, r7, #12
 532              	.LCFI44:
 533              		.cfi_def_cfa_offset 4
 534 0010 BD46     		mov	sp, r7
 535              	.LCFI45:
 536              		.cfi_def_cfa_register 13
 537              		@ sp needed
 538 0012 5DF8047B 		ldr	r7, [sp], #4
 539              	.LCFI46:
 540              		.cfi_restore 7
 541              		.cfi_def_cfa_offset 0
 542 0016 7047     		bx	lr
 543              		.cfi_endproc
 544              	.LFE1446:
ARM GAS  /tmp/cc9hWwcq.s 			page 40


 546              		.section	.text.MCI_ExecSpeedRamp,"ax",%progbits
 547              		.align	1
 548              		.weak	MCI_ExecSpeedRamp
 549              		.syntax unified
 550              		.thumb
 551              		.thumb_func
 552              		.fpu fpv4-sp-d16
 554              	MCI_ExecSpeedRamp:
 555              	.LFB1713:
 556              		.file 6 "Src/mc_interface.c"
   1:Src/mc_interface.c **** 
   2:Src/mc_interface.c **** /**
   3:Src/mc_interface.c ****   ******************************************************************************
   4:Src/mc_interface.c ****   * @file    mc_interface.c
   5:Src/mc_interface.c ****   * @author  Motor Control SDK Team, ST Microelectronics
   6:Src/mc_interface.c ****   * @brief   This file provides firmware functions that implement the features
   7:Src/mc_interface.c ****   *          of the MC Interface component of the Motor Control SDK:
   8:Src/mc_interface.c ****   *
   9:Src/mc_interface.c ****   ******************************************************************************
  10:Src/mc_interface.c ****   * @attention
  11:Src/mc_interface.c ****   *
  12:Src/mc_interface.c ****   * <h2><center>&copy; Copyright (c) 2024 STMicroelectronics.
  13:Src/mc_interface.c ****   * All rights reserved.</center></h2>
  14:Src/mc_interface.c ****   *
  15:Src/mc_interface.c ****   * This software component is licensed by ST under Ultimate Liberty license
  16:Src/mc_interface.c ****   * SLA0044, the "License"; You may not use this file except in compliance with
  17:Src/mc_interface.c ****   * the License. You may obtain a copy of the License at:
  18:Src/mc_interface.c ****   *                             www.st.com/SLA0044
  19:Src/mc_interface.c ****   *
  20:Src/mc_interface.c ****   ******************************************************************************
  21:Src/mc_interface.c ****   * @ingroup MCInterface
  22:Src/mc_interface.c ****   */
  23:Src/mc_interface.c **** 
  24:Src/mc_interface.c **** /* Includes ------------------------------------------------------------------*/
  25:Src/mc_interface.c **** #include "mc_math.h"
  26:Src/mc_interface.c **** #include "speed_torq_ctrl.h"
  27:Src/mc_interface.c **** #include "mc_interface.h"
  28:Src/mc_interface.c **** #include "motorcontrol.h"
  29:Src/mc_interface.c **** 
  30:Src/mc_interface.c **** #define ROUNDING_OFF
  31:Src/mc_interface.c **** 
  32:Src/mc_interface.c **** /** @addtogroup MCSDK
  33:Src/mc_interface.c ****   * @{
  34:Src/mc_interface.c ****   */
  35:Src/mc_interface.c **** 
  36:Src/mc_interface.c **** /** @addtogroup CAI
  37:Src/mc_interface.c ****   * @{
  38:Src/mc_interface.c ****   */
  39:Src/mc_interface.c **** 
  40:Src/mc_interface.c **** /** @defgroup MCInterface Motor Control Interface
  41:Src/mc_interface.c ****   * @brief MC Interface component of the Motor Control SDK
  42:Src/mc_interface.c ****   *
  43:Src/mc_interface.c ****   *  This interface allows for performing basic operations on the motor driven by a
  44:Src/mc_interface.c ****   *  Motor Control SDK based application. With it, motors can be started and stopped, speed or
  45:Src/mc_interface.c ****   *  torque ramps can be programmed and executed and information on the state of the motor can
  46:Src/mc_interface.c ****   *  be retrieved, among others.
  47:Src/mc_interface.c ****   *
ARM GAS  /tmp/cc9hWwcq.s 			page 41


  48:Src/mc_interface.c ****   *  These functions aims at being the main interface used by an application to control the motor.
  49:Src/mc_interface.c ****   *
  50:Src/mc_interface.c ****   * @{
  51:Src/mc_interface.c ****   */
  52:Src/mc_interface.c **** /* Private macros ------------------------------------------------------------*/
  53:Src/mc_interface.c **** 
  54:Src/mc_interface.c **** #define round(x) ((x)>=0?(int32_t)((x)+0.5):(int32_t)((x)-0.5))
  55:Src/mc_interface.c **** 
  56:Src/mc_interface.c **** /* Functions -----------------------------------------------*/
  57:Src/mc_interface.c **** 
  58:Src/mc_interface.c **** /**
  59:Src/mc_interface.c ****   * @brief  Programs a motor speed ramp
  60:Src/mc_interface.c ****   *
  61:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to operate on.
  62:Src/mc_interface.c ****   * @param  hFinalSpeed The value of mechanical rotor speed reference at the
  63:Src/mc_interface.c ****   *         end of the ramp expressed in the unit defined by #SPEED_UNIT.
  64:Src/mc_interface.c ****   * @param  hDurationms The duration of the ramp expressed in milliseconds. It
  65:Src/mc_interface.c ****   *         is possible to set 0 to perform an instantaneous change in the
  66:Src/mc_interface.c ****   *         value.
  67:Src/mc_interface.c ****   *
  68:Src/mc_interface.c ****   *  This command is executed immediately if the target motor's state machine is in
  69:Src/mc_interface.c ****   * the #RUN state. Otherwise, it is buffered and its execution is delayed until This
  70:Src/mc_interface.c ****   * state is reached.
  71:Src/mc_interface.c ****   *
  72:Src/mc_interface.c ****   * Users can check the status of the command by calling the MCI_IsCommandAcknowledged()
  73:Src/mc_interface.c ****   * function.
  74:Src/mc_interface.c ****   *
  75:Src/mc_interface.c ****   * @sa MCI_ExecSpeedRamp
  76:Src/mc_interface.c ****   */
  77:Src/mc_interface.c **** __weak void MCI_ExecSpeedRamp(MCI_Handle_t *pHandle, int16_t hFinalSpeed, uint16_t hDurationms)
  78:Src/mc_interface.c **** {
 557              		.loc 6 78 1
 558              		.cfi_startproc
 559              		@ args = 0, pretend = 0, frame = 8
 560              		@ frame_needed = 1, uses_anonymous_args = 0
 561              		@ link register save eliminated.
 562 0000 80B4     		push	{r7}
 563              	.LCFI47:
 564              		.cfi_def_cfa_offset 4
 565              		.cfi_offset 7, -4
 566 0002 83B0     		sub	sp, sp, #12
 567              	.LCFI48:
 568              		.cfi_def_cfa_offset 16
 569 0004 00AF     		add	r7, sp, #0
 570              	.LCFI49:
 571              		.cfi_def_cfa_register 7
 572 0006 7860     		str	r0, [r7, #4]
 573 0008 0B46     		mov	r3, r1
 574 000a 7B80     		strh	r3, [r7, #2]	@ movhi
 575 000c 1346     		mov	r3, r2	@ movhi
 576 000e 3B80     		strh	r3, [r7]	@ movhi
  79:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
  80:Src/mc_interface.c ****   if (MC_NULL == pHandle)
  81:Src/mc_interface.c ****   {
  82:Src/mc_interface.c ****     /* Nothing to do */
  83:Src/mc_interface.c ****   }
  84:Src/mc_interface.c ****   else
ARM GAS  /tmp/cc9hWwcq.s 			page 42


  85:Src/mc_interface.c ****   {
  86:Src/mc_interface.c **** #endif
  87:Src/mc_interface.c ****     pHandle->lastCommand = MCI_CMD_EXECSPEEDRAMP;
 577              		.loc 6 87 26
 578 0010 7B68     		ldr	r3, [r7, #4]
 579 0012 0122     		movs	r2, #1
 580 0014 1A73     		strb	r2, [r3, #12]
  88:Src/mc_interface.c ****     pHandle->hFinalSpeed = hFinalSpeed;
 581              		.loc 6 88 26
 582 0016 7B68     		ldr	r3, [r7, #4]
 583 0018 7A88     		ldrh	r2, [r7, #2]	@ movhi
 584 001a DA81     		strh	r2, [r3, #14]	@ movhi
  89:Src/mc_interface.c ****     pHandle->hDurationms = hDurationms;
 585              		.loc 6 89 26
 586 001c 7B68     		ldr	r3, [r7, #4]
 587 001e 3A88     		ldrh	r2, [r7]	@ movhi
 588 0020 9A83     		strh	r2, [r3, #28]	@ movhi
  90:Src/mc_interface.c ****     pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 589              		.loc 6 90 27
 590 0022 7B68     		ldr	r3, [r7, #4]
 591 0024 0122     		movs	r2, #1
 592 0026 83F82420 		strb	r2, [r3, #36]
  91:Src/mc_interface.c ****     pHandle->LastModalitySetByUser = MCM_SPEED_MODE;
 593              		.loc 6 91 36
 594 002a 7B68     		ldr	r3, [r7, #4]
 595 002c 0322     		movs	r2, #3
 596 002e 83F82520 		strb	r2, [r3, #37]
  92:Src/mc_interface.c **** 
  93:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
  94:Src/mc_interface.c ****   }
  95:Src/mc_interface.c **** #endif
  96:Src/mc_interface.c **** }
 597              		.loc 6 96 1
 598 0032 00BF     		nop
 599 0034 0C37     		adds	r7, r7, #12
 600              	.LCFI50:
 601              		.cfi_def_cfa_offset 4
 602 0036 BD46     		mov	sp, r7
 603              	.LCFI51:
 604              		.cfi_def_cfa_register 13
 605              		@ sp needed
 606 0038 5DF8047B 		ldr	r7, [sp], #4
 607              	.LCFI52:
 608              		.cfi_restore 7
 609              		.cfi_def_cfa_offset 0
 610 003c 7047     		bx	lr
 611              		.cfi_endproc
 612              	.LFE1713:
 614              		.section	.text.MCI_ExecSpeedRamp_F,"ax",%progbits
 615              		.align	1
 616              		.weak	MCI_ExecSpeedRamp_F
 617              		.syntax unified
 618              		.thumb
 619              		.thumb_func
 620              		.fpu fpv4-sp-d16
 622              	MCI_ExecSpeedRamp_F:
 623              	.LFB1714:
ARM GAS  /tmp/cc9hWwcq.s 			page 43


  97:Src/mc_interface.c **** 
  98:Src/mc_interface.c **** /**
  99:Src/mc_interface.c ****   * @brief  Programs a motor speed ramp
 100:Src/mc_interface.c ****   *
 101:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to operate on.
 102:Src/mc_interface.c ****   * @param  FinalSpeed is the value of mechanical rotor speed reference at the
 103:Src/mc_interface.c ****   *         end of the ramp expressed in RPM.
 104:Src/mc_interface.c ****   * @param  hDurationms the duration of the ramp expressed in milliseconds. It
 105:Src/mc_interface.c ****   *         is possible to set 0 to perform an instantaneous change in the
 106:Src/mc_interface.c ****   *         value.
 107:Src/mc_interface.c ****   *
 108:Src/mc_interface.c ****   *  This command is executed immediately if the target motor's state machine is in
 109:Src/mc_interface.c ****   * the #RUN state. Otherwise, it is buffered and its execution is delayed until This
 110:Src/mc_interface.c ****   * state is reached.
 111:Src/mc_interface.c ****   *
 112:Src/mc_interface.c ****   * Users can check the status of the command by calling the MCI_IsCommandAcknowledged()
 113:Src/mc_interface.c ****   * function.
 114:Src/mc_interface.c ****   *
 115:Src/mc_interface.c ****   * @sa MCI_ExecSpeedRamp_F
 116:Src/mc_interface.c ****   */
 117:Src/mc_interface.c **** __weak void MCI_ExecSpeedRamp_F(MCI_Handle_t *pHandle, const float_t FinalSpeed, uint16_t hDuration
 118:Src/mc_interface.c **** {
 624              		.loc 6 118 1
 625              		.cfi_startproc
 626              		@ args = 0, pretend = 0, frame = 24
 627              		@ frame_needed = 1, uses_anonymous_args = 0
 628 0000 80B5     		push	{r7, lr}
 629              	.LCFI53:
 630              		.cfi_def_cfa_offset 8
 631              		.cfi_offset 7, -8
 632              		.cfi_offset 14, -4
 633 0002 86B0     		sub	sp, sp, #24
 634              	.LCFI54:
 635              		.cfi_def_cfa_offset 32
 636 0004 00AF     		add	r7, sp, #0
 637              	.LCFI55:
 638              		.cfi_def_cfa_register 7
 639 0006 F860     		str	r0, [r7, #12]
 640 0008 87ED020A 		vstr.32	s0, [r7, #8]
 641 000c 0B46     		mov	r3, r1
 642 000e FB80     		strh	r3, [r7, #6]	@ movhi
 119:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 120:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 121:Src/mc_interface.c ****   {
 122:Src/mc_interface.c ****     /* Nothing to do */
 123:Src/mc_interface.c ****   }
 124:Src/mc_interface.c ****   else
 125:Src/mc_interface.c ****   {
 126:Src/mc_interface.c **** #endif
 127:Src/mc_interface.c ****     float_t hFinalSpeed = ((FinalSpeed * (float_t)SPEED_UNIT) / (float_t)U_RPM);
 643              		.loc 6 127 40
 644 0010 D7ED027A 		vldr.32	s15, [r7, #8]
 645 0014 B2EE047A 		vmov.f32	s14, #1.0e+1
 646 0018 27EE877A 		vmul.f32	s14, s15, s14
 647              		.loc 6 127 13
 648 001c DFED0A6A 		vldr.32	s13, .L24
 649 0020 C7EE267A 		vdiv.f32	s15, s14, s13
ARM GAS  /tmp/cc9hWwcq.s 			page 44


 650 0024 C7ED057A 		vstr.32	s15, [r7, #20]
 128:Src/mc_interface.c ****     MCI_ExecSpeedRamp(pHandle, (int16_t)hFinalSpeed, hDurationms);
 651              		.loc 6 128 5
 652 0028 D7ED057A 		vldr.32	s15, [r7, #20]
 653 002c FDEEE77A 		vcvt.s32.f32	s15, s15
 654 0030 17EE903A 		vmov	r3, s15	@ int
 655 0034 1BB2     		sxth	r3, r3
 656 0036 FA88     		ldrh	r2, [r7, #6]
 657 0038 1946     		mov	r1, r3
 658 003a F868     		ldr	r0, [r7, #12]
 659 003c FFF7FEFF 		bl	MCI_ExecSpeedRamp
 129:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 130:Src/mc_interface.c ****   }
 131:Src/mc_interface.c **** #endif
 132:Src/mc_interface.c **** }
 660              		.loc 6 132 1
 661 0040 00BF     		nop
 662 0042 1837     		adds	r7, r7, #24
 663              	.LCFI56:
 664              		.cfi_def_cfa_offset 8
 665 0044 BD46     		mov	sp, r7
 666              	.LCFI57:
 667              		.cfi_def_cfa_register 13
 668              		@ sp needed
 669 0046 80BD     		pop	{r7, pc}
 670              	.L25:
 671              		.align	2
 672              	.L24:
 673 0048 00007042 		.word	1114636288
 674              		.cfi_endproc
 675              	.LFE1714:
 677              		.section	.text.MCI_ExecTorqueRamp,"ax",%progbits
 678              		.align	1
 679              		.weak	MCI_ExecTorqueRamp
 680              		.syntax unified
 681              		.thumb
 682              		.thumb_func
 683              		.fpu fpv4-sp-d16
 685              	MCI_ExecTorqueRamp:
 686              	.LFB1715:
 133:Src/mc_interface.c **** 
 134:Src/mc_interface.c **** /**
 135:Src/mc_interface.c ****   * @brief  Programs a motor torque ramp
 136:Src/mc_interface.c ****   *
 137:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
 138:Src/mc_interface.c ****   * @param  hFinalTorque is the value of motor torque reference at the end of
 139:Src/mc_interface.c ****   *         the ramp. This value represents actually the $I_q$ current expressed in
 140:Src/mc_interface.c ****   *         digit.
 141:Src/mc_interface.c ****   *         To convert current expressed in Amps to current expressed in digit
 142:Src/mc_interface.c ****   *         is possible to use the formula:
 143:Src/mc_interface.c ****   *         Current (digit) = [Current(Amp) * 65536 * Rshunt * Aop] / Vdd micro.
 144:Src/mc_interface.c ****   * @param  hDurationms the duration of the ramp expressed in milliseconds. It
 145:Src/mc_interface.c ****   *         is possible to set 0 to perform an instantaneous change in the
 146:Src/mc_interface.c ****   *         value.
 147:Src/mc_interface.c ****   *
 148:Src/mc_interface.c ****   *  This command is executed immediately if the target motor's state machine is in
 149:Src/mc_interface.c ****   * the #RUN state. Otherwise, it is buffered and its execution is delayed until This
ARM GAS  /tmp/cc9hWwcq.s 			page 45


 150:Src/mc_interface.c ****   * state is reached.
 151:Src/mc_interface.c ****   *
 152:Src/mc_interface.c ****   * Users can check the status of the command by calling the MCI_IsCommandAcknowledged()
 153:Src/mc_interface.c ****   * function.
 154:Src/mc_interface.c ****   *
 155:Src/mc_interface.c ****   * @sa MCI_ExecTorqueRamp
 156:Src/mc_interface.c ****   */
 157:Src/mc_interface.c **** __weak void MCI_ExecTorqueRamp(MCI_Handle_t *pHandle, int16_t hFinalTorque, uint16_t hDurationms)
 158:Src/mc_interface.c **** {
 687              		.loc 6 158 1
 688              		.cfi_startproc
 689              		@ args = 0, pretend = 0, frame = 8
 690              		@ frame_needed = 1, uses_anonymous_args = 0
 691              		@ link register save eliminated.
 692 0000 80B4     		push	{r7}
 693              	.LCFI58:
 694              		.cfi_def_cfa_offset 4
 695              		.cfi_offset 7, -4
 696 0002 83B0     		sub	sp, sp, #12
 697              	.LCFI59:
 698              		.cfi_def_cfa_offset 16
 699 0004 00AF     		add	r7, sp, #0
 700              	.LCFI60:
 701              		.cfi_def_cfa_register 7
 702 0006 7860     		str	r0, [r7, #4]
 703 0008 0B46     		mov	r3, r1
 704 000a 7B80     		strh	r3, [r7, #2]	@ movhi
 705 000c 1346     		mov	r3, r2	@ movhi
 706 000e 3B80     		strh	r3, [r7]	@ movhi
 159:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 160:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 161:Src/mc_interface.c ****   {
 162:Src/mc_interface.c ****     /* Nothing to do */
 163:Src/mc_interface.c ****   }
 164:Src/mc_interface.c ****   else
 165:Src/mc_interface.c ****   {
 166:Src/mc_interface.c **** #endif
 167:Src/mc_interface.c ****     pHandle->lastCommand = MCI_CMD_EXECTORQUERAMP;
 707              		.loc 6 167 26
 708 0010 7B68     		ldr	r3, [r7, #4]
 709 0012 0222     		movs	r2, #2
 710 0014 1A73     		strb	r2, [r3, #12]
 168:Src/mc_interface.c ****     pHandle->hFinalTorque = hFinalTorque;
 711              		.loc 6 168 27
 712 0016 7B68     		ldr	r3, [r7, #4]
 713 0018 7A88     		ldrh	r2, [r7, #2]	@ movhi
 714 001a 1A82     		strh	r2, [r3, #16]	@ movhi
 169:Src/mc_interface.c ****     pHandle->hDurationms = hDurationms;
 715              		.loc 6 169 26
 716 001c 7B68     		ldr	r3, [r7, #4]
 717 001e 3A88     		ldrh	r2, [r7]	@ movhi
 718 0020 9A83     		strh	r2, [r3, #28]	@ movhi
 170:Src/mc_interface.c ****     pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 719              		.loc 6 170 27
 720 0022 7B68     		ldr	r3, [r7, #4]
 721 0024 0122     		movs	r2, #1
 722 0026 83F82420 		strb	r2, [r3, #36]
ARM GAS  /tmp/cc9hWwcq.s 			page 46


 171:Src/mc_interface.c ****     pHandle->LastModalitySetByUser = MCM_TORQUE_MODE;
 723              		.loc 6 171 36
 724 002a 7B68     		ldr	r3, [r7, #4]
 725 002c 0422     		movs	r2, #4
 726 002e 83F82520 		strb	r2, [r3, #37]
 172:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 173:Src/mc_interface.c ****   }
 174:Src/mc_interface.c **** #endif
 175:Src/mc_interface.c **** }
 727              		.loc 6 175 1
 728 0032 00BF     		nop
 729 0034 0C37     		adds	r7, r7, #12
 730              	.LCFI61:
 731              		.cfi_def_cfa_offset 4
 732 0036 BD46     		mov	sp, r7
 733              	.LCFI62:
 734              		.cfi_def_cfa_register 13
 735              		@ sp needed
 736 0038 5DF8047B 		ldr	r7, [sp], #4
 737              	.LCFI63:
 738              		.cfi_restore 7
 739              		.cfi_def_cfa_offset 0
 740 003c 7047     		bx	lr
 741              		.cfi_endproc
 742              	.LFE1715:
 744              		.section	.text.MCI_ExecTorqueRamp_F,"ax",%progbits
 745              		.align	1
 746              		.weak	MCI_ExecTorqueRamp_F
 747              		.syntax unified
 748              		.thumb
 749              		.thumb_func
 750              		.fpu fpv4-sp-d16
 752              	MCI_ExecTorqueRamp_F:
 753              	.LFB1716:
 176:Src/mc_interface.c **** 
 177:Src/mc_interface.c **** /**
 178:Src/mc_interface.c ****   * @brief  Programs a motor torque ramp
 179:Src/mc_interface.c ****   *
 180:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
 181:Src/mc_interface.c ****   * @param  FinalTorque is the value of motor torque reference at the end of
 182:Src/mc_interface.c ****   *         the ramp. This value represents actually the $I_q$ current expressed in
 183:Src/mc_interface.c ****   *         Ampere.
 184:Src/mc_interface.c ****   *         Here the formula for conversion from current in Ampere to digit:
 185:Src/mc_interface.c ****   *           I(s16) = [i(Amp) * 65536 * Rshunt * Aop] / Vdd_micro.
 186:Src/mc_interface.c ****   * @param  hDurationms the duration of the ramp expressed in milliseconds. It
 187:Src/mc_interface.c ****   *         is possible to set 0 to perform an instantaneous change in the
 188:Src/mc_interface.c ****   *         value.
 189:Src/mc_interface.c ****   *
 190:Src/mc_interface.c ****   *  This command is executed immediately if the target motor's state machine is in
 191:Src/mc_interface.c ****   * the #RUN state. Otherwise, it is buffered and its execution is delayed until This
 192:Src/mc_interface.c ****   * state is reached.
 193:Src/mc_interface.c ****   *
 194:Src/mc_interface.c ****   * Users can check the status of the command by calling the MCI_IsCommandAcknowledged()
 195:Src/mc_interface.c ****   * function.
 196:Src/mc_interface.c ****   *
 197:Src/mc_interface.c ****   * @sa MCI_ExecTorqueRamp_F
 198:Src/mc_interface.c ****   */
ARM GAS  /tmp/cc9hWwcq.s 			page 47


 199:Src/mc_interface.c **** __weak void MCI_ExecTorqueRamp_F(MCI_Handle_t *pHandle, const float_t FinalTorque, uint16_t hDurati
 200:Src/mc_interface.c **** {
 754              		.loc 6 200 1
 755              		.cfi_startproc
 756              		@ args = 0, pretend = 0, frame = 24
 757              		@ frame_needed = 1, uses_anonymous_args = 0
 758 0000 80B5     		push	{r7, lr}
 759              	.LCFI64:
 760              		.cfi_def_cfa_offset 8
 761              		.cfi_offset 7, -8
 762              		.cfi_offset 14, -4
 763 0002 86B0     		sub	sp, sp, #24
 764              	.LCFI65:
 765              		.cfi_def_cfa_offset 32
 766 0004 00AF     		add	r7, sp, #0
 767              	.LCFI66:
 768              		.cfi_def_cfa_register 7
 769 0006 F860     		str	r0, [r7, #12]
 770 0008 87ED020A 		vstr.32	s0, [r7, #8]
 771 000c 0B46     		mov	r3, r1
 772 000e FB80     		strh	r3, [r7, #6]	@ movhi
 201:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 202:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 203:Src/mc_interface.c ****   {
 204:Src/mc_interface.c ****     /* Nothing to do */
 205:Src/mc_interface.c ****   }
 206:Src/mc_interface.c ****   else
 207:Src/mc_interface.c ****   {
 208:Src/mc_interface.c **** #endif
 209:Src/mc_interface.c ****     float_t hFinalTorque = (FinalTorque * (float_t)CURRENT_CONV_FACTOR);
 773              		.loc 6 209 13
 774 0010 D7ED027A 		vldr.32	s15, [r7, #8]
 775 0014 9FED0A7A 		vldr.32	s14, .L28
 776 0018 67EE877A 		vmul.f32	s15, s15, s14
 777 001c C7ED057A 		vstr.32	s15, [r7, #20]
 210:Src/mc_interface.c ****     MCI_ExecTorqueRamp(pHandle, (int16_t)hFinalTorque, hDurationms);
 778              		.loc 6 210 5
 779 0020 D7ED057A 		vldr.32	s15, [r7, #20]
 780 0024 FDEEE77A 		vcvt.s32.f32	s15, s15
 781 0028 17EE903A 		vmov	r3, s15	@ int
 782 002c 1BB2     		sxth	r3, r3
 783 002e FA88     		ldrh	r2, [r7, #6]
 784 0030 1946     		mov	r1, r3
 785 0032 F868     		ldr	r0, [r7, #12]
 786 0034 FFF7FEFF 		bl	MCI_ExecTorqueRamp
 211:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 212:Src/mc_interface.c ****   }
 213:Src/mc_interface.c **** #endif
 214:Src/mc_interface.c **** }
 787              		.loc 6 214 1
 788 0038 00BF     		nop
 789 003a 1837     		adds	r7, r7, #24
 790              	.LCFI67:
 791              		.cfi_def_cfa_offset 8
 792 003c BD46     		mov	sp, r7
 793              	.LCFI68:
 794              		.cfi_def_cfa_register 13
ARM GAS  /tmp/cc9hWwcq.s 			page 48


 795              		@ sp needed
 796 003e 80BD     		pop	{r7, pc}
 797              	.L29:
 798              		.align	2
 799              	.L28:
 800 0040 00C02D44 		.word	1143848960
 801              		.cfi_endproc
 802              	.LFE1716:
 804              		.section	.text.MCI_SetCurrentReferences,"ax",%progbits
 805              		.align	1
 806              		.weak	MCI_SetCurrentReferences
 807              		.syntax unified
 808              		.thumb
 809              		.thumb_func
 810              		.fpu fpv4-sp-d16
 812              	MCI_SetCurrentReferences:
 813              	.LFB1717:
 215:Src/mc_interface.c **** 
 216:Src/mc_interface.c **** /**
 217:Src/mc_interface.c ****   * @brief  Sets the motor current references $I_q$ and $I_d$ directly.
 218:Src/mc_interface.c ****   *
 219:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
 220:Src/mc_interface.c ****   * @param  Iqdref current references on qd reference frame in qd_t format.
 221:Src/mc_interface.c ****   *
 222:Src/mc_interface.c ****   *  This command is executed immediately if the target motor's state machine is in
 223:Src/mc_interface.c ****   * the #RUN state. Otherwise, it is buffered and its execution is delayed until This
 224:Src/mc_interface.c ****   * state is reached.
 225:Src/mc_interface.c ****   *
 226:Src/mc_interface.c ****   * Users can check the status of the command by calling the MCI_IsCommandAcknowledged()
 227:Src/mc_interface.c ****   * function.
 228:Src/mc_interface.c **** 
 229:Src/mc_interface.c ****   @sa MCI_SetCurrentReferences_F
 230:Src/mc_interface.c ****   */
 231:Src/mc_interface.c **** __weak void MCI_SetCurrentReferences(MCI_Handle_t *pHandle, qd_t Iqdref)
 232:Src/mc_interface.c **** {
 814              		.loc 6 232 1
 815              		.cfi_startproc
 816              		@ args = 0, pretend = 0, frame = 8
 817              		@ frame_needed = 1, uses_anonymous_args = 0
 818              		@ link register save eliminated.
 819 0000 80B4     		push	{r7}
 820              	.LCFI69:
 821              		.cfi_def_cfa_offset 4
 822              		.cfi_offset 7, -4
 823 0002 83B0     		sub	sp, sp, #12
 824              	.LCFI70:
 825              		.cfi_def_cfa_offset 16
 826 0004 00AF     		add	r7, sp, #0
 827              	.LCFI71:
 828              		.cfi_def_cfa_register 7
 829 0006 7860     		str	r0, [r7, #4]
 830 0008 3960     		str	r1, [r7]
 233:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 234:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 235:Src/mc_interface.c ****   {
 236:Src/mc_interface.c ****     /* Nothing to do */
 237:Src/mc_interface.c ****   }
ARM GAS  /tmp/cc9hWwcq.s 			page 49


 238:Src/mc_interface.c ****   else
 239:Src/mc_interface.c ****   {
 240:Src/mc_interface.c **** #endif
 241:Src/mc_interface.c **** 
 242:Src/mc_interface.c ****     pHandle->lastCommand = MCI_CMD_SETCURRENTREFERENCES;
 831              		.loc 6 242 26
 832 000a 7B68     		ldr	r3, [r7, #4]
 833 000c 0322     		movs	r2, #3
 834 000e 1A73     		strb	r2, [r3, #12]
 243:Src/mc_interface.c ****     pHandle->Iqdref.q = Iqdref.q;
 835              		.loc 6 243 31
 836 0010 B7F90020 		ldrsh	r2, [r7]
 837              		.loc 6 243 23
 838 0014 7B68     		ldr	r3, [r7, #4]
 839 0016 5A82     		strh	r2, [r3, #18]	@ movhi
 244:Src/mc_interface.c ****     pHandle->Iqdref.d = Iqdref.d;
 840              		.loc 6 244 31
 841 0018 B7F90220 		ldrsh	r2, [r7, #2]
 842              		.loc 6 244 23
 843 001c 7B68     		ldr	r3, [r7, #4]
 844 001e 9A82     		strh	r2, [r3, #20]	@ movhi
 245:Src/mc_interface.c ****     pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 845              		.loc 6 245 27
 846 0020 7B68     		ldr	r3, [r7, #4]
 847 0022 0122     		movs	r2, #1
 848 0024 83F82420 		strb	r2, [r3, #36]
 246:Src/mc_interface.c ****     pHandle->LastModalitySetByUser = MCM_TORQUE_MODE;
 849              		.loc 6 246 36
 850 0028 7B68     		ldr	r3, [r7, #4]
 851 002a 0422     		movs	r2, #4
 852 002c 83F82520 		strb	r2, [r3, #37]
 247:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 248:Src/mc_interface.c ****   }
 249:Src/mc_interface.c **** #endif
 250:Src/mc_interface.c **** }
 853              		.loc 6 250 1
 854 0030 00BF     		nop
 855 0032 0C37     		adds	r7, r7, #12
 856              	.LCFI72:
 857              		.cfi_def_cfa_offset 4
 858 0034 BD46     		mov	sp, r7
 859              	.LCFI73:
 860              		.cfi_def_cfa_register 13
 861              		@ sp needed
 862 0036 5DF8047B 		ldr	r7, [sp], #4
 863              	.LCFI74:
 864              		.cfi_restore 7
 865              		.cfi_def_cfa_offset 0
 866 003a 7047     		bx	lr
 867              		.cfi_endproc
 868              	.LFE1717:
 870              		.section	.text.MCI_SetCurrentReferences_F,"ax",%progbits
 871              		.align	1
 872              		.weak	MCI_SetCurrentReferences_F
 873              		.syntax unified
 874              		.thumb
 875              		.thumb_func
ARM GAS  /tmp/cc9hWwcq.s 			page 50


 876              		.fpu fpv4-sp-d16
 878              	MCI_SetCurrentReferences_F:
 879              	.LFB1718:
 251:Src/mc_interface.c **** 
 252:Src/mc_interface.c **** /**
 253:Src/mc_interface.c ****   * @brief  Sets the motor current references $I_q$ and $I_d$ directly.
 254:Src/mc_interface.c ****   *
 255:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
 256:Src/mc_interface.c ****   * @param  IqdRef current (A) references on qd reference frame in qd_f_t format.
 257:Src/mc_interface.c ****   *
 258:Src/mc_interface.c ****   *  This command is executed immediately if the target motor's state machine is in
 259:Src/mc_interface.c ****   * the #RUN state. Otherwise, it is buffered and its execution is delayed until This
 260:Src/mc_interface.c ****   * state is reached.
 261:Src/mc_interface.c ****   *
 262:Src/mc_interface.c ****   * Users can check the status of the command by calling the MCI_IsCommandAcknowledged()
 263:Src/mc_interface.c ****   * function.
 264:Src/mc_interface.c **** 
 265:Src/mc_interface.c ****   @sa MCI_SetCurrentReferences
 266:Src/mc_interface.c ****   */
 267:Src/mc_interface.c **** __weak void MCI_SetCurrentReferences_F(MCI_Handle_t *pHandle, qd_f_t IqdRef)
 268:Src/mc_interface.c **** {
 880              		.loc 6 268 1
 881              		.cfi_startproc
 882              		@ args = 0, pretend = 0, frame = 32
 883              		@ frame_needed = 1, uses_anonymous_args = 0
 884 0000 80B5     		push	{r7, lr}
 885              	.LCFI75:
 886              		.cfi_def_cfa_offset 8
 887              		.cfi_offset 7, -8
 888              		.cfi_offset 14, -4
 889 0002 88B0     		sub	sp, sp, #32
 890              	.LCFI76:
 891              		.cfi_def_cfa_offset 40
 892 0004 00AF     		add	r7, sp, #0
 893              	.LCFI77:
 894              		.cfi_def_cfa_register 7
 895 0006 F860     		str	r0, [r7, #12]
 896 0008 B0EE407A 		vmov.f32	s14, s0
 897 000c F0EE607A 		vmov.f32	s15, s1
 898 0010 87ED017A 		vstr.32	s14, [r7, #4]
 899 0014 C7ED027A 		vstr.32	s15, [r7, #8]
 269:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 270:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 271:Src/mc_interface.c ****   {
 272:Src/mc_interface.c ****     /* Nothing to do */
 273:Src/mc_interface.c ****   }
 274:Src/mc_interface.c ****   else
 275:Src/mc_interface.c ****   {
 276:Src/mc_interface.c **** #endif
 277:Src/mc_interface.c ****     qd_t iqDrefTemp;
 278:Src/mc_interface.c ****     qd_f_t iqDrefTempf;
 279:Src/mc_interface.c ****     iqDrefTempf.d = (IqdRef.d * (float_t)CURRENT_CONV_FACTOR);
 900              		.loc 6 279 28
 901 0018 D7ED027A 		vldr.32	s15, [r7, #8]
 902              		.loc 6 279 31
 903 001c 9FED127A 		vldr.32	s14, .L32
 904 0020 67EE877A 		vmul.f32	s15, s15, s14
ARM GAS  /tmp/cc9hWwcq.s 			page 51


 905              		.loc 6 279 19
 906 0024 C7ED067A 		vstr.32	s15, [r7, #24]
 280:Src/mc_interface.c ****     iqDrefTempf.q = (IqdRef.q * (float_t)CURRENT_CONV_FACTOR);
 907              		.loc 6 280 28
 908 0028 D7ED017A 		vldr.32	s15, [r7, #4]
 909              		.loc 6 280 31
 910 002c 9FED0E7A 		vldr.32	s14, .L32
 911 0030 67EE877A 		vmul.f32	s15, s15, s14
 912              		.loc 6 280 19
 913 0034 C7ED057A 		vstr.32	s15, [r7, #20]
 281:Src/mc_interface.c ****     iqDrefTemp.d = (int16_t)(iqDrefTempf.d);
 914              		.loc 6 281 41
 915 0038 D7ED067A 		vldr.32	s15, [r7, #24]
 916              		.loc 6 281 20
 917 003c FDEEE77A 		vcvt.s32.f32	s15, s15
 918 0040 17EE903A 		vmov	r3, s15	@ int
 919 0044 1BB2     		sxth	r3, r3
 920              		.loc 6 281 18
 921 0046 FB83     		strh	r3, [r7, #30]	@ movhi
 282:Src/mc_interface.c ****     iqDrefTemp.q = (int16_t)(iqDrefTempf.q);
 922              		.loc 6 282 41
 923 0048 D7ED057A 		vldr.32	s15, [r7, #20]
 924              		.loc 6 282 20
 925 004c FDEEE77A 		vcvt.s32.f32	s15, s15
 926 0050 17EE903A 		vmov	r3, s15	@ int
 927 0054 1BB2     		sxth	r3, r3
 928              		.loc 6 282 18
 929 0056 BB83     		strh	r3, [r7, #28]	@ movhi
 283:Src/mc_interface.c ****     MCI_SetCurrentReferences(pHandle, iqDrefTemp);
 930              		.loc 6 283 5
 931 0058 F969     		ldr	r1, [r7, #28]
 932 005a F868     		ldr	r0, [r7, #12]
 933 005c FFF7FEFF 		bl	MCI_SetCurrentReferences
 284:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 285:Src/mc_interface.c ****   }
 286:Src/mc_interface.c **** #endif
 287:Src/mc_interface.c **** }
 934              		.loc 6 287 1
 935 0060 00BF     		nop
 936 0062 2037     		adds	r7, r7, #32
 937              	.LCFI78:
 938              		.cfi_def_cfa_offset 8
 939 0064 BD46     		mov	sp, r7
 940              	.LCFI79:
 941              		.cfi_def_cfa_register 13
 942              		@ sp needed
 943 0066 80BD     		pop	{r7, pc}
 944              	.L33:
 945              		.align	2
 946              	.L32:
 947 0068 00C02D44 		.word	1143848960
 948              		.cfi_endproc
 949              	.LFE1718:
 951              		.section	.text.MCI_StartMotor,"ax",%progbits
 952              		.align	1
 953              		.weak	MCI_StartMotor
 954              		.syntax unified
ARM GAS  /tmp/cc9hWwcq.s 			page 52


 955              		.thumb
 956              		.thumb_func
 957              		.fpu fpv4-sp-d16
 959              	MCI_StartMotor:
 960              	.LFB1719:
 288:Src/mc_interface.c **** 
 289:Src/mc_interface.c **** /**
 290:Src/mc_interface.c ****   * @brief  Initiates a motor startup procedure
 291:Src/mc_interface.c ****   *
 292:Src/mc_interface.c ****   * @param  pHandle Handle on the target motor interface structure
 293:Src/mc_interface.c ****   * @retval Returns true if the command is successfully executed;
 294:Src/mc_interface.c ****   *         returns false otherwise
 295:Src/mc_interface.c ****   *
 296:Src/mc_interface.c ****   *  If the state machine of target the motor is in #IDLE state the command is
 297:Src/mc_interface.c ****   * executed instantaneously otherwise it is discarded. Users can check
 298:Src/mc_interface.c ****   * the return value of the function to get its status. The state of the motor
 299:Src/mc_interface.c ****   * can be queried with the MCI_GetSTMState() function.
 300:Src/mc_interface.c ****   *
 301:Src/mc_interface.c ****   * Before calling MCI_StartMotor() it is mandatory to execute one of the
 302:Src/mc_interface.c ****   * following commands, in order to set a torque or a speed reference
 303:Src/mc_interface.c ****   * otherwise the behavior of the motor when it reaches the #RUN state will
 304:Src/mc_interface.c ****   * be unpredictable:
 305:Src/mc_interface.c ****   *  - MCI_ExecSpeedRamp
 306:Src/mc_interface.c ****   *  - MCI_ExecTorqueRamp
 307:Src/mc_interface.c ****   *  - MCI_SetCurrentReferences
 308:Src/mc_interface.c ****   *
 309:Src/mc_interface.c ****   * If the offsets of the current measurement circuitry offsets are not known yet,
 310:Src/mc_interface.c ****   * an offset calibration procedure is executed to measure them prior to acutally
 311:Src/mc_interface.c ****   * starting up the motor.
 312:Src/mc_interface.c ****   *
 313:Src/mc_interface.c ****   * @note The MCI_StartMotor command only triggers the execution of the start-up
 314:Src/mc_interface.c ****   * procedure (or eventually the offset calibration procedure) and returns
 315:Src/mc_interface.c ****   * immediately after. It is not blocking the execution of the application until
 316:Src/mc_interface.c ****   * the motor is indeed running in steady state. If the application needs to wait
 317:Src/mc_interface.c ****   * for the motor to be running in steady state, the application has to check the
 318:Src/mc_interface.c ****   * state machine of the motor and verify that the #RUN state has been reached.
 319:Src/mc_interface.c ****   * Note also that if the startup sequence fails the #RUN state may never be reached.
 320:Src/mc_interface.c ****   */
 321:Src/mc_interface.c **** __weak bool MCI_StartMotor(MCI_Handle_t *pHandle)
 322:Src/mc_interface.c **** {
 961              		.loc 6 322 1
 962              		.cfi_startproc
 963              		@ args = 0, pretend = 0, frame = 16
 964              		@ frame_needed = 1, uses_anonymous_args = 0
 965 0000 80B5     		push	{r7, lr}
 966              	.LCFI80:
 967              		.cfi_def_cfa_offset 8
 968              		.cfi_offset 7, -8
 969              		.cfi_offset 14, -4
 970 0002 84B0     		sub	sp, sp, #16
 971              	.LCFI81:
 972              		.cfi_def_cfa_offset 24
 973 0004 00AF     		add	r7, sp, #0
 974              	.LCFI82:
 975              		.cfi_def_cfa_register 7
 976 0006 7860     		str	r0, [r7, #4]
 323:Src/mc_interface.c ****   bool retVal = false;
ARM GAS  /tmp/cc9hWwcq.s 			page 53


 977              		.loc 6 323 8
 978 0008 0023     		movs	r3, #0
 979 000a FB73     		strb	r3, [r7, #15]
 324:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 325:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 326:Src/mc_interface.c ****   {
 327:Src/mc_interface.c ****     /* Nothing to do */
 328:Src/mc_interface.c ****   }
 329:Src/mc_interface.c ****   else
 330:Src/mc_interface.c ****   {
 331:Src/mc_interface.c **** #endif
 332:Src/mc_interface.c ****     if ((IDLE == MCI_GetSTMState(pHandle)) &&
 980              		.loc 6 332 18
 981 000c 7868     		ldr	r0, [r7, #4]
 982 000e FFF7FEFF 		bl	MCI_GetSTMState
 983 0012 0346     		mov	r3, r0
 984              		.loc 6 332 8
 985 0014 002B     		cmp	r3, #0
 986 0016 14D1     		bne	.L35
 333:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 987              		.loc 6 333 26 discriminator 1
 988 0018 7868     		ldr	r0, [r7, #4]
 989 001a FFF7FEFF 		bl	MCI_GetOccurredFaults
 990 001e 0346     		mov	r3, r0
 332:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 991              		.loc 6 332 44 discriminator 1
 992 0020 002B     		cmp	r3, #0
 993 0022 0ED1     		bne	.L35
 334:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)))
 994              		.loc 6 334 26
 995 0024 7868     		ldr	r0, [r7, #4]
 996 0026 FFF7FEFF 		bl	MCI_GetCurrentFaults
 997 002a 0346     		mov	r3, r0
 333:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 998              		.loc 6 333 58
 999 002c 002B     		cmp	r3, #0
 1000 002e 08D1     		bne	.L35
 335:Src/mc_interface.c ****     {
 336:Src/mc_interface.c ****       pHandle->DirectCommand = MCI_START;
 1001              		.loc 6 336 30
 1002 0030 7B68     		ldr	r3, [r7, #4]
 1003 0032 0122     		movs	r2, #1
 1004 0034 9A77     		strb	r2, [r3, #30]
 337:Src/mc_interface.c ****       pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 1005              		.loc 6 337 29
 1006 0036 7B68     		ldr	r3, [r7, #4]
 1007 0038 0122     		movs	r2, #1
 1008 003a 83F82420 		strb	r2, [r3, #36]
 338:Src/mc_interface.c ****       retVal = true;
 1009              		.loc 6 338 14
 1010 003e 0123     		movs	r3, #1
 1011 0040 FB73     		strb	r3, [r7, #15]
 1012              	.L35:
 339:Src/mc_interface.c ****     }
 340:Src/mc_interface.c ****     else
 341:Src/mc_interface.c ****     {
 342:Src/mc_interface.c ****       /* Reject the command as the condition are not met */
ARM GAS  /tmp/cc9hWwcq.s 			page 54


 343:Src/mc_interface.c ****     }
 344:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 345:Src/mc_interface.c ****   }
 346:Src/mc_interface.c **** #endif
 347:Src/mc_interface.c ****   return (retVal);
 1013              		.loc 6 347 10
 1014 0042 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 348:Src/mc_interface.c **** }
 1015              		.loc 6 348 1
 1016 0044 1846     		mov	r0, r3
 1017 0046 1037     		adds	r7, r7, #16
 1018              	.LCFI83:
 1019              		.cfi_def_cfa_offset 8
 1020 0048 BD46     		mov	sp, r7
 1021              	.LCFI84:
 1022              		.cfi_def_cfa_register 13
 1023              		@ sp needed
 1024 004a 80BD     		pop	{r7, pc}
 1025              		.cfi_endproc
 1026              	.LFE1719:
 1028              		.section	.text.MCI_StartWithPolarizationMotor,"ax",%progbits
 1029              		.align	1
 1030              		.weak	MCI_StartWithPolarizationMotor
 1031              		.syntax unified
 1032              		.thumb
 1033              		.thumb_func
 1034              		.fpu fpv4-sp-d16
 1036              	MCI_StartWithPolarizationMotor:
 1037              	.LFB1720:
 349:Src/mc_interface.c **** 
 350:Src/mc_interface.c **** /**
 351:Src/mc_interface.c ****   * @brief  Initiates a motor startup procedure preceded by an offset
 352:Src/mc_interface.c ****   *         calibration procedure
 353:Src/mc_interface.c ****   *
 354:Src/mc_interface.c ****   * @param  pHandle Handle on the target motor interface structure
 355:Src/mc_interface.c ****   * @retval Returns true if the command is successfully executed;
 356:Src/mc_interface.c ****   *         returns false otherwise
 357:Src/mc_interface.c ****   *
 358:Src/mc_interface.c ****   *  If the state machine of target the motor is in #IDLE state the command is
 359:Src/mc_interface.c ****   * executed instantaneously otherwise it is discarded. Users can check
 360:Src/mc_interface.c ****   * the return value of the function to get its status. The state of the motor
 361:Src/mc_interface.c ****   * can be queried with the MCI_GetSTMState() function.
 362:Src/mc_interface.c ****   *
 363:Src/mc_interface.c ****   * Before calling MCI_StartMotor() it is mandatory to execute one of the
 364:Src/mc_interface.c ****   * following commands, in order to set a torque or a speed reference
 365:Src/mc_interface.c ****   * otherwise the behavior of the motor when it reaches the #RUN state will
 366:Src/mc_interface.c ****   * be unpredictable:
 367:Src/mc_interface.c ****   *  - MCI_ExecSpeedRamp
 368:Src/mc_interface.c ****   *  - MCI_ExecTorqueRamp
 369:Src/mc_interface.c ****   *  - MCI_SetCurrentReferences
 370:Src/mc_interface.c ****   *
 371:Src/mc_interface.c ****   * Whether the current measurement circuitry offsets are known or not, an
 372:Src/mc_interface.c ****   * offset calibration procedure is executed to (re)measure them. Once it has
 373:Src/mc_interface.c ****   * completed, the start up procedure of the motor is executed.
 374:Src/mc_interface.c ****   *
 375:Src/mc_interface.c ****   * @note The MCI_StartMotor command only triggers the execution of the start-up
 376:Src/mc_interface.c ****   * procedure (or eventually the offset calibration procedure) and returns
ARM GAS  /tmp/cc9hWwcq.s 			page 55


 377:Src/mc_interface.c ****   * immediately after. It is not blocking the execution of the application until
 378:Src/mc_interface.c ****   * the motor is indeed running in steady state. If the application needs to wait
 379:Src/mc_interface.c ****   * for the motor to be running in steady state, the application has to check the
 380:Src/mc_interface.c ****   * state machine of the motor and verify that the #RUN state has been reached.
 381:Src/mc_interface.c ****   * Note also that if the startup sequence fails the #RUN state may never be reached.
 382:Src/mc_interface.c ****   */
 383:Src/mc_interface.c **** __weak bool MCI_StartWithPolarizationMotor(MCI_Handle_t* pHandle)
 384:Src/mc_interface.c **** {
 1038              		.loc 6 384 1
 1039              		.cfi_startproc
 1040              		@ args = 0, pretend = 0, frame = 16
 1041              		@ frame_needed = 1, uses_anonymous_args = 0
 1042 0000 80B5     		push	{r7, lr}
 1043              	.LCFI85:
 1044              		.cfi_def_cfa_offset 8
 1045              		.cfi_offset 7, -8
 1046              		.cfi_offset 14, -4
 1047 0002 84B0     		sub	sp, sp, #16
 1048              	.LCFI86:
 1049              		.cfi_def_cfa_offset 24
 1050 0004 00AF     		add	r7, sp, #0
 1051              	.LCFI87:
 1052              		.cfi_def_cfa_register 7
 1053 0006 7860     		str	r0, [r7, #4]
 385:Src/mc_interface.c ****   bool retVal = false;
 1054              		.loc 6 385 8
 1055 0008 0023     		movs	r3, #0
 1056 000a FB73     		strb	r3, [r7, #15]
 386:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 387:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 388:Src/mc_interface.c ****   {
 389:Src/mc_interface.c ****     /* Nothing to do */
 390:Src/mc_interface.c ****   }
 391:Src/mc_interface.c ****   else
 392:Src/mc_interface.c ****   {
 393:Src/mc_interface.c **** #endif
 394:Src/mc_interface.c ****     if ((IDLE == MCI_GetSTMState(pHandle)) &&
 1057              		.loc 6 394 18
 1058 000c 7868     		ldr	r0, [r7, #4]
 1059 000e FFF7FEFF 		bl	MCI_GetSTMState
 1060 0012 0346     		mov	r3, r0
 1061              		.loc 6 394 8
 1062 0014 002B     		cmp	r3, #0
 1063 0016 19D1     		bne	.L38
 395:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 1064              		.loc 6 395 26 discriminator 1
 1065 0018 7868     		ldr	r0, [r7, #4]
 1066 001a FFF7FEFF 		bl	MCI_GetOccurredFaults
 1067 001e 0346     		mov	r3, r0
 394:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 1068              		.loc 6 394 44 discriminator 1
 1069 0020 002B     		cmp	r3, #0
 1070 0022 13D1     		bne	.L38
 396:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)))
 1071              		.loc 6 396 26
 1072 0024 7868     		ldr	r0, [r7, #4]
 1073 0026 FFF7FEFF 		bl	MCI_GetCurrentFaults
ARM GAS  /tmp/cc9hWwcq.s 			page 56


 1074 002a 0346     		mov	r3, r0
 395:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 1075              		.loc 6 395 58
 1076 002c 002B     		cmp	r3, #0
 1077 002e 0DD1     		bne	.L38
 397:Src/mc_interface.c ****     {
 398:Src/mc_interface.c ****       pHandle->DirectCommand = MCI_START;
 1078              		.loc 6 398 30
 1079 0030 7B68     		ldr	r3, [r7, #4]
 1080 0032 0122     		movs	r2, #1
 1081 0034 9A77     		strb	r2, [r3, #30]
 399:Src/mc_interface.c ****       pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 1082              		.loc 6 399 29
 1083 0036 7B68     		ldr	r3, [r7, #4]
 1084 0038 0122     		movs	r2, #1
 1085 003a 83F82420 		strb	r2, [r3, #36]
 400:Src/mc_interface.c ****       pHandle->pPWM->offsetCalibStatus = false;
 1086              		.loc 6 400 14
 1087 003e 7B68     		ldr	r3, [r7, #4]
 1088 0040 9B68     		ldr	r3, [r3, #8]
 1089              		.loc 6 400 40
 1090 0042 0022     		movs	r2, #0
 1091 0044 83F87F20 		strb	r2, [r3, #127]
 401:Src/mc_interface.c ****       retVal = true;
 1092              		.loc 6 401 14
 1093 0048 0123     		movs	r3, #1
 1094 004a FB73     		strb	r3, [r7, #15]
 1095              	.L38:
 402:Src/mc_interface.c ****   }
 403:Src/mc_interface.c ****   else
 404:Src/mc_interface.c ****   {
 405:Src/mc_interface.c ****     /* Reject the command as the condition are not met */
 406:Src/mc_interface.c ****   }
 407:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 408:Src/mc_interface.c ****   }
 409:Src/mc_interface.c **** #endif
 410:Src/mc_interface.c ****   return (retVal);
 1096              		.loc 6 410 10
 1097 004c FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 411:Src/mc_interface.c **** }
 1098              		.loc 6 411 1
 1099 004e 1846     		mov	r0, r3
 1100 0050 1037     		adds	r7, r7, #16
 1101              	.LCFI88:
 1102              		.cfi_def_cfa_offset 8
 1103 0052 BD46     		mov	sp, r7
 1104              	.LCFI89:
 1105              		.cfi_def_cfa_register 13
 1106              		@ sp needed
 1107 0054 80BD     		pop	{r7, pc}
 1108              		.cfi_endproc
 1109              	.LFE1720:
 1111              		.section	.text.MCI_StartOffsetMeasurments,"ax",%progbits
 1112              		.align	1
 1113              		.weak	MCI_StartOffsetMeasurments
 1114              		.syntax unified
 1115              		.thumb
ARM GAS  /tmp/cc9hWwcq.s 			page 57


 1116              		.thumb_func
 1117              		.fpu fpv4-sp-d16
 1119              	MCI_StartOffsetMeasurments:
 1120              	.LFB1721:
 412:Src/mc_interface.c **** 
 413:Src/mc_interface.c **** /**
 414:Src/mc_interface.c ****   * @brief  This is a user command used to begin the phase offset calibration
 415:Src/mc_interface.c ****   *         procedure. If the state machine is in IDLE state the command is executed
 416:Src/mc_interface.c ****   *         instantaneously otherwise the command is discarded. User must take
 417:Src/mc_interface.c ****   *         care of this possibility by checking the return value.\n
 418:Src/mc_interface.c ****   *         <B>Note:</B> The MCI_StartOffsetMeasurments command is used to begin phase
 419:Src/mc_interface.c ****   *         offset calibration procedure moving the state machine from IDLE state to
 420:Src/mc_interface.c ****   *         OFFSET_CALIB. The command MCI_StartOffsetMeasurments is not blocking
 421:Src/mc_interface.c ****   *         the execution of project until the measurments are done; to do this, the user
 422:Src/mc_interface.c ****   *         have to check the state machine and verify that the IDLE state (or
 423:Src/mc_interface.c ****   *         any other state) has been reached.
 424:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
 425:Src/mc_interface.c ****   * @retval bool It returns true if the command is successfully executed
 426:Src/mc_interface.c ****   *         otherwise it return false.
 427:Src/mc_interface.c ****   */
 428:Src/mc_interface.c **** __weak bool MCI_StartOffsetMeasurments(MCI_Handle_t *pHandle)
 429:Src/mc_interface.c **** {
 1121              		.loc 6 429 1
 1122              		.cfi_startproc
 1123              		@ args = 0, pretend = 0, frame = 16
 1124              		@ frame_needed = 1, uses_anonymous_args = 0
 1125 0000 80B5     		push	{r7, lr}
 1126              	.LCFI90:
 1127              		.cfi_def_cfa_offset 8
 1128              		.cfi_offset 7, -8
 1129              		.cfi_offset 14, -4
 1130 0002 84B0     		sub	sp, sp, #16
 1131              	.LCFI91:
 1132              		.cfi_def_cfa_offset 24
 1133 0004 00AF     		add	r7, sp, #0
 1134              	.LCFI92:
 1135              		.cfi_def_cfa_register 7
 1136 0006 7860     		str	r0, [r7, #4]
 430:Src/mc_interface.c ****   bool retVal = false;
 1137              		.loc 6 430 8
 1138 0008 0023     		movs	r3, #0
 1139 000a FB73     		strb	r3, [r7, #15]
 431:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 432:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 433:Src/mc_interface.c ****   {
 434:Src/mc_interface.c ****     /* Nothing to do */
 435:Src/mc_interface.c ****   }
 436:Src/mc_interface.c ****   else
 437:Src/mc_interface.c ****   {
 438:Src/mc_interface.c **** #endif
 439:Src/mc_interface.c ****     if ((IDLE == MCI_GetSTMState(pHandle)) &&
 1140              		.loc 6 439 18
 1141 000c 7868     		ldr	r0, [r7, #4]
 1142 000e FFF7FEFF 		bl	MCI_GetSTMState
 1143 0012 0346     		mov	r3, r0
 1144              		.loc 6 439 8
 1145 0014 002B     		cmp	r3, #0
ARM GAS  /tmp/cc9hWwcq.s 			page 58


 1146 0016 15D1     		bne	.L41
 440:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 1147              		.loc 6 440 26 discriminator 1
 1148 0018 7868     		ldr	r0, [r7, #4]
 1149 001a FFF7FEFF 		bl	MCI_GetOccurredFaults
 1150 001e 0346     		mov	r3, r0
 439:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 1151              		.loc 6 439 44 discriminator 1
 1152 0020 002B     		cmp	r3, #0
 1153 0022 0FD1     		bne	.L41
 441:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)))
 1154              		.loc 6 441 26
 1155 0024 7868     		ldr	r0, [r7, #4]
 1156 0026 FFF7FEFF 		bl	MCI_GetCurrentFaults
 1157 002a 0346     		mov	r3, r0
 440:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 1158              		.loc 6 440 58
 1159 002c 002B     		cmp	r3, #0
 1160 002e 09D1     		bne	.L41
 442:Src/mc_interface.c ****     {
 443:Src/mc_interface.c ****       pHandle->DirectCommand = MCI_MEASURE_OFFSETS;
 1161              		.loc 6 443 30
 1162 0030 7B68     		ldr	r3, [r7, #4]
 1163 0032 0322     		movs	r2, #3
 1164 0034 9A77     		strb	r2, [r3, #30]
 444:Src/mc_interface.c ****       pHandle->pPWM->offsetCalibStatus = false;
 1165              		.loc 6 444 14
 1166 0036 7B68     		ldr	r3, [r7, #4]
 1167 0038 9B68     		ldr	r3, [r3, #8]
 1168              		.loc 6 444 40
 1169 003a 0022     		movs	r2, #0
 1170 003c 83F87F20 		strb	r2, [r3, #127]
 445:Src/mc_interface.c ****       retVal = true;
 1171              		.loc 6 445 14
 1172 0040 0123     		movs	r3, #1
 1173 0042 FB73     		strb	r3, [r7, #15]
 1174              	.L41:
 446:Src/mc_interface.c ****     }
 447:Src/mc_interface.c ****     else
 448:Src/mc_interface.c ****     {
 449:Src/mc_interface.c ****       /* Reject the command as the condition are not met */
 450:Src/mc_interface.c ****     }
 451:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 452:Src/mc_interface.c ****   }
 453:Src/mc_interface.c **** #endif
 454:Src/mc_interface.c ****   return (retVal);
 1175              		.loc 6 454 10
 1176 0044 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 455:Src/mc_interface.c **** }
 1177              		.loc 6 455 1
 1178 0046 1846     		mov	r0, r3
 1179 0048 1037     		adds	r7, r7, #16
 1180              	.LCFI93:
 1181              		.cfi_def_cfa_offset 8
 1182 004a BD46     		mov	sp, r7
 1183              	.LCFI94:
 1184              		.cfi_def_cfa_register 13
ARM GAS  /tmp/cc9hWwcq.s 			page 59


 1185              		@ sp needed
 1186 004c 80BD     		pop	{r7, pc}
 1187              		.cfi_endproc
 1188              	.LFE1721:
 1190              		.section	.text.MCI_GetCalibratedOffsetsMotor,"ax",%progbits
 1191              		.align	1
 1192              		.weak	MCI_GetCalibratedOffsetsMotor
 1193              		.syntax unified
 1194              		.thumb
 1195              		.thumb_func
 1196              		.fpu fpv4-sp-d16
 1198              	MCI_GetCalibratedOffsetsMotor:
 1199              	.LFB1722:
 456:Src/mc_interface.c **** 
 457:Src/mc_interface.c **** /**
 458:Src/mc_interface.c ****   * @brief  Gets the phase current measurement offset values
 459:Src/mc_interface.c ****   *
 460:Src/mc_interface.c ****   * The offset values are written in the PolarizationOffsets structure provided that they
 461:Src/mc_interface.c ****   * have been previously provided for the Motor Control subsystem or measured by it.
 462:Src/mc_interface.c ****   *
 463:Src/mc_interface.c ****   * If the offset have not previously been provided to the Motor Control subsystem or
 464:Src/mc_interface.c ****   * if it has not measured them the function returns false and nothing is written in the
 465:Src/mc_interface.c ****   * PolarizationOffsets structure.
 466:Src/mc_interface.c ****   *
 467:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
 468:Src/mc_interface.c ****   * @param  PolarizationOffsets Pointer on ploarization offset structure in which offsets will be w
 469:Src/mc_interface.c ****   * @retval returns true if the command is successfully executed; returns false otherwise.
 470:Src/mc_interface.c ****   */
 471:Src/mc_interface.c **** __weak bool MCI_GetCalibratedOffsetsMotor(MCI_Handle_t *pHandle, PolarizationOffsets_t *Polarizatio
 472:Src/mc_interface.c **** {
 1200              		.loc 6 472 1
 1201              		.cfi_startproc
 1202              		@ args = 0, pretend = 0, frame = 16
 1203              		@ frame_needed = 1, uses_anonymous_args = 0
 1204 0000 80B5     		push	{r7, lr}
 1205              	.LCFI95:
 1206              		.cfi_def_cfa_offset 8
 1207              		.cfi_offset 7, -8
 1208              		.cfi_offset 14, -4
 1209 0002 84B0     		sub	sp, sp, #16
 1210              	.LCFI96:
 1211              		.cfi_def_cfa_offset 24
 1212 0004 00AF     		add	r7, sp, #0
 1213              	.LCFI97:
 1214              		.cfi_def_cfa_register 7
 1215 0006 7860     		str	r0, [r7, #4]
 1216 0008 3960     		str	r1, [r7]
 473:Src/mc_interface.c ****   bool retVal = false;
 1217              		.loc 6 473 8
 1218 000a 0023     		movs	r3, #0
 1219 000c FB73     		strb	r3, [r7, #15]
 474:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 475:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 476:Src/mc_interface.c ****   {
 477:Src/mc_interface.c ****     /* Nothing to do */
 478:Src/mc_interface.c ****   }
 479:Src/mc_interface.c ****   else
ARM GAS  /tmp/cc9hWwcq.s 			page 60


 480:Src/mc_interface.c ****   {
 481:Src/mc_interface.c **** #endif
 482:Src/mc_interface.c ****     if (pHandle->pPWM->offsetCalibStatus == true)
 1220              		.loc 6 482 16
 1221 000e 7B68     		ldr	r3, [r7, #4]
 1222 0010 9B68     		ldr	r3, [r3, #8]
 1223              		.loc 6 482 22
 1224 0012 93F87F30 		ldrb	r3, [r3, #127]	@ zero_extendqisi2
 1225              		.loc 6 482 8
 1226 0016 002B     		cmp	r3, #0
 1227 0018 07D0     		beq	.L44
 483:Src/mc_interface.c ****     {
 484:Src/mc_interface.c ****       PWMC_GetOffsetCalib(pHandle->pPWM, PolarizationOffsets);
 1228              		.loc 6 484 7
 1229 001a 7B68     		ldr	r3, [r7, #4]
 1230 001c 9B68     		ldr	r3, [r3, #8]
 1231 001e 3968     		ldr	r1, [r7]
 1232 0020 1846     		mov	r0, r3
 1233 0022 FFF7FEFF 		bl	PWMC_GetOffsetCalib
 485:Src/mc_interface.c ****       retVal = true;
 1234              		.loc 6 485 14
 1235 0026 0123     		movs	r3, #1
 1236 0028 FB73     		strb	r3, [r7, #15]
 1237              	.L44:
 486:Src/mc_interface.c ****     }
 487:Src/mc_interface.c ****     else
 488:Src/mc_interface.c ****     {
 489:Src/mc_interface.c ****       /* Reject the command as the condition are not met */
 490:Src/mc_interface.c ****     }
 491:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 492:Src/mc_interface.c ****   }
 493:Src/mc_interface.c **** #endif
 494:Src/mc_interface.c **** 
 495:Src/mc_interface.c ****   return(retVal);
 1238              		.loc 6 495 9
 1239 002a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 496:Src/mc_interface.c **** }
 1240              		.loc 6 496 1
 1241 002c 1846     		mov	r0, r3
 1242 002e 1037     		adds	r7, r7, #16
 1243              	.LCFI98:
 1244              		.cfi_def_cfa_offset 8
 1245 0030 BD46     		mov	sp, r7
 1246              	.LCFI99:
 1247              		.cfi_def_cfa_register 13
 1248              		@ sp needed
 1249 0032 80BD     		pop	{r7, pc}
 1250              		.cfi_endproc
 1251              	.LFE1722:
 1253              		.section	.text.MCI_SetCalibratedOffsetsMotor,"ax",%progbits
 1254              		.align	1
 1255              		.weak	MCI_SetCalibratedOffsetsMotor
 1256              		.syntax unified
 1257              		.thumb
 1258              		.thumb_func
 1259              		.fpu fpv4-sp-d16
 1261              	MCI_SetCalibratedOffsetsMotor:
ARM GAS  /tmp/cc9hWwcq.s 			page 61


 1262              	.LFB1723:
 497:Src/mc_interface.c **** 
 498:Src/mc_interface.c **** /**
 499:Src/mc_interface.c ****   * @brief  Sets the phase current measurement offset values
 500:Src/mc_interface.c ****   *
 501:Src/mc_interface.c ****   * If the state machine is in IDLE state the command is executed
 502:Src/mc_interface.c ****   * instantaneously otherwise the command is discarded. User must take
 503:Src/mc_interface.c ****   * care of this possibility by checking the return value.
 504:Src/mc_interface.c ****   *
 505:Src/mc_interface.c ****   * @note The MCI_SetCalibratedOffsetsMotor command is used to set the phase
 506:Src/mc_interface.c ****   *  offset values . The command MCI_SetCalibratedOffsetsMotor is not blocking
 507:Src/mc_interface.c ****   * the execution of project until the measurments are done; to do this, the user
 508:Src/mc_interface.c ****   * have to check the state machine and verify that the IDLE state (or
 509:Src/mc_interface.c ****   * any other state) has been reached.
 510:Src/mc_interface.c ****   *
 511:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
 512:Src/mc_interface.c ****   * @param  PolarizationOffsets Pointer on ploarization offset structure that contains phase A,
 513:Src/mc_interface.c ****   *         and C values.
 514:Src/mc_interface.c ****   * @retval Returns true if the command is successfully executed
 515:Src/mc_interface.c ****   *         otherwise it return false.
 516:Src/mc_interface.c ****   */
 517:Src/mc_interface.c **** __weak bool MCI_SetCalibratedOffsetsMotor(MCI_Handle_t *pHandle, PolarizationOffsets_t *Polarizatio
 518:Src/mc_interface.c **** {
 1263              		.loc 6 518 1
 1264              		.cfi_startproc
 1265              		@ args = 0, pretend = 0, frame = 16
 1266              		@ frame_needed = 1, uses_anonymous_args = 0
 1267 0000 80B5     		push	{r7, lr}
 1268              	.LCFI100:
 1269              		.cfi_def_cfa_offset 8
 1270              		.cfi_offset 7, -8
 1271              		.cfi_offset 14, -4
 1272 0002 84B0     		sub	sp, sp, #16
 1273              	.LCFI101:
 1274              		.cfi_def_cfa_offset 24
 1275 0004 00AF     		add	r7, sp, #0
 1276              	.LCFI102:
 1277              		.cfi_def_cfa_register 7
 1278 0006 7860     		str	r0, [r7, #4]
 1279 0008 3960     		str	r1, [r7]
 519:Src/mc_interface.c ****   bool retVal = false;
 1280              		.loc 6 519 8
 1281 000a 0023     		movs	r3, #0
 1282 000c FB73     		strb	r3, [r7, #15]
 520:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 521:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 522:Src/mc_interface.c ****   {
 523:Src/mc_interface.c ****     /* Nothing to do */
 524:Src/mc_interface.c ****   }
 525:Src/mc_interface.c ****   else
 526:Src/mc_interface.c ****   {
 527:Src/mc_interface.c **** #endif
 528:Src/mc_interface.c ****     if ((IDLE == MCI_GetSTMState(pHandle)) &&
 1283              		.loc 6 528 18
 1284 000e 7868     		ldr	r0, [r7, #4]
 1285 0010 FFF7FEFF 		bl	MCI_GetSTMState
 1286 0014 0346     		mov	r3, r0
ARM GAS  /tmp/cc9hWwcq.s 			page 62


 1287              		.loc 6 528 8
 1288 0016 002B     		cmp	r3, #0
 1289 0018 18D1     		bne	.L47
 529:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 1290              		.loc 6 529 26 discriminator 1
 1291 001a 7868     		ldr	r0, [r7, #4]
 1292 001c FFF7FEFF 		bl	MCI_GetOccurredFaults
 1293 0020 0346     		mov	r3, r0
 528:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 1294              		.loc 6 528 44 discriminator 1
 1295 0022 002B     		cmp	r3, #0
 1296 0024 12D1     		bne	.L47
 530:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)))
 1297              		.loc 6 530 26
 1298 0026 7868     		ldr	r0, [r7, #4]
 1299 0028 FFF7FEFF 		bl	MCI_GetCurrentFaults
 1300 002c 0346     		mov	r3, r0
 529:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 1301              		.loc 6 529 58
 1302 002e 002B     		cmp	r3, #0
 1303 0030 0CD1     		bne	.L47
 531:Src/mc_interface.c ****     {
 532:Src/mc_interface.c ****       PWMC_SetOffsetCalib(pHandle->pPWM, PolarizationOffsets);
 1304              		.loc 6 532 7
 1305 0032 7B68     		ldr	r3, [r7, #4]
 1306 0034 9B68     		ldr	r3, [r3, #8]
 1307 0036 3968     		ldr	r1, [r7]
 1308 0038 1846     		mov	r0, r3
 1309 003a FFF7FEFF 		bl	PWMC_SetOffsetCalib
 533:Src/mc_interface.c ****       pHandle->pPWM->offsetCalibStatus = true;
 1310              		.loc 6 533 14
 1311 003e 7B68     		ldr	r3, [r7, #4]
 1312 0040 9B68     		ldr	r3, [r3, #8]
 1313              		.loc 6 533 40
 1314 0042 0122     		movs	r2, #1
 1315 0044 83F87F20 		strb	r2, [r3, #127]
 534:Src/mc_interface.c ****       retVal = true;
 1316              		.loc 6 534 14
 1317 0048 0123     		movs	r3, #1
 1318 004a FB73     		strb	r3, [r7, #15]
 1319              	.L47:
 535:Src/mc_interface.c ****     }
 536:Src/mc_interface.c ****     else
 537:Src/mc_interface.c ****     {
 538:Src/mc_interface.c ****       /* Reject the command as the condition are not met */
 539:Src/mc_interface.c ****     }
 540:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 541:Src/mc_interface.c ****   }
 542:Src/mc_interface.c **** #endif
 543:Src/mc_interface.c ****     return(retVal);
 1320              		.loc 6 543 11
 1321 004c FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 544:Src/mc_interface.c **** }
 1322              		.loc 6 544 1
 1323 004e 1846     		mov	r0, r3
 1324 0050 1037     		adds	r7, r7, #16
 1325              	.LCFI103:
ARM GAS  /tmp/cc9hWwcq.s 			page 63


 1326              		.cfi_def_cfa_offset 8
 1327 0052 BD46     		mov	sp, r7
 1328              	.LCFI104:
 1329              		.cfi_def_cfa_register 13
 1330              		@ sp needed
 1331 0054 80BD     		pop	{r7, pc}
 1332              		.cfi_endproc
 1333              	.LFE1723:
 1335              		.section	.text.MCI_StopMotor,"ax",%progbits
 1336              		.align	1
 1337              		.weak	MCI_StopMotor
 1338              		.syntax unified
 1339              		.thumb
 1340              		.thumb_func
 1341              		.fpu fpv4-sp-d16
 1343              	MCI_StopMotor:
 1344              	.LFB1724:
 545:Src/mc_interface.c **** 
 546:Src/mc_interface.c **** /**
 547:Src/mc_interface.c ****   * @brief Initiates the stop procedure for a motor
 548:Src/mc_interface.c ****   *
 549:Src/mc_interface.c ****   *  If the state machine is in any state but the #ICLWAIT, #IDLE, #FAULT_NOW and
 550:Src/mc_interface.c ****   * #FAULT_OVER states, the command is immediately executed. Otherwise, it is
 551:Src/mc_interface.c ****   * discarded. The Application can check the return value to know whether the
 552:Src/mc_interface.c ****   * command was executed or discarded.
 553:Src/mc_interface.c ****   *
 554:Src/mc_interface.c ****   * @note The MCI_StopMotor() command only triggers the stop motor procedure
 555:Src/mc_interface.c ****   * and then returns. It is not blocking the application until the motor is indeed
 556:Src/mc_interface.c ****   * stopped. To know if it has stopped, the application can query the motor's state
 557:Src/mc_interface.c ****   * machine and check if the #IDLE state has been reached.
 558:Src/mc_interface.c ****   *
 559:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
 560:Src/mc_interface.c ****   * @retval returns true if the command is successfully executed, false otherwise.
 561:Src/mc_interface.c ****   */
 562:Src/mc_interface.c **** __weak bool MCI_StopMotor(MCI_Handle_t *pHandle)
 563:Src/mc_interface.c **** {
 1345              		.loc 6 563 1
 1346              		.cfi_startproc
 1347              		@ args = 0, pretend = 0, frame = 16
 1348              		@ frame_needed = 1, uses_anonymous_args = 0
 1349 0000 80B5     		push	{r7, lr}
 1350              	.LCFI105:
 1351              		.cfi_def_cfa_offset 8
 1352              		.cfi_offset 7, -8
 1353              		.cfi_offset 14, -4
 1354 0002 84B0     		sub	sp, sp, #16
 1355              	.LCFI106:
 1356              		.cfi_def_cfa_offset 24
 1357 0004 00AF     		add	r7, sp, #0
 1358              	.LCFI107:
 1359              		.cfi_def_cfa_register 7
 1360 0006 7860     		str	r0, [r7, #4]
 564:Src/mc_interface.c ****   bool retVal = false;
 1361              		.loc 6 564 8
 1362 0008 0023     		movs	r3, #0
 1363 000a FB73     		strb	r3, [r7, #15]
 565:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
ARM GAS  /tmp/cc9hWwcq.s 			page 64


 566:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 567:Src/mc_interface.c ****   {
 568:Src/mc_interface.c ****     /* Nothing to do */
 569:Src/mc_interface.c ****   }
 570:Src/mc_interface.c ****   else
 571:Src/mc_interface.c ****   {
 572:Src/mc_interface.c **** #endif
 573:Src/mc_interface.c ****     bool status;
 574:Src/mc_interface.c ****     MCI_State_t State;
 575:Src/mc_interface.c **** 
 576:Src/mc_interface.c ****     State = MCI_GetSTMState(pHandle);
 1364              		.loc 6 576 13
 1365 000c 7868     		ldr	r0, [r7, #4]
 1366 000e FFF7FEFF 		bl	MCI_GetSTMState
 1367 0012 0346     		mov	r3, r0
 1368 0014 7B73     		strb	r3, [r7, #13]
 577:Src/mc_interface.c ****     if ((IDLE == State) || (ICLWAIT == State))
 1369              		.loc 6 577 8
 1370 0016 7B7B     		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 1371 0018 002B     		cmp	r3, #0
 1372 001a 02D0     		beq	.L50
 1373              		.loc 6 577 25 discriminator 1
 1374 001c 7B7B     		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 1375 001e 0C2B     		cmp	r3, #12
 1376 0020 02D1     		bne	.L51
 1377              	.L50:
 578:Src/mc_interface.c ****     {
 579:Src/mc_interface.c ****       status = false;
 1378              		.loc 6 579 14
 1379 0022 0023     		movs	r3, #0
 1380 0024 BB73     		strb	r3, [r7, #14]
 1381 0026 01E0     		b	.L52
 1382              	.L51:
 580:Src/mc_interface.c ****     }
 581:Src/mc_interface.c ****     else
 582:Src/mc_interface.c ****     {
 583:Src/mc_interface.c ****       status = true;
 1383              		.loc 6 583 14
 1384 0028 0123     		movs	r3, #1
 1385 002a BB73     		strb	r3, [r7, #14]
 1386              	.L52:
 584:Src/mc_interface.c ****     }
 585:Src/mc_interface.c **** 
 586:Src/mc_interface.c ****     if ((MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 1387              		.loc 6 586 26
 1388 002c 7868     		ldr	r0, [r7, #4]
 1389 002e FFF7FEFF 		bl	MCI_GetOccurredFaults
 1390 0032 0346     		mov	r3, r0
 1391              		.loc 6 586 8
 1392 0034 002B     		cmp	r3, #0
 1393 0036 0DD1     		bne	.L53
 587:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)) &&
 1394              		.loc 6 587 26 discriminator 1
 1395 0038 7868     		ldr	r0, [r7, #4]
 1396 003a FFF7FEFF 		bl	MCI_GetCurrentFaults
 1397 003e 0346     		mov	r3, r0
 586:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)) &&
ARM GAS  /tmp/cc9hWwcq.s 			page 65


 1398              		.loc 6 586 58 discriminator 1
 1399 0040 002B     		cmp	r3, #0
 1400 0042 07D1     		bne	.L53
 1401              		.loc 6 587 57
 1402 0044 BB7B     		ldrb	r3, [r7, #14]	@ zero_extendqisi2
 1403 0046 002B     		cmp	r3, #0
 1404 0048 04D0     		beq	.L53
 588:Src/mc_interface.c ****         (status == true))
 589:Src/mc_interface.c ****     {
 590:Src/mc_interface.c ****       pHandle->DirectCommand = MCI_STOP;
 1405              		.loc 6 590 30
 1406 004a 7B68     		ldr	r3, [r7, #4]
 1407 004c 0522     		movs	r2, #5
 1408 004e 9A77     		strb	r2, [r3, #30]
 591:Src/mc_interface.c ****       retVal = true;
 1409              		.loc 6 591 14
 1410 0050 0123     		movs	r3, #1
 1411 0052 FB73     		strb	r3, [r7, #15]
 1412              	.L53:
 592:Src/mc_interface.c ****     }
 593:Src/mc_interface.c ****     else
 594:Src/mc_interface.c ****     {
 595:Src/mc_interface.c ****       /* Reject the command as the condition are not met */
 596:Src/mc_interface.c ****     }
 597:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 598:Src/mc_interface.c ****   }
 599:Src/mc_interface.c **** #endif
 600:Src/mc_interface.c ****   return (retVal);
 1413              		.loc 6 600 10
 1414 0054 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 601:Src/mc_interface.c **** }
 1415              		.loc 6 601 1
 1416 0056 1846     		mov	r0, r3
 1417 0058 1037     		adds	r7, r7, #16
 1418              	.LCFI108:
 1419              		.cfi_def_cfa_offset 8
 1420 005a BD46     		mov	sp, r7
 1421              	.LCFI109:
 1422              		.cfi_def_cfa_register 13
 1423              		@ sp needed
 1424 005c 80BD     		pop	{r7, pc}
 1425              		.cfi_endproc
 1426              	.LFE1724:
 1428              		.section	.text.MCI_FaultAcknowledged,"ax",%progbits
 1429              		.align	1
 1430              		.weak	MCI_FaultAcknowledged
 1431              		.syntax unified
 1432              		.thumb
 1433              		.thumb_func
 1434              		.fpu fpv4-sp-d16
 1436              	MCI_FaultAcknowledged:
 1437              	.LFB1725:
 602:Src/mc_interface.c **** 
 603:Src/mc_interface.c **** /**
 604:Src/mc_interface.c ****  * @brief Acknowledges Motor Control faults that occurred on the target motor 1.
 605:Src/mc_interface.c ****  *
 606:Src/mc_interface.c ****  *  This function must be called before the motor can be started again when a fault
ARM GAS  /tmp/cc9hWwcq.s 			page 66


 607:Src/mc_interface.c ****  * condition has occured. It clears the faults status and resets the state machine
 608:Src/mc_interface.c ****  * of the target motor to the #IDLE state provided that there is no active fault
 609:Src/mc_interface.c ****  * condition anymore.
 610:Src/mc_interface.c ****  *
 611:Src/mc_interface.c ****  *  If the state machine of the target motor is in the #FAULT_OVER state, the function
 612:Src/mc_interface.c ****  * clears the list of past faults, transitions to the #IDLE state and returns true.
 613:Src/mc_interface.c ****  * Otherwise, it oes nothing and returns false.
 614:Src/mc_interface.c ****  *
 615:Src/mc_interface.c ****  * @param  pHandle Pointer on the target motor drive structure.
 616:Src/mc_interface.c ****  */
 617:Src/mc_interface.c **** __weak bool MCI_FaultAcknowledged(MCI_Handle_t *pHandle)
 618:Src/mc_interface.c **** {
 1438              		.loc 6 618 1
 1439              		.cfi_startproc
 1440              		@ args = 0, pretend = 0, frame = 16
 1441              		@ frame_needed = 1, uses_anonymous_args = 0
 1442 0000 80B5     		push	{r7, lr}
 1443              	.LCFI110:
 1444              		.cfi_def_cfa_offset 8
 1445              		.cfi_offset 7, -8
 1446              		.cfi_offset 14, -4
 1447 0002 84B0     		sub	sp, sp, #16
 1448              	.LCFI111:
 1449              		.cfi_def_cfa_offset 24
 1450 0004 00AF     		add	r7, sp, #0
 1451              	.LCFI112:
 1452              		.cfi_def_cfa_register 7
 1453 0006 7860     		str	r0, [r7, #4]
 619:Src/mc_interface.c ****   bool reVal = false;
 1454              		.loc 6 619 8
 1455 0008 0023     		movs	r3, #0
 1456 000a FB73     		strb	r3, [r7, #15]
 620:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 621:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 622:Src/mc_interface.c ****   {
 623:Src/mc_interface.c ****     /* Nothing to do */
 624:Src/mc_interface.c ****   }
 625:Src/mc_interface.c ****   else
 626:Src/mc_interface.c ****   {
 627:Src/mc_interface.c **** #endif
 628:Src/mc_interface.c ****     if ((FAULT_OVER == MCI_GetSTMState(pHandle)) && (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle))
 1457              		.loc 6 628 24
 1458 000c 7868     		ldr	r0, [r7, #4]
 1459 000e FFF7FEFF 		bl	MCI_GetSTMState
 1460 0012 0346     		mov	r3, r0
 1461              		.loc 6 628 8
 1462 0014 0B2B     		cmp	r3, #11
 1463 0016 0DD1     		bne	.L56
 1464              		.loc 6 628 70 discriminator 1
 1465 0018 7868     		ldr	r0, [r7, #4]
 1466 001a FFF7FEFF 		bl	MCI_GetCurrentFaults
 1467 001e 0346     		mov	r3, r0
 1468              		.loc 6 628 50 discriminator 1
 1469 0020 002B     		cmp	r3, #0
 1470 0022 07D1     		bne	.L56
 629:Src/mc_interface.c ****     {
 630:Src/mc_interface.c ****       pHandle->PastFaults = MC_NO_FAULTS;
ARM GAS  /tmp/cc9hWwcq.s 			page 67


 1471              		.loc 6 630 27
 1472 0024 7B68     		ldr	r3, [r7, #4]
 1473 0026 0022     		movs	r2, #0
 1474 0028 5A84     		strh	r2, [r3, #34]	@ movhi
 631:Src/mc_interface.c ****       pHandle->DirectCommand = MCI_ACK_FAULTS;
 1475              		.loc 6 631 30
 1476 002a 7B68     		ldr	r3, [r7, #4]
 1477 002c 0222     		movs	r2, #2
 1478 002e 9A77     		strb	r2, [r3, #30]
 632:Src/mc_interface.c ****       reVal = true;
 1479              		.loc 6 632 13
 1480 0030 0123     		movs	r3, #1
 1481 0032 FB73     		strb	r3, [r7, #15]
 1482              	.L56:
 633:Src/mc_interface.c ****     }
 634:Src/mc_interface.c ****     else
 635:Src/mc_interface.c ****     {
 636:Src/mc_interface.c ****       /* Reject the command as the conditions are not met */
 637:Src/mc_interface.c ****     }
 638:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 639:Src/mc_interface.c ****   }
 640:Src/mc_interface.c **** #endif
 641:Src/mc_interface.c ****   return (reVal);
 1483              		.loc 6 641 10
 1484 0034 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 642:Src/mc_interface.c **** }
 1485              		.loc 6 642 1
 1486 0036 1846     		mov	r0, r3
 1487 0038 1037     		adds	r7, r7, #16
 1488              	.LCFI113:
 1489              		.cfi_def_cfa_offset 8
 1490 003a BD46     		mov	sp, r7
 1491              	.LCFI114:
 1492              		.cfi_def_cfa_register 13
 1493              		@ sp needed
 1494 003c 80BD     		pop	{r7, pc}
 1495              		.cfi_endproc
 1496              	.LFE1725:
 1498              		.section	.text.MCI_FaultProcessing,"ax",%progbits
 1499              		.align	1
 1500              		.weak	MCI_FaultProcessing
 1501              		.syntax unified
 1502              		.thumb
 1503              		.thumb_func
 1504              		.fpu fpv4-sp-d16
 1506              	MCI_FaultProcessing:
 1507              	.LFB1726:
 643:Src/mc_interface.c **** 
 644:Src/mc_interface.c **** /**
 645:Src/mc_interface.c ****  * @brief It clocks both HW and SW faults processing and update the state
 646:Src/mc_interface.c ****  *        machine accordingly with hSetErrors, hResetErrors and present state.
 647:Src/mc_interface.c ****  *        Refer to State_t description for more information about fault states.
 648:Src/mc_interface.c ****  * @param pHandle pointer of type  STM_Handle_t
 649:Src/mc_interface.c ****  * @param hSetErrors Bit field reporting faults currently present
 650:Src/mc_interface.c ****  * @param hResetErrors Bit field reporting faults to be cleared
 651:Src/mc_interface.c ****  */
 652:Src/mc_interface.c **** __weak void MCI_FaultProcessing(MCI_Handle_t *pHandle, uint16_t hSetErrors, uint16_t hResetErrors)
ARM GAS  /tmp/cc9hWwcq.s 			page 68


 653:Src/mc_interface.c **** {
 1508              		.loc 6 653 1
 1509              		.cfi_startproc
 1510              		@ args = 0, pretend = 0, frame = 8
 1511              		@ frame_needed = 1, uses_anonymous_args = 0
 1512              		@ link register save eliminated.
 1513 0000 80B4     		push	{r7}
 1514              	.LCFI115:
 1515              		.cfi_def_cfa_offset 4
 1516              		.cfi_offset 7, -4
 1517 0002 83B0     		sub	sp, sp, #12
 1518              	.LCFI116:
 1519              		.cfi_def_cfa_offset 16
 1520 0004 00AF     		add	r7, sp, #0
 1521              	.LCFI117:
 1522              		.cfi_def_cfa_register 7
 1523 0006 7860     		str	r0, [r7, #4]
 1524 0008 0B46     		mov	r3, r1
 1525 000a 7B80     		strh	r3, [r7, #2]	@ movhi
 1526 000c 1346     		mov	r3, r2	@ movhi
 1527 000e 3B80     		strh	r3, [r7]	@ movhi
 654:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 655:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 656:Src/mc_interface.c ****   {
 657:Src/mc_interface.c ****     /* Nothing to do */
 658:Src/mc_interface.c ****   }
 659:Src/mc_interface.c ****   else
 660:Src/mc_interface.c ****   {
 661:Src/mc_interface.c **** #endif
 662:Src/mc_interface.c ****     /* Set current errors */
 663:Src/mc_interface.c ****     pHandle->CurrentFaults = (pHandle->CurrentFaults | hSetErrors ) & (~hResetErrors);
 1528              		.loc 6 663 38
 1529 0010 7B68     		ldr	r3, [r7, #4]
 1530 0012 1A8C     		ldrh	r2, [r3, #32]
 1531              		.loc 6 663 69
 1532 0014 7B88     		ldrh	r3, [r7, #2]	@ movhi
 1533 0016 1343     		orrs	r3, r3, r2
 1534 0018 9BB2     		uxth	r3, r3
 1535 001a 1AB2     		sxth	r2, r3
 1536 001c B7F90030 		ldrsh	r3, [r7]
 1537 0020 DB43     		mvns	r3, r3
 1538 0022 1BB2     		sxth	r3, r3
 1539 0024 1340     		ands	r3, r3, r2
 1540 0026 1BB2     		sxth	r3, r3
 1541 0028 9AB2     		uxth	r2, r3
 1542              		.loc 6 663 28
 1543 002a 7B68     		ldr	r3, [r7, #4]
 1544 002c 1A84     		strh	r2, [r3, #32]	@ movhi
 664:Src/mc_interface.c ****     pHandle->PastFaults |= hSetErrors;
 1545              		.loc 6 664 25
 1546 002e 7B68     		ldr	r3, [r7, #4]
 1547 0030 5A8C     		ldrh	r2, [r3, #34]
 1548 0032 7B88     		ldrh	r3, [r7, #2]	@ movhi
 1549 0034 1343     		orrs	r3, r3, r2
 1550 0036 9AB2     		uxth	r2, r3
 1551 0038 7B68     		ldr	r3, [r7, #4]
 1552 003a 5A84     		strh	r2, [r3, #34]	@ movhi
ARM GAS  /tmp/cc9hWwcq.s 			page 69


 665:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 666:Src/mc_interface.c ****   }
 667:Src/mc_interface.c **** #endif
 668:Src/mc_interface.c **** }
 1553              		.loc 6 668 1
 1554 003c 00BF     		nop
 1555 003e 0C37     		adds	r7, r7, #12
 1556              	.LCFI118:
 1557              		.cfi_def_cfa_offset 4
 1558 0040 BD46     		mov	sp, r7
 1559              	.LCFI119:
 1560              		.cfi_def_cfa_register 13
 1561              		@ sp needed
 1562 0042 5DF8047B 		ldr	r7, [sp], #4
 1563              	.LCFI120:
 1564              		.cfi_restore 7
 1565              		.cfi_def_cfa_offset 0
 1566 0046 7047     		bx	lr
 1567              		.cfi_endproc
 1568              	.LFE1726:
 1570              		.section	.text.MCI_ExecBufferedCommands,"ax",%progbits
 1571              		.align	1
 1572              		.weak	MCI_ExecBufferedCommands
 1573              		.syntax unified
 1574              		.thumb
 1575              		.thumb_func
 1576              		.fpu fpv4-sp-d16
 1578              	MCI_ExecBufferedCommands:
 1579              	.LFB1727:
 669:Src/mc_interface.c **** 
 670:Src/mc_interface.c **** /**
 671:Src/mc_interface.c ****   * @brief  This is usually a method managed by task. It must be called
 672:Src/mc_interface.c ****   *         periodically in order to check the status of the related pSTM object
 673:Src/mc_interface.c ****   *         and eventually to execute the buffered command if the condition
 674:Src/mc_interface.c ****   *         occurs.
 675:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
 676:Src/mc_interface.c ****   */
 677:Src/mc_interface.c **** __weak void MCI_ExecBufferedCommands(MCI_Handle_t *pHandle)
 678:Src/mc_interface.c **** {
 1580              		.loc 6 678 1
 1581              		.cfi_startproc
 1582              		@ args = 0, pretend = 0, frame = 16
 1583              		@ frame_needed = 1, uses_anonymous_args = 0
 1584 0000 80B5     		push	{r7, lr}
 1585              	.LCFI121:
 1586              		.cfi_def_cfa_offset 8
 1587              		.cfi_offset 7, -8
 1588              		.cfi_offset 14, -4
 1589 0002 84B0     		sub	sp, sp, #16
 1590              	.LCFI122:
 1591              		.cfi_def_cfa_offset 24
 1592 0004 00AF     		add	r7, sp, #0
 1593              	.LCFI123:
 1594              		.cfi_def_cfa_register 7
 1595 0006 7860     		str	r0, [r7, #4]
 679:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 680:Src/mc_interface.c ****   if (NULL == pHandle)
ARM GAS  /tmp/cc9hWwcq.s 			page 70


 681:Src/mc_interface.c ****   {
 682:Src/mc_interface.c ****     /* Nothing to do */
 683:Src/mc_interface.c ****   }
 684:Src/mc_interface.c ****   else
 685:Src/mc_interface.c ****   {
 686:Src/mc_interface.c **** #endif
 687:Src/mc_interface.c ****     if ( pHandle->CommandState == MCI_COMMAND_NOT_ALREADY_EXECUTED )
 1596              		.loc 6 687 17
 1597 0008 7B68     		ldr	r3, [r7, #4]
 1598 000a 93F82430 		ldrb	r3, [r3, #36]	@ zero_extendqisi2
 1599              		.loc 6 687 8
 1600 000e 012B     		cmp	r3, #1
 1601 0010 58D1     		bne	.L67
 1602              	.LBB10:
 688:Src/mc_interface.c ****     {
 689:Src/mc_interface.c ****       bool commandHasBeenExecuted = false;
 1603              		.loc 6 689 12
 1604 0012 0023     		movs	r3, #0
 1605 0014 FB73     		strb	r3, [r7, #15]
 690:Src/mc_interface.c ****       switch (pHandle->lastCommand)
 1606              		.loc 6 690 22
 1607 0016 7B68     		ldr	r3, [r7, #4]
 1608 0018 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1609              		.loc 6 690 7
 1610 001a 032B     		cmp	r3, #3
 1611 001c 36D0     		beq	.L61
 1612 001e 032B     		cmp	r3, #3
 1613 0020 43DC     		bgt	.L68
 1614 0022 012B     		cmp	r3, #1
 1615 0024 02D0     		beq	.L63
 1616 0026 022B     		cmp	r3, #2
 1617 0028 18D0     		beq	.L64
 691:Src/mc_interface.c ****       {
 692:Src/mc_interface.c ****         case MCI_CMD_EXECSPEEDRAMP:
 693:Src/mc_interface.c ****         {
 694:Src/mc_interface.c ****           pHandle->pFOCVars->bDriveInput = INTERNAL;
 695:Src/mc_interface.c ****           STC_SetControlMode(pHandle->pSTC, MCM_SPEED_MODE);
 696:Src/mc_interface.c ****           commandHasBeenExecuted = STC_ExecRamp(pHandle->pSTC, pHandle->hFinalSpeed, pHandle->hDura
 697:Src/mc_interface.c ****           break;
 698:Src/mc_interface.c ****         }
 699:Src/mc_interface.c **** 
 700:Src/mc_interface.c ****         case MCI_CMD_EXECTORQUERAMP:
 701:Src/mc_interface.c ****         {
 702:Src/mc_interface.c ****           pHandle->pFOCVars->bDriveInput = INTERNAL;
 703:Src/mc_interface.c ****           STC_SetControlMode(pHandle->pSTC, MCM_TORQUE_MODE);
 704:Src/mc_interface.c ****           commandHasBeenExecuted = STC_ExecRamp(pHandle->pSTC, pHandle->hFinalTorque, pHandle->hDur
 705:Src/mc_interface.c ****           break;
 706:Src/mc_interface.c ****         }
 707:Src/mc_interface.c **** 
 708:Src/mc_interface.c ****         case MCI_CMD_SETCURRENTREFERENCES:
 709:Src/mc_interface.c ****         {
 710:Src/mc_interface.c ****           pHandle->pFOCVars->bDriveInput = EXTERNAL;
 711:Src/mc_interface.c ****           pHandle->pFOCVars->Iqdref = pHandle->Iqdref;
 712:Src/mc_interface.c ****           commandHasBeenExecuted = true;
 713:Src/mc_interface.c ****           break;
 714:Src/mc_interface.c ****         }
 715:Src/mc_interface.c **** 
ARM GAS  /tmp/cc9hWwcq.s 			page 71


 716:Src/mc_interface.c ****         default:
 717:Src/mc_interface.c ****           break;
 1618              		.loc 6 717 11
 1619 002a 3EE0     		b	.L68
 1620              	.L63:
 694:Src/mc_interface.c ****           STC_SetControlMode(pHandle->pSTC, MCM_SPEED_MODE);
 1621              		.loc 6 694 18
 1622 002c 7B68     		ldr	r3, [r7, #4]
 1623 002e 5B68     		ldr	r3, [r3, #4]
 694:Src/mc_interface.c ****           STC_SetControlMode(pHandle->pSTC, MCM_SPEED_MODE);
 1624              		.loc 6 694 42
 1625 0030 0022     		movs	r2, #0
 1626 0032 83F82420 		strb	r2, [r3, #36]
 695:Src/mc_interface.c ****           commandHasBeenExecuted = STC_ExecRamp(pHandle->pSTC, pHandle->hFinalSpeed, pHandle->hDura
 1627              		.loc 6 695 11
 1628 0036 7B68     		ldr	r3, [r7, #4]
 1629 0038 1B68     		ldr	r3, [r3]
 1630 003a 0321     		movs	r1, #3
 1631 003c 1846     		mov	r0, r3
 1632 003e FFF7FEFF 		bl	STC_SetControlMode
 696:Src/mc_interface.c ****           break;
 1633              		.loc 6 696 36
 1634 0042 7B68     		ldr	r3, [r7, #4]
 1635 0044 1868     		ldr	r0, [r3]
 1636 0046 7B68     		ldr	r3, [r7, #4]
 1637 0048 B3F90E10 		ldrsh	r1, [r3, #14]
 696:Src/mc_interface.c ****           break;
 1638              		.loc 6 696 93
 1639 004c 7B68     		ldr	r3, [r7, #4]
 1640 004e 9B8B     		ldrh	r3, [r3, #28]
 696:Src/mc_interface.c ****           break;
 1641              		.loc 6 696 36
 1642 0050 1A46     		mov	r2, r3
 1643 0052 FFF7FEFF 		bl	STC_ExecRamp
 1644 0056 0346     		mov	r3, r0
 1645 0058 FB73     		strb	r3, [r7, #15]
 697:Src/mc_interface.c ****         }
 1646              		.loc 6 697 11
 1647 005a 27E0     		b	.L65
 1648              	.L64:
 702:Src/mc_interface.c ****           STC_SetControlMode(pHandle->pSTC, MCM_TORQUE_MODE);
 1649              		.loc 6 702 18
 1650 005c 7B68     		ldr	r3, [r7, #4]
 1651 005e 5B68     		ldr	r3, [r3, #4]
 702:Src/mc_interface.c ****           STC_SetControlMode(pHandle->pSTC, MCM_TORQUE_MODE);
 1652              		.loc 6 702 42
 1653 0060 0022     		movs	r2, #0
 1654 0062 83F82420 		strb	r2, [r3, #36]
 703:Src/mc_interface.c ****           commandHasBeenExecuted = STC_ExecRamp(pHandle->pSTC, pHandle->hFinalTorque, pHandle->hDur
 1655              		.loc 6 703 11
 1656 0066 7B68     		ldr	r3, [r7, #4]
 1657 0068 1B68     		ldr	r3, [r3]
 1658 006a 0421     		movs	r1, #4
 1659 006c 1846     		mov	r0, r3
 1660 006e FFF7FEFF 		bl	STC_SetControlMode
 704:Src/mc_interface.c ****           break;
 1661              		.loc 6 704 36
ARM GAS  /tmp/cc9hWwcq.s 			page 72


 1662 0072 7B68     		ldr	r3, [r7, #4]
 1663 0074 1868     		ldr	r0, [r3]
 1664 0076 7B68     		ldr	r3, [r7, #4]
 1665 0078 B3F91010 		ldrsh	r1, [r3, #16]
 704:Src/mc_interface.c ****           break;
 1666              		.loc 6 704 94
 1667 007c 7B68     		ldr	r3, [r7, #4]
 1668 007e 9B8B     		ldrh	r3, [r3, #28]
 704:Src/mc_interface.c ****           break;
 1669              		.loc 6 704 36
 1670 0080 1A46     		mov	r2, r3
 1671 0082 FFF7FEFF 		bl	STC_ExecRamp
 1672 0086 0346     		mov	r3, r0
 1673 0088 FB73     		strb	r3, [r7, #15]
 705:Src/mc_interface.c ****         }
 1674              		.loc 6 705 11
 1675 008a 0FE0     		b	.L65
 1676              	.L61:
 710:Src/mc_interface.c ****           pHandle->pFOCVars->Iqdref = pHandle->Iqdref;
 1677              		.loc 6 710 18
 1678 008c 7B68     		ldr	r3, [r7, #4]
 1679 008e 5B68     		ldr	r3, [r3, #4]
 710:Src/mc_interface.c ****           pHandle->pFOCVars->Iqdref = pHandle->Iqdref;
 1680              		.loc 6 710 42
 1681 0090 0122     		movs	r2, #1
 1682 0092 83F82420 		strb	r2, [r3, #36]
 711:Src/mc_interface.c ****           commandHasBeenExecuted = true;
 1683              		.loc 6 711 18
 1684 0096 7B68     		ldr	r3, [r7, #4]
 1685 0098 5B68     		ldr	r3, [r3, #4]
 711:Src/mc_interface.c ****           commandHasBeenExecuted = true;
 1686              		.loc 6 711 37
 1687 009a 7A68     		ldr	r2, [r7, #4]
 1688 009c 1033     		adds	r3, r3, #16
 1689 009e 1232     		adds	r2, r2, #18
 1690 00a0 1268     		ldr	r2, [r2]	@ unaligned
 1691 00a2 1A60     		str	r2, [r3]	@ unaligned
 712:Src/mc_interface.c ****           break;
 1692              		.loc 6 712 34
 1693 00a4 0123     		movs	r3, #1
 1694 00a6 FB73     		strb	r3, [r7, #15]
 713:Src/mc_interface.c ****         }
 1695              		.loc 6 713 11
 1696 00a8 00E0     		b	.L65
 1697              	.L68:
 1698              		.loc 6 717 11
 1699 00aa 00BF     		nop
 1700              	.L65:
 718:Src/mc_interface.c ****       }
 719:Src/mc_interface.c **** 
 720:Src/mc_interface.c ****       if (commandHasBeenExecuted)
 1701              		.loc 6 720 10
 1702 00ac FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 1703 00ae 002B     		cmp	r3, #0
 1704 00b0 04D0     		beq	.L66
 721:Src/mc_interface.c ****       {
 722:Src/mc_interface.c ****         pHandle->CommandState = MCI_COMMAND_EXECUTED_SUCCESSFULLY;
ARM GAS  /tmp/cc9hWwcq.s 			page 73


 1705              		.loc 6 722 31
 1706 00b2 7B68     		ldr	r3, [r7, #4]
 1707 00b4 0222     		movs	r2, #2
 1708 00b6 83F82420 		strb	r2, [r3, #36]
 1709              	.LBE10:
 723:Src/mc_interface.c ****       }
 724:Src/mc_interface.c ****       else
 725:Src/mc_interface.c ****       {
 726:Src/mc_interface.c ****         pHandle->CommandState = MCI_COMMAND_EXECUTED_UNSUCCESSFULLY;
 727:Src/mc_interface.c ****       }
 728:Src/mc_interface.c ****     }
 729:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 730:Src/mc_interface.c ****   }
 731:Src/mc_interface.c **** #endif
 732:Src/mc_interface.c **** }
 1710              		.loc 6 732 1
 1711 00ba 03E0     		b	.L67
 1712              	.L66:
 1713              	.LBB11:
 726:Src/mc_interface.c ****       }
 1714              		.loc 6 726 31
 1715 00bc 7B68     		ldr	r3, [r7, #4]
 1716 00be 0322     		movs	r2, #3
 1717 00c0 83F82420 		strb	r2, [r3, #36]
 1718              	.L67:
 1719              	.LBE11:
 1720              		.loc 6 732 1
 1721 00c4 00BF     		nop
 1722 00c6 1037     		adds	r7, r7, #16
 1723              	.LCFI124:
 1724              		.cfi_def_cfa_offset 8
 1725 00c8 BD46     		mov	sp, r7
 1726              	.LCFI125:
 1727              		.cfi_def_cfa_register 13
 1728              		@ sp needed
 1729 00ca 80BD     		pop	{r7, pc}
 1730              		.cfi_endproc
 1731              	.LFE1727:
 1733              		.section	.text.MCI_IsCommandAcknowledged,"ax",%progbits
 1734              		.align	1
 1735              		.weak	MCI_IsCommandAcknowledged
 1736              		.syntax unified
 1737              		.thumb
 1738              		.thumb_func
 1739              		.fpu fpv4-sp-d16
 1741              	MCI_IsCommandAcknowledged:
 1742              	.LFB1728:
 733:Src/mc_interface.c **** 
 734:Src/mc_interface.c **** /**
 735:Src/mc_interface.c ****   * @brief  Returns information about the state of the last buffered command.
 736:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
 737:Src/mc_interface.c ****   * @retval The state of the last buffered command
 738:Src/mc_interface.c ****   *
 739:Src/mc_interface.c ****   * The state returned by this function can be one of the following codes:
 740:Src/mc_interface.c ****   * - #MCI_BUFFER_EMPTY if no buffered command has been called.
 741:Src/mc_interface.c ****   * - #MCI_COMMAND_NOT_ALREADY_EXECUTED if the buffered command
 742:Src/mc_interface.c ****   * condition has not already occurred.
ARM GAS  /tmp/cc9hWwcq.s 			page 74


 743:Src/mc_interface.c ****   * - #MCI_COMMAND_EXECUTED_SUCCESSFULLY if the buffered command has
 744:Src/mc_interface.c ****   * been executed successfully. In this case calling this function resets
 745:Src/mc_interface.c ****   * the command state to #MCI_BUFFER_EMPTY.
 746:Src/mc_interface.c ****   * - #MCI_COMMAND_EXECUTED_UNSUCCESSFULLY if the buffered command has
 747:Src/mc_interface.c ****   * been executed unsuccessfully. In this case calling this function
 748:Src/mc_interface.c ****   * resets the command state to #MCI_BUFFER_EMPTY.
 749:Src/mc_interface.c ****   */
 750:Src/mc_interface.c **** __weak MCI_CommandState_t MCI_IsCommandAcknowledged(MCI_Handle_t *pHandle)
 751:Src/mc_interface.c **** {
 1743              		.loc 6 751 1
 1744              		.cfi_startproc
 1745              		@ args = 0, pretend = 0, frame = 16
 1746              		@ frame_needed = 1, uses_anonymous_args = 0
 1747              		@ link register save eliminated.
 1748 0000 80B4     		push	{r7}
 1749              	.LCFI126:
 1750              		.cfi_def_cfa_offset 4
 1751              		.cfi_offset 7, -4
 1752 0002 85B0     		sub	sp, sp, #20
 1753              	.LCFI127:
 1754              		.cfi_def_cfa_offset 24
 1755 0004 00AF     		add	r7, sp, #0
 1756              	.LCFI128:
 1757              		.cfi_def_cfa_register 7
 1758 0006 7860     		str	r0, [r7, #4]
 752:Src/mc_interface.c ****   MCI_CommandState_t retVal;
 753:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 754:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 755:Src/mc_interface.c ****   {
 756:Src/mc_interface.c ****     retVal = MCI_COMMAND_EXECUTED_UNSUCCESSFULLY;
 757:Src/mc_interface.c ****   }
 758:Src/mc_interface.c ****   else
 759:Src/mc_interface.c ****   {
 760:Src/mc_interface.c **** #endif
 761:Src/mc_interface.c ****     retVal = pHandle->CommandState;
 1759              		.loc 6 761 12
 1760 0008 7B68     		ldr	r3, [r7, #4]
 1761 000a 93F82430 		ldrb	r3, [r3, #36]
 1762 000e FB73     		strb	r3, [r7, #15]
 762:Src/mc_interface.c **** 
 763:Src/mc_interface.c ****     if ((MCI_COMMAND_EXECUTED_SUCCESSFULLY == retVal) || (MCI_COMMAND_EXECUTED_UNSUCCESSFULLY == re
 1763              		.loc 6 763 8
 1764 0010 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 1765 0012 022B     		cmp	r3, #2
 1766 0014 02D0     		beq	.L70
 1767              		.loc 6 763 55 discriminator 1
 1768 0016 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 1769 0018 032B     		cmp	r3, #3
 1770 001a 03D1     		bne	.L71
 1771              	.L70:
 764:Src/mc_interface.c ****     {
 765:Src/mc_interface.c ****       pHandle->CommandState = MCI_BUFFER_EMPTY;
 1772              		.loc 6 765 29
 1773 001c 7B68     		ldr	r3, [r7, #4]
 1774 001e 0022     		movs	r2, #0
 1775 0020 83F82420 		strb	r2, [r3, #36]
 1776              	.L71:
ARM GAS  /tmp/cc9hWwcq.s 			page 75


 766:Src/mc_interface.c ****     }
 767:Src/mc_interface.c ****     else
 768:Src/mc_interface.c ****     {
 769:Src/mc_interface.c ****       /* Nothing to do */
 770:Src/mc_interface.c ****     }
 771:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 772:Src/mc_interface.c ****   }
 773:Src/mc_interface.c **** #endif
 774:Src/mc_interface.c ****   return (retVal);
 1777              		.loc 6 774 10
 1778 0024 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 775:Src/mc_interface.c **** }
 1779              		.loc 6 775 1
 1780 0026 1846     		mov	r0, r3
 1781 0028 1437     		adds	r7, r7, #20
 1782              	.LCFI129:
 1783              		.cfi_def_cfa_offset 4
 1784 002a BD46     		mov	sp, r7
 1785              	.LCFI130:
 1786              		.cfi_def_cfa_register 13
 1787              		@ sp needed
 1788 002c 5DF8047B 		ldr	r7, [sp], #4
 1789              	.LCFI131:
 1790              		.cfi_restore 7
 1791              		.cfi_def_cfa_offset 0
 1792 0030 7047     		bx	lr
 1793              		.cfi_endproc
 1794              	.LFE1728:
 1796              		.section	.text.MCI_GetSTMState,"ax",%progbits
 1797              		.align	1
 1798              		.weak	MCI_GetSTMState
 1799              		.syntax unified
 1800              		.thumb
 1801              		.thumb_func
 1802              		.fpu fpv4-sp-d16
 1804              	MCI_GetSTMState:
 1805              	.LFB1729:
 776:Src/mc_interface.c **** 
 777:Src/mc_interface.c **** /**
 778:Src/mc_interface.c ****   * @brief  It returns information about the state of the related pSTM object.
 779:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
 780:Src/mc_interface.c ****   * @retval State_t It returns the current state of the related pSTM object.
 781:Src/mc_interface.c ****   */
 782:Src/mc_interface.c **** __weak MCI_State_t MCI_GetSTMState(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
 783:Src/mc_interface.c **** {
 1806              		.loc 6 783 1
 1807              		.cfi_startproc
 1808              		@ args = 0, pretend = 0, frame = 8
 1809              		@ frame_needed = 1, uses_anonymous_args = 0
 1810              		@ link register save eliminated.
 1811 0000 80B4     		push	{r7}
 1812              	.LCFI132:
 1813              		.cfi_def_cfa_offset 4
 1814              		.cfi_offset 7, -4
 1815 0002 83B0     		sub	sp, sp, #12
 1816              	.LCFI133:
 1817              		.cfi_def_cfa_offset 16
ARM GAS  /tmp/cc9hWwcq.s 			page 76


 1818 0004 00AF     		add	r7, sp, #0
 1819              	.LCFI134:
 1820              		.cfi_def_cfa_register 7
 1821 0006 7860     		str	r0, [r7, #4]
 784:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 785:Src/mc_interface.c ****   return ((MC_NULL == pHandle) ? FAULT_NOW : pHandle->State);
 786:Src/mc_interface.c **** #else
 787:Src/mc_interface.c ****   return (pHandle->State);
 1822              		.loc 6 787 18
 1823 0008 7B68     		ldr	r3, [r7, #4]
 1824 000a DB7F     		ldrb	r3, [r3, #31]	@ zero_extendqisi2
 788:Src/mc_interface.c **** #endif
 789:Src/mc_interface.c **** }
 1825              		.loc 6 789 1
 1826 000c 1846     		mov	r0, r3
 1827 000e 0C37     		adds	r7, r7, #12
 1828              	.LCFI135:
 1829              		.cfi_def_cfa_offset 4
 1830 0010 BD46     		mov	sp, r7
 1831              	.LCFI136:
 1832              		.cfi_def_cfa_register 13
 1833              		@ sp needed
 1834 0012 5DF8047B 		ldr	r7, [sp], #4
 1835              	.LCFI137:
 1836              		.cfi_restore 7
 1837              		.cfi_def_cfa_offset 0
 1838 0016 7047     		bx	lr
 1839              		.cfi_endproc
 1840              	.LFE1729:
 1842              		.section	.text.MCI_GetOccurredFaults,"ax",%progbits
 1843              		.align	1
 1844              		.weak	MCI_GetOccurredFaults
 1845              		.syntax unified
 1846              		.thumb
 1847              		.thumb_func
 1848              		.fpu fpv4-sp-d16
 1850              	MCI_GetOccurredFaults:
 1851              	.LFB1730:
 790:Src/mc_interface.c **** 
 791:Src/mc_interface.c **** /**
 792:Src/mc_interface.c ****   * @brief Returns the list of non-acknowledged faults that occured on the target motor
 793:Src/mc_interface.c ****   *
 794:Src/mc_interface.c ****   * This function returns a bitfield indicating the faults that occured since the state machine
 795:Src/mc_interface.c ****   * of the target motor has been moved into the #FAULT_NOW state.
 796:Src/mc_interface.c ****   *
 797:Src/mc_interface.c ****   * Possible error codes are listed in the @ref fault_codes "Fault codes" section.
 798:Src/mc_interface.c ****   *
 799:Src/mc_interface.c ****   * @param  pHandle Pointer on the target motor drive structure.
 800:Src/mc_interface.c ****   * @retval uint16_t  16 bit fields with information about the faults
 801:Src/mc_interface.c ****   *         historically occurred since the state machine has been moved into
 802:Src/mc_interface.c ****   */
 803:Src/mc_interface.c **** __weak uint16_t MCI_GetOccurredFaults(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
 804:Src/mc_interface.c **** {
 1852              		.loc 6 804 1
 1853              		.cfi_startproc
 1854              		@ args = 0, pretend = 0, frame = 8
 1855              		@ frame_needed = 1, uses_anonymous_args = 0
ARM GAS  /tmp/cc9hWwcq.s 			page 77


 1856              		@ link register save eliminated.
 1857 0000 80B4     		push	{r7}
 1858              	.LCFI138:
 1859              		.cfi_def_cfa_offset 4
 1860              		.cfi_offset 7, -4
 1861 0002 83B0     		sub	sp, sp, #12
 1862              	.LCFI139:
 1863              		.cfi_def_cfa_offset 16
 1864 0004 00AF     		add	r7, sp, #0
 1865              	.LCFI140:
 1866              		.cfi_def_cfa_register 7
 1867 0006 7860     		str	r0, [r7, #4]
 805:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 806:Src/mc_interface.c ****   return ((MC_NULL == pHandle) ? MC_SW_ERROR : (uint16_t)pHandle->PastFaults);
 807:Src/mc_interface.c **** #else
 808:Src/mc_interface.c ****   return ((uint16_t)pHandle->PastFaults);
 1868              		.loc 6 808 11
 1869 0008 7B68     		ldr	r3, [r7, #4]
 1870 000a 5B8C     		ldrh	r3, [r3, #34]
 809:Src/mc_interface.c **** #endif
 810:Src/mc_interface.c **** }
 1871              		.loc 6 810 1
 1872 000c 1846     		mov	r0, r3
 1873 000e 0C37     		adds	r7, r7, #12
 1874              	.LCFI141:
 1875              		.cfi_def_cfa_offset 4
 1876 0010 BD46     		mov	sp, r7
 1877              	.LCFI142:
 1878              		.cfi_def_cfa_register 13
 1879              		@ sp needed
 1880 0012 5DF8047B 		ldr	r7, [sp], #4
 1881              	.LCFI143:
 1882              		.cfi_restore 7
 1883              		.cfi_def_cfa_offset 0
 1884 0016 7047     		bx	lr
 1885              		.cfi_endproc
 1886              	.LFE1730:
 1888              		.section	.text.MCI_GetCurrentFaults,"ax",%progbits
 1889              		.align	1
 1890              		.weak	MCI_GetCurrentFaults
 1891              		.syntax unified
 1892              		.thumb
 1893              		.thumb_func
 1894              		.fpu fpv4-sp-d16
 1896              	MCI_GetCurrentFaults:
 1897              	.LFB1731:
 811:Src/mc_interface.c **** 
 812:Src/mc_interface.c **** /**
 813:Src/mc_interface.c ****   * @brief Returns the list of faults that are currently active on the target motor
 814:Src/mc_interface.c ****   *
 815:Src/mc_interface.c ****   * This function returns a bitfield that indicates faults that occured on the Motor
 816:Src/mc_interface.c ****   * Control subsystem for the target motor and that are still active (the conditions
 817:Src/mc_interface.c ****   * that triggered the faults returned are still true).
 818:Src/mc_interface.c ****   *
 819:Src/mc_interface.c ****   * Possible error codes are listed in the @ref fault_codes "Fault codes" section.
 820:Src/mc_interface.c ****   *
 821:Src/mc_interface.c ****   * @param  pHandle Pointer on the target motor drive structure.
ARM GAS  /tmp/cc9hWwcq.s 			page 78


 822:Src/mc_interface.c ****   */
 823:Src/mc_interface.c **** __weak uint16_t MCI_GetCurrentFaults(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
 824:Src/mc_interface.c **** {
 1898              		.loc 6 824 1
 1899              		.cfi_startproc
 1900              		@ args = 0, pretend = 0, frame = 8
 1901              		@ frame_needed = 1, uses_anonymous_args = 0
 1902              		@ link register save eliminated.
 1903 0000 80B4     		push	{r7}
 1904              	.LCFI144:
 1905              		.cfi_def_cfa_offset 4
 1906              		.cfi_offset 7, -4
 1907 0002 83B0     		sub	sp, sp, #12
 1908              	.LCFI145:
 1909              		.cfi_def_cfa_offset 16
 1910 0004 00AF     		add	r7, sp, #0
 1911              	.LCFI146:
 1912              		.cfi_def_cfa_register 7
 1913 0006 7860     		str	r0, [r7, #4]
 825:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 826:Src/mc_interface.c ****   return ((MC_NULL == pHandle) ? MC_SW_ERROR : (uint16_t)pHandle->CurrentFaults);
 827:Src/mc_interface.c **** #else
 828:Src/mc_interface.c ****   return ((uint16_t)pHandle->CurrentFaults);
 1914              		.loc 6 828 11
 1915 0008 7B68     		ldr	r3, [r7, #4]
 1916 000a 1B8C     		ldrh	r3, [r3, #32]
 829:Src/mc_interface.c **** #endif
 830:Src/mc_interface.c **** }
 1917              		.loc 6 830 1
 1918 000c 1846     		mov	r0, r3
 1919 000e 0C37     		adds	r7, r7, #12
 1920              	.LCFI147:
 1921              		.cfi_def_cfa_offset 4
 1922 0010 BD46     		mov	sp, r7
 1923              	.LCFI148:
 1924              		.cfi_def_cfa_register 13
 1925              		@ sp needed
 1926 0012 5DF8047B 		ldr	r7, [sp], #4
 1927              	.LCFI149:
 1928              		.cfi_restore 7
 1929              		.cfi_def_cfa_offset 0
 1930 0016 7047     		bx	lr
 1931              		.cfi_endproc
 1932              	.LFE1731:
 1934              		.section	.text.MCI_GetFaultState,"ax",%progbits
 1935              		.align	1
 1936              		.weak	MCI_GetFaultState
 1937              		.syntax unified
 1938              		.thumb
 1939              		.thumb_func
 1940              		.fpu fpv4-sp-d16
 1942              	MCI_GetFaultState:
 1943              	.LFB1732:
 831:Src/mc_interface.c **** 
 832:Src/mc_interface.c **** /**
 833:Src/mc_interface.c ****   * @brief Returns the lists of current and past faults that occurred on the target motor
 834:Src/mc_interface.c ****   *
ARM GAS  /tmp/cc9hWwcq.s 			page 79


 835:Src/mc_interface.c ****   *  This function returns two bitfields containing information about the faults currently
 836:Src/mc_interface.c ****   * present and the faults occurred since the state machine has been moved into the #FAULT_NOW
 837:Src/mc_interface.c ****   * state.
 838:Src/mc_interface.c ****   *
 839:Src/mc_interface.c ****   * These two bitfields are 16 bits wide each and are concatenated into the 32-bit data. The
 840:Src/mc_interface.c ****   * 16 most significant bits contains the status of the current faults while that of the
 841:Src/mc_interface.c ****   * past faults is in the 16 least significant bits.
 842:Src/mc_interface.c ****   *
 843:Src/mc_interface.c ****   * @sa MCI_GetOccurredFaults, MCI_GetCurrentFaults
 844:Src/mc_interface.c ****   *
 845:Src/mc_interface.c ****   * @param  pHandle Pointer on the target motor drive structure.
 846:Src/mc_interface.c ****   */
 847:Src/mc_interface.c **** __weak uint32_t MCI_GetFaultState(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
 848:Src/mc_interface.c **** {
 1944              		.loc 6 848 1
 1945              		.cfi_startproc
 1946              		@ args = 0, pretend = 0, frame = 16
 1947              		@ frame_needed = 1, uses_anonymous_args = 0
 1948              		@ link register save eliminated.
 1949 0000 80B4     		push	{r7}
 1950              	.LCFI150:
 1951              		.cfi_def_cfa_offset 4
 1952              		.cfi_offset 7, -4
 1953 0002 85B0     		sub	sp, sp, #20
 1954              	.LCFI151:
 1955              		.cfi_def_cfa_offset 24
 1956 0004 00AF     		add	r7, sp, #0
 1957              	.LCFI152:
 1958              		.cfi_def_cfa_register 7
 1959 0006 7860     		str	r0, [r7, #4]
 849:Src/mc_interface.c ****   uint32_t LocalFaultState;
 850:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 851:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 852:Src/mc_interface.c ****   {
 853:Src/mc_interface.c ****     LocalFaultState = MC_SW_ERROR | (MC_SW_ERROR << 16);
 854:Src/mc_interface.c ****   }
 855:Src/mc_interface.c ****   else
 856:Src/mc_interface.c ****   {
 857:Src/mc_interface.c **** #endif
 858:Src/mc_interface.c ****     LocalFaultState = (uint32_t)(pHandle->PastFaults);
 1960              		.loc 6 858 41
 1961 0008 7B68     		ldr	r3, [r7, #4]
 1962 000a 5B8C     		ldrh	r3, [r3, #34]
 1963              		.loc 6 858 21
 1964 000c FB60     		str	r3, [r7, #12]
 859:Src/mc_interface.c ****     LocalFaultState |= (uint32_t)(pHandle->CurrentFaults) << 16;
 1965              		.loc 6 859 42
 1966 000e 7B68     		ldr	r3, [r7, #4]
 1967 0010 1B8C     		ldrh	r3, [r3, #32]
 1968              		.loc 6 859 59
 1969 0012 1B04     		lsls	r3, r3, #16
 1970              		.loc 6 859 21
 1971 0014 FA68     		ldr	r2, [r7, #12]
 1972 0016 1343     		orrs	r3, r3, r2
 1973 0018 FB60     		str	r3, [r7, #12]
 860:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 861:Src/mc_interface.c ****   }
ARM GAS  /tmp/cc9hWwcq.s 			page 80


 862:Src/mc_interface.c **** #endif
 863:Src/mc_interface.c ****   return (LocalFaultState);
 1974              		.loc 6 863 10
 1975 001a FB68     		ldr	r3, [r7, #12]
 864:Src/mc_interface.c **** }
 1976              		.loc 6 864 1
 1977 001c 1846     		mov	r0, r3
 1978 001e 1437     		adds	r7, r7, #20
 1979              	.LCFI153:
 1980              		.cfi_def_cfa_offset 4
 1981 0020 BD46     		mov	sp, r7
 1982              	.LCFI154:
 1983              		.cfi_def_cfa_register 13
 1984              		@ sp needed
 1985 0022 5DF8047B 		ldr	r7, [sp], #4
 1986              	.LCFI155:
 1987              		.cfi_restore 7
 1988              		.cfi_def_cfa_offset 0
 1989 0026 7047     		bx	lr
 1990              		.cfi_endproc
 1991              	.LFE1732:
 1993              		.section	.text.MCI_GetControlMode,"ax",%progbits
 1994              		.align	1
 1995              		.weak	MCI_GetControlMode
 1996              		.syntax unified
 1997              		.thumb
 1998              		.thumb_func
 1999              		.fpu fpv4-sp-d16
 2001              	MCI_GetControlMode:
 2002              	.LFB1733:
 865:Src/mc_interface.c **** 
 866:Src/mc_interface.c **** /**
 867:Src/mc_interface.c ****   * @brief  It returns the modality of the speed and torque controller.
 868:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
 869:Src/mc_interface.c ****   * @retval MC_ControlMode_t It returns the modality of STC. It can be one of
 870:Src/mc_interface.c ****   *         these two values: MCM_TORQUE_MODE or MCM_SPEED_MODE.
 871:Src/mc_interface.c ****   */
 872:Src/mc_interface.c **** __weak MC_ControlMode_t MCI_GetControlMode(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
 873:Src/mc_interface.c **** {
 2003              		.loc 6 873 1
 2004              		.cfi_startproc
 2005              		@ args = 0, pretend = 0, frame = 8
 2006              		@ frame_needed = 1, uses_anonymous_args = 0
 2007              		@ link register save eliminated.
 2008 0000 80B4     		push	{r7}
 2009              	.LCFI156:
 2010              		.cfi_def_cfa_offset 4
 2011              		.cfi_offset 7, -4
 2012 0002 83B0     		sub	sp, sp, #12
 2013              	.LCFI157:
 2014              		.cfi_def_cfa_offset 16
 2015 0004 00AF     		add	r7, sp, #0
 2016              	.LCFI158:
 2017              		.cfi_def_cfa_register 7
 2018 0006 7860     		str	r0, [r7, #4]
 874:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 875:Src/mc_interface.c ****   return ((MC_NULL == pHandle) ? MCM_TORQUE_MODE : pHandle->LastModalitySetByUser);
ARM GAS  /tmp/cc9hWwcq.s 			page 81


 876:Src/mc_interface.c **** #else
 877:Src/mc_interface.c ****   return (pHandle->LastModalitySetByUser);
 2019              		.loc 6 877 18
 2020 0008 7B68     		ldr	r3, [r7, #4]
 2021 000a 93F82530 		ldrb	r3, [r3, #37]	@ zero_extendqisi2
 878:Src/mc_interface.c **** #endif
 879:Src/mc_interface.c **** }
 2022              		.loc 6 879 1
 2023 000e 1846     		mov	r0, r3
 2024 0010 0C37     		adds	r7, r7, #12
 2025              	.LCFI159:
 2026              		.cfi_def_cfa_offset 4
 2027 0012 BD46     		mov	sp, r7
 2028              	.LCFI160:
 2029              		.cfi_def_cfa_register 13
 2030              		@ sp needed
 2031 0014 5DF8047B 		ldr	r7, [sp], #4
 2032              	.LCFI161:
 2033              		.cfi_restore 7
 2034              		.cfi_def_cfa_offset 0
 2035 0018 7047     		bx	lr
 2036              		.cfi_endproc
 2037              	.LFE1733:
 2039              		.section	.text.MCI_GetImposedMotorDirection,"ax",%progbits
 2040              		.align	1
 2041              		.weak	MCI_GetImposedMotorDirection
 2042              		.syntax unified
 2043              		.thumb
 2044              		.thumb_func
 2045              		.fpu fpv4-sp-d16
 2047              	MCI_GetImposedMotorDirection:
 2048              	.LFB1734:
 880:Src/mc_interface.c **** 
 881:Src/mc_interface.c **** /**
 882:Src/mc_interface.c ****   * @brief  It returns the motor direction imposed by the last command
 883:Src/mc_interface.c ****   *         (MCI_ExecSpeedRamp, MCI_ExecTorqueRamp or MCI_SetCurrentReferences).
 884:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
 885:Src/mc_interface.c ****   * @retval int16_t It returns 1 or -1 according the sign of hFinalSpeed,
 886:Src/mc_interface.c ****   *         hFinalTorque or Iqdref.q of the last command.
 887:Src/mc_interface.c ****   */
 888:Src/mc_interface.c **** __weak int16_t MCI_GetImposedMotorDirection(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
 889:Src/mc_interface.c **** {
 2049              		.loc 6 889 1
 2050              		.cfi_startproc
 2051              		@ args = 0, pretend = 0, frame = 16
 2052              		@ frame_needed = 1, uses_anonymous_args = 0
 2053              		@ link register save eliminated.
 2054 0000 80B4     		push	{r7}
 2055              	.LCFI162:
 2056              		.cfi_def_cfa_offset 4
 2057              		.cfi_offset 7, -4
 2058 0002 85B0     		sub	sp, sp, #20
 2059              	.LCFI163:
 2060              		.cfi_def_cfa_offset 24
 2061 0004 00AF     		add	r7, sp, #0
 2062              	.LCFI164:
 2063              		.cfi_def_cfa_register 7
ARM GAS  /tmp/cc9hWwcq.s 			page 82


 2064 0006 7860     		str	r0, [r7, #4]
 890:Src/mc_interface.c ****   int16_t retVal = 1;
 2065              		.loc 6 890 11
 2066 0008 0123     		movs	r3, #1
 2067 000a FB81     		strh	r3, [r7, #14]	@ movhi
 891:Src/mc_interface.c **** 
 892:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 893:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 894:Src/mc_interface.c ****   {
 895:Src/mc_interface.c ****     /* Nothing to do */
 896:Src/mc_interface.c ****   }
 897:Src/mc_interface.c ****   else
 898:Src/mc_interface.c ****   {
 899:Src/mc_interface.c **** #endif
 900:Src/mc_interface.c ****     switch (pHandle->lastCommand)
 2068              		.loc 6 900 20
 2069 000c 7B68     		ldr	r3, [r7, #4]
 2070 000e 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 2071              		.loc 6 900 5
 2072 0010 032B     		cmp	r3, #3
 2073 0012 18D0     		beq	.L84
 2074 0014 032B     		cmp	r3, #3
 2075 0016 1FDC     		bgt	.L93
 2076 0018 012B     		cmp	r3, #1
 2077 001a 02D0     		beq	.L86
 2078 001c 022B     		cmp	r3, #2
 2079 001e 09D0     		beq	.L87
 901:Src/mc_interface.c ****     {
 902:Src/mc_interface.c ****       case MCI_CMD_EXECSPEEDRAMP:
 903:Src/mc_interface.c ****       {
 904:Src/mc_interface.c ****         if (pHandle->hFinalSpeed < 0)
 905:Src/mc_interface.c ****         {
 906:Src/mc_interface.c ****           retVal = -1;
 907:Src/mc_interface.c ****         }
 908:Src/mc_interface.c ****         else
 909:Src/mc_interface.c ****         {
 910:Src/mc_interface.c ****           /* Nothing to do */
 911:Src/mc_interface.c ****         }
 912:Src/mc_interface.c ****         break;
 913:Src/mc_interface.c ****       }
 914:Src/mc_interface.c **** 
 915:Src/mc_interface.c ****       case MCI_CMD_EXECTORQUERAMP:
 916:Src/mc_interface.c ****       {
 917:Src/mc_interface.c ****         if (pHandle->hFinalTorque < 0)
 918:Src/mc_interface.c ****         {
 919:Src/mc_interface.c ****           retVal = -1;
 920:Src/mc_interface.c ****         }
 921:Src/mc_interface.c ****         else
 922:Src/mc_interface.c ****         {
 923:Src/mc_interface.c ****           /* Nothing to do */
 924:Src/mc_interface.c ****         }
 925:Src/mc_interface.c ****         break;
 926:Src/mc_interface.c ****       }
 927:Src/mc_interface.c **** 
 928:Src/mc_interface.c ****       case MCI_CMD_SETCURRENTREFERENCES:
 929:Src/mc_interface.c ****       {
 930:Src/mc_interface.c ****         if (pHandle->Iqdref.q < 0)
ARM GAS  /tmp/cc9hWwcq.s 			page 83


 931:Src/mc_interface.c ****         {
 932:Src/mc_interface.c ****           retVal = -1;
 933:Src/mc_interface.c ****         }
 934:Src/mc_interface.c ****         else
 935:Src/mc_interface.c ****         {
 936:Src/mc_interface.c ****           /* Nothing to do */
 937:Src/mc_interface.c ****         }
 938:Src/mc_interface.c ****         break;
 939:Src/mc_interface.c ****        }
 940:Src/mc_interface.c ****       default:
 941:Src/mc_interface.c ****         break;
 2080              		.loc 6 941 9
 2081 0020 1AE0     		b	.L93
 2082              	.L86:
 904:Src/mc_interface.c ****         {
 2083              		.loc 6 904 20
 2084 0022 7B68     		ldr	r3, [r7, #4]
 2085 0024 B3F90E30 		ldrsh	r3, [r3, #14]
 904:Src/mc_interface.c ****         {
 2086              		.loc 6 904 12
 2087 0028 002B     		cmp	r3, #0
 2088 002a 17DA     		bge	.L94
 906:Src/mc_interface.c ****         }
 2089              		.loc 6 906 18
 2090 002c 4FF6FF73 		movw	r3, #65535
 2091 0030 FB81     		strh	r3, [r7, #14]	@ movhi
 912:Src/mc_interface.c ****       }
 2092              		.loc 6 912 9
 2093 0032 13E0     		b	.L94
 2094              	.L87:
 917:Src/mc_interface.c ****         {
 2095              		.loc 6 917 20
 2096 0034 7B68     		ldr	r3, [r7, #4]
 2097 0036 B3F91030 		ldrsh	r3, [r3, #16]
 917:Src/mc_interface.c ****         {
 2098              		.loc 6 917 12
 2099 003a 002B     		cmp	r3, #0
 2100 003c 10DA     		bge	.L95
 919:Src/mc_interface.c ****         }
 2101              		.loc 6 919 18
 2102 003e 4FF6FF73 		movw	r3, #65535
 2103 0042 FB81     		strh	r3, [r7, #14]	@ movhi
 925:Src/mc_interface.c ****       }
 2104              		.loc 6 925 9
 2105 0044 0CE0     		b	.L95
 2106              	.L84:
 930:Src/mc_interface.c ****         {
 2107              		.loc 6 930 28
 2108 0046 7B68     		ldr	r3, [r7, #4]
 2109 0048 B3F91230 		ldrsh	r3, [r3, #18]
 930:Src/mc_interface.c ****         {
 2110              		.loc 6 930 12
 2111 004c 002B     		cmp	r3, #0
 2112 004e 09DA     		bge	.L96
 932:Src/mc_interface.c ****         }
 2113              		.loc 6 932 18
 2114 0050 4FF6FF73 		movw	r3, #65535
ARM GAS  /tmp/cc9hWwcq.s 			page 84


 2115 0054 FB81     		strh	r3, [r7, #14]	@ movhi
 938:Src/mc_interface.c ****        }
 2116              		.loc 6 938 9
 2117 0056 05E0     		b	.L96
 2118              	.L93:
 2119              		.loc 6 941 9
 2120 0058 00BF     		nop
 2121 005a 04E0     		b	.L89
 2122              	.L94:
 912:Src/mc_interface.c ****       }
 2123              		.loc 6 912 9
 2124 005c 00BF     		nop
 2125 005e 02E0     		b	.L89
 2126              	.L95:
 925:Src/mc_interface.c ****       }
 2127              		.loc 6 925 9
 2128 0060 00BF     		nop
 2129 0062 00E0     		b	.L89
 2130              	.L96:
 938:Src/mc_interface.c ****        }
 2131              		.loc 6 938 9
 2132 0064 00BF     		nop
 2133              	.L89:
 942:Src/mc_interface.c ****     }
 943:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 944:Src/mc_interface.c ****   }
 945:Src/mc_interface.c **** #endif
 946:Src/mc_interface.c ****   return (retVal);
 2134              		.loc 6 946 10
 2135 0066 B7F90E30 		ldrsh	r3, [r7, #14]
 947:Src/mc_interface.c **** }
 2136              		.loc 6 947 1
 2137 006a 1846     		mov	r0, r3
 2138 006c 1437     		adds	r7, r7, #20
 2139              	.LCFI165:
 2140              		.cfi_def_cfa_offset 4
 2141 006e BD46     		mov	sp, r7
 2142              	.LCFI166:
 2143              		.cfi_def_cfa_register 13
 2144              		@ sp needed
 2145 0070 5DF8047B 		ldr	r7, [sp], #4
 2146              	.LCFI167:
 2147              		.cfi_restore 7
 2148              		.cfi_def_cfa_offset 0
 2149 0074 7047     		bx	lr
 2150              		.cfi_endproc
 2151              	.LFE1734:
 2153              		.section	.text.MCI_GetLastRampFinalSpeed,"ax",%progbits
 2154              		.align	1
 2155              		.weak	MCI_GetLastRampFinalSpeed
 2156              		.syntax unified
 2157              		.thumb
 2158              		.thumb_func
 2159              		.fpu fpv4-sp-d16
 2161              	MCI_GetLastRampFinalSpeed:
 2162              	.LFB1735:
 948:Src/mc_interface.c **** 
ARM GAS  /tmp/cc9hWwcq.s 			page 85


 949:Src/mc_interface.c **** /**
 950:Src/mc_interface.c ****   * @brief  It returns information about the last ramp final speed sent by the
 951:Src/mc_interface.c ****   *         user expressed in the unit defined by #SPEED_UNIT.
 952:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
 953:Src/mc_interface.c ****   * @retval int16_t last ramp final speed sent by the user expressed in
 954:Src/mc_interface.c ****   *         the unit defined by #SPEED_UNIT.
 955:Src/mc_interface.c ****   */
 956:Src/mc_interface.c **** __weak int16_t MCI_GetLastRampFinalSpeed(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
 957:Src/mc_interface.c **** {
 2163              		.loc 6 957 1
 2164              		.cfi_startproc
 2165              		@ args = 0, pretend = 0, frame = 8
 2166              		@ frame_needed = 1, uses_anonymous_args = 0
 2167              		@ link register save eliminated.
 2168 0000 80B4     		push	{r7}
 2169              	.LCFI168:
 2170              		.cfi_def_cfa_offset 4
 2171              		.cfi_offset 7, -4
 2172 0002 83B0     		sub	sp, sp, #12
 2173              	.LCFI169:
 2174              		.cfi_def_cfa_offset 16
 2175 0004 00AF     		add	r7, sp, #0
 2176              	.LCFI170:
 2177              		.cfi_def_cfa_register 7
 2178 0006 7860     		str	r0, [r7, #4]
 958:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 959:Src/mc_interface.c ****   int16_t retVal = 0;
 960:Src/mc_interface.c **** 
 961:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 962:Src/mc_interface.c ****   {
 963:Src/mc_interface.c ****     /* Nothing to do */
 964:Src/mc_interface.c ****   }
 965:Src/mc_interface.c ****   else
 966:Src/mc_interface.c ****   {
 967:Src/mc_interface.c ****     retVal = pHandle->hFinalSpeed;
 968:Src/mc_interface.c ****   }
 969:Src/mc_interface.c ****   return (retVal);
 970:Src/mc_interface.c **** #else
 971:Src/mc_interface.c ****   return (pHandle->hFinalSpeed);
 2179              		.loc 6 971 18
 2180 0008 7B68     		ldr	r3, [r7, #4]
 2181 000a B3F90E30 		ldrsh	r3, [r3, #14]
 972:Src/mc_interface.c **** #endif
 973:Src/mc_interface.c **** }
 2182              		.loc 6 973 1
 2183 000e 1846     		mov	r0, r3
 2184 0010 0C37     		adds	r7, r7, #12
 2185              	.LCFI171:
 2186              		.cfi_def_cfa_offset 4
 2187 0012 BD46     		mov	sp, r7
 2188              	.LCFI172:
 2189              		.cfi_def_cfa_register 13
 2190              		@ sp needed
 2191 0014 5DF8047B 		ldr	r7, [sp], #4
 2192              	.LCFI173:
 2193              		.cfi_restore 7
 2194              		.cfi_def_cfa_offset 0
ARM GAS  /tmp/cc9hWwcq.s 			page 86


 2195 0018 7047     		bx	lr
 2196              		.cfi_endproc
 2197              	.LFE1735:
 2199              		.section	.text.MCI_GetLastRampFinalTorque,"ax",%progbits
 2200              		.align	1
 2201              		.weak	MCI_GetLastRampFinalTorque
 2202              		.syntax unified
 2203              		.thumb
 2204              		.thumb_func
 2205              		.fpu fpv4-sp-d16
 2207              	MCI_GetLastRampFinalTorque:
 2208              	.LFB1736:
 974:Src/mc_interface.c **** 
 975:Src/mc_interface.c **** /**
 976:Src/mc_interface.c ****   * @brief  It returns information about the last ramp final torque sent by the
 977:Src/mc_interface.c ****   *         user .This value represents actually the Iq current expressed in
 978:Src/mc_interface.c ****   *         digit.
 979:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
 980:Src/mc_interface.c ****   * @retval int16_t last ramp final torque sent by the user expressed in digit
 981:Src/mc_interface.c ****   */
 982:Src/mc_interface.c **** __weak int16_t MCI_GetLastRampFinalTorque(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
 983:Src/mc_interface.c **** {
 2209              		.loc 6 983 1
 2210              		.cfi_startproc
 2211              		@ args = 0, pretend = 0, frame = 8
 2212              		@ frame_needed = 1, uses_anonymous_args = 0
 2213              		@ link register save eliminated.
 2214 0000 80B4     		push	{r7}
 2215              	.LCFI174:
 2216              		.cfi_def_cfa_offset 4
 2217              		.cfi_offset 7, -4
 2218 0002 83B0     		sub	sp, sp, #12
 2219              	.LCFI175:
 2220              		.cfi_def_cfa_offset 16
 2221 0004 00AF     		add	r7, sp, #0
 2222              	.LCFI176:
 2223              		.cfi_def_cfa_register 7
 2224 0006 7860     		str	r0, [r7, #4]
 984:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 985:Src/mc_interface.c ****   int16_t retVal = 0;
 986:Src/mc_interface.c **** 
 987:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 988:Src/mc_interface.c ****   {
 989:Src/mc_interface.c ****     /* Nothing to do */
 990:Src/mc_interface.c ****   }
 991:Src/mc_interface.c ****   else
 992:Src/mc_interface.c ****   {
 993:Src/mc_interface.c ****     retVal = pHandle->hFinalTorque;
 994:Src/mc_interface.c ****   }
 995:Src/mc_interface.c ****   return (retVal);
 996:Src/mc_interface.c **** #else
 997:Src/mc_interface.c ****   return (pHandle->hFinalTorque);
 2225              		.loc 6 997 18
 2226 0008 7B68     		ldr	r3, [r7, #4]
 2227 000a B3F91030 		ldrsh	r3, [r3, #16]
 998:Src/mc_interface.c **** #endif
 999:Src/mc_interface.c **** }
ARM GAS  /tmp/cc9hWwcq.s 			page 87


 2228              		.loc 6 999 1
 2229 000e 1846     		mov	r0, r3
 2230 0010 0C37     		adds	r7, r7, #12
 2231              	.LCFI177:
 2232              		.cfi_def_cfa_offset 4
 2233 0012 BD46     		mov	sp, r7
 2234              	.LCFI178:
 2235              		.cfi_def_cfa_register 13
 2236              		@ sp needed
 2237 0014 5DF8047B 		ldr	r7, [sp], #4
 2238              	.LCFI179:
 2239              		.cfi_restore 7
 2240              		.cfi_def_cfa_offset 0
 2241 0018 7047     		bx	lr
 2242              		.cfi_endproc
 2243              	.LFE1736:
 2245              		.section	.text.MCI_GetLastRampFinalTorque_F,"ax",%progbits
 2246              		.align	1
 2247              		.weak	MCI_GetLastRampFinalTorque_F
 2248              		.syntax unified
 2249              		.thumb
 2250              		.thumb_func
 2251              		.fpu fpv4-sp-d16
 2253              	MCI_GetLastRampFinalTorque_F:
 2254              	.LFB1737:
1000:Src/mc_interface.c **** 
1001:Src/mc_interface.c **** /**
1002:Src/mc_interface.c ****   * @brief  It returns information about the last ramp final torque sent by the
1003:Src/mc_interface.c ****   *         user .This value represents actually the Iq current expressed in
1004:Src/mc_interface.c ****   *         Ampere.
1005:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1006:Src/mc_interface.c ****   * @retval float_t last ramp final torque sent by the user expressed in digit
1007:Src/mc_interface.c ****   */
1008:Src/mc_interface.c **** __weak float_t MCI_GetLastRampFinalTorque_F(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1009:Src/mc_interface.c **** {
 2255              		.loc 6 1009 1
 2256              		.cfi_startproc
 2257              		@ args = 0, pretend = 0, frame = 8
 2258              		@ frame_needed = 1, uses_anonymous_args = 0
 2259              		@ link register save eliminated.
 2260 0000 80B4     		push	{r7}
 2261              	.LCFI180:
 2262              		.cfi_def_cfa_offset 4
 2263              		.cfi_offset 7, -4
 2264 0002 83B0     		sub	sp, sp, #12
 2265              	.LCFI181:
 2266              		.cfi_def_cfa_offset 16
 2267 0004 00AF     		add	r7, sp, #0
 2268              	.LCFI182:
 2269              		.cfi_def_cfa_register 7
 2270 0006 7860     		str	r0, [r7, #4]
1010:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1011:Src/mc_interface.c ****   float_t retVal = 0;
1012:Src/mc_interface.c **** 
1013:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1014:Src/mc_interface.c ****   {
1015:Src/mc_interface.c ****     /* Nothing to do */
ARM GAS  /tmp/cc9hWwcq.s 			page 88


1016:Src/mc_interface.c ****   }
1017:Src/mc_interface.c ****   else
1018:Src/mc_interface.c ****   {
1019:Src/mc_interface.c ****     retVal = ((float_t)pHandle->hFinalTorque * (float_t)pHandle->pScale->current);
1020:Src/mc_interface.c ****   }
1021:Src/mc_interface.c ****   return (retVal);
1022:Src/mc_interface.c **** #else
1023:Src/mc_interface.c ****   return ((float_t)pHandle->hFinalTorque * (float_t)pHandle->pScale->current);
 2271              		.loc 6 1023 27
 2272 0008 7B68     		ldr	r3, [r7, #4]
 2273 000a B3F91030 		ldrsh	r3, [r3, #16]
 2274              		.loc 6 1023 11
 2275 000e 07EE903A 		vmov	s15, r3	@ int
 2276 0012 F8EEE77A 		vcvt.f32.s32	s15, s15
 2277              		.loc 6 1023 60
 2278 0016 7B68     		ldr	r3, [r7, #4]
 2279 0018 9B69     		ldr	r3, [r3, #24]
 2280              		.loc 6 1023 68
 2281 001a 5B68     		ldr	r3, [r3, #4]	@ unaligned
 2282              		.loc 6 1023 42
 2283 001c 07EE103A 		vmov	s14, r3
 2284 0020 67EE877A 		vmul.f32	s15, s15, s14
1024:Src/mc_interface.c **** #endif
1025:Src/mc_interface.c **** }
 2285              		.loc 6 1025 1
 2286 0024 B0EE670A 		vmov.f32	s0, s15
 2287 0028 0C37     		adds	r7, r7, #12
 2288              	.LCFI183:
 2289              		.cfi_def_cfa_offset 4
 2290 002a BD46     		mov	sp, r7
 2291              	.LCFI184:
 2292              		.cfi_def_cfa_register 13
 2293              		@ sp needed
 2294 002c 5DF8047B 		ldr	r7, [sp], #4
 2295              	.LCFI185:
 2296              		.cfi_restore 7
 2297              		.cfi_def_cfa_offset 0
 2298 0030 7047     		bx	lr
 2299              		.cfi_endproc
 2300              	.LFE1737:
 2302              		.section	.text.MCI_GetLastRampFinalDuration,"ax",%progbits
 2303              		.align	1
 2304              		.weak	MCI_GetLastRampFinalDuration
 2305              		.syntax unified
 2306              		.thumb
 2307              		.thumb_func
 2308              		.fpu fpv4-sp-d16
 2310              	MCI_GetLastRampFinalDuration:
 2311              	.LFB1738:
1026:Src/mc_interface.c **** 
1027:Src/mc_interface.c **** /**
1028:Src/mc_interface.c ****   * @brief  It returns information about the last ramp Duration sent by the
1029:Src/mc_interface.c ****   *         user .
1030:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1031:Src/mc_interface.c ****   * @retval uint16_t last ramp final torque sent by the user expressed in digit
1032:Src/mc_interface.c ****   */
1033:Src/mc_interface.c **** __weak uint16_t MCI_GetLastRampFinalDuration(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
ARM GAS  /tmp/cc9hWwcq.s 			page 89


1034:Src/mc_interface.c **** {
 2312              		.loc 6 1034 1
 2313              		.cfi_startproc
 2314              		@ args = 0, pretend = 0, frame = 8
 2315              		@ frame_needed = 1, uses_anonymous_args = 0
 2316              		@ link register save eliminated.
 2317 0000 80B4     		push	{r7}
 2318              	.LCFI186:
 2319              		.cfi_def_cfa_offset 4
 2320              		.cfi_offset 7, -4
 2321 0002 83B0     		sub	sp, sp, #12
 2322              	.LCFI187:
 2323              		.cfi_def_cfa_offset 16
 2324 0004 00AF     		add	r7, sp, #0
 2325              	.LCFI188:
 2326              		.cfi_def_cfa_register 7
 2327 0006 7860     		str	r0, [r7, #4]
1035:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1036:Src/mc_interface.c ****   uint16_t retVal = 0;
1037:Src/mc_interface.c **** 
1038:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1039:Src/mc_interface.c ****   {
1040:Src/mc_interface.c ****     /* Nothing to do */
1041:Src/mc_interface.c ****   }
1042:Src/mc_interface.c ****   else
1043:Src/mc_interface.c ****   {
1044:Src/mc_interface.c ****     retVal = pHandle->hDurationms;
1045:Src/mc_interface.c ****   }
1046:Src/mc_interface.c ****   return (retVal);
1047:Src/mc_interface.c **** #else
1048:Src/mc_interface.c ****   return (pHandle->hDurationms);
 2328              		.loc 6 1048 18
 2329 0008 7B68     		ldr	r3, [r7, #4]
 2330 000a 9B8B     		ldrh	r3, [r3, #28]
1049:Src/mc_interface.c **** #endif
1050:Src/mc_interface.c **** }
 2331              		.loc 6 1050 1
 2332 000c 1846     		mov	r0, r3
 2333 000e 0C37     		adds	r7, r7, #12
 2334              	.LCFI189:
 2335              		.cfi_def_cfa_offset 4
 2336 0010 BD46     		mov	sp, r7
 2337              	.LCFI190:
 2338              		.cfi_def_cfa_register 13
 2339              		@ sp needed
 2340 0012 5DF8047B 		ldr	r7, [sp], #4
 2341              	.LCFI191:
 2342              		.cfi_restore 7
 2343              		.cfi_def_cfa_offset 0
 2344 0016 7047     		bx	lr
 2345              		.cfi_endproc
 2346              	.LFE1738:
 2348              		.section	.text.MCI_GetLastRampFinalSpeed_F,"ax",%progbits
 2349              		.align	1
 2350              		.weak	MCI_GetLastRampFinalSpeed_F
 2351              		.syntax unified
 2352              		.thumb
ARM GAS  /tmp/cc9hWwcq.s 			page 90


 2353              		.thumb_func
 2354              		.fpu fpv4-sp-d16
 2356              	MCI_GetLastRampFinalSpeed_F:
 2357              	.LFB1739:
1051:Src/mc_interface.c **** 
1052:Src/mc_interface.c **** /**
1053:Src/mc_interface.c ****   * @brief  It returns last ramp final speed expressed in rpm.
1054:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1055:Src/mc_interface.c ****   * @retval float_t last ramp final speed sent by the user expressed in rpm.
1056:Src/mc_interface.c ****   */
1057:Src/mc_interface.c **** __weak float_t MCI_GetLastRampFinalSpeed_F(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1058:Src/mc_interface.c **** {
 2358              		.loc 6 1058 1
 2359              		.cfi_startproc
 2360              		@ args = 0, pretend = 0, frame = 16
 2361              		@ frame_needed = 1, uses_anonymous_args = 0
 2362              		@ link register save eliminated.
 2363 0000 80B4     		push	{r7}
 2364              	.LCFI192:
 2365              		.cfi_def_cfa_offset 4
 2366              		.cfi_offset 7, -4
 2367 0002 85B0     		sub	sp, sp, #20
 2368              	.LCFI193:
 2369              		.cfi_def_cfa_offset 24
 2370 0004 00AF     		add	r7, sp, #0
 2371              	.LCFI194:
 2372              		.cfi_def_cfa_register 7
 2373 0006 7860     		str	r0, [r7, #4]
1059:Src/mc_interface.c ****   float_t reVal = 0.0f;
 2374              		.loc 6 1059 11
 2375 0008 4FF00003 		mov	r3, #0
 2376 000c FB60     		str	r3, [r7, #12]	@ float
1060:Src/mc_interface.c **** 
1061:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 2377              		.loc 6 1061 6
 2378 000e 7B68     		ldr	r3, [r7, #4]
 2379 0010 002B     		cmp	r3, #0
 2380 0012 10D0     		beq	.L106
1062:Src/mc_interface.c ****   {
1063:Src/mc_interface.c ****     /* Nothing to do */
1064:Src/mc_interface.c ****   }
1065:Src/mc_interface.c ****   else
1066:Src/mc_interface.c ****   {
1067:Src/mc_interface.c ****     reVal = (((float_t)pHandle->hFinalSpeed * (float_t)U_RPM) / (float_t)SPEED_UNIT);
 2381              		.loc 6 1067 31
 2382 0014 7B68     		ldr	r3, [r7, #4]
 2383 0016 B3F90E30 		ldrsh	r3, [r3, #14]
 2384              		.loc 6 1067 15
 2385 001a 07EE903A 		vmov	s15, r3	@ int
 2386 001e F8EEE77A 		vcvt.f32.s32	s15, s15
 2387              		.loc 6 1067 45
 2388 0022 9FED0A7A 		vldr.32	s14, .L108
 2389 0026 27EE877A 		vmul.f32	s14, s15, s14
 2390              		.loc 6 1067 11
 2391 002a F2EE046A 		vmov.f32	s13, #1.0e+1
 2392 002e C7EE267A 		vdiv.f32	s15, s14, s13
 2393 0032 C7ED037A 		vstr.32	s15, [r7, #12]
ARM GAS  /tmp/cc9hWwcq.s 			page 91


 2394              	.L106:
1068:Src/mc_interface.c ****   }
1069:Src/mc_interface.c ****   return (reVal);
 2395              		.loc 6 1069 10
 2396 0036 FB68     		ldr	r3, [r7, #12]	@ float
 2397 0038 07EE903A 		vmov	s15, r3
1070:Src/mc_interface.c **** }
 2398              		.loc 6 1070 1
 2399 003c B0EE670A 		vmov.f32	s0, s15
 2400 0040 1437     		adds	r7, r7, #20
 2401              	.LCFI195:
 2402              		.cfi_def_cfa_offset 4
 2403 0042 BD46     		mov	sp, r7
 2404              	.LCFI196:
 2405              		.cfi_def_cfa_register 13
 2406              		@ sp needed
 2407 0044 5DF8047B 		ldr	r7, [sp], #4
 2408              	.LCFI197:
 2409              		.cfi_restore 7
 2410              		.cfi_def_cfa_offset 0
 2411 0048 7047     		bx	lr
 2412              	.L109:
 2413 004a 00BF     		.align	2
 2414              	.L108:
 2415 004c 00007042 		.word	1114636288
 2416              		.cfi_endproc
 2417              	.LFE1739:
 2419              		.section	.text.MCI_RampCompleted,"ax",%progbits
 2420              		.align	1
 2421              		.weak	MCI_RampCompleted
 2422              		.syntax unified
 2423              		.thumb
 2424              		.thumb_func
 2425              		.fpu fpv4-sp-d16
 2427              	MCI_RampCompleted:
 2428              	.LFB1740:
1071:Src/mc_interface.c **** 
1072:Src/mc_interface.c **** /**
1073:Src/mc_interface.c ****   * @brief  Check if the settled speed or torque ramp has been completed.
1074:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1075:Src/mc_interface.c ****   * @retval bool It returns true if the ramp is completed, false otherwise.
1076:Src/mc_interface.c ****   */
1077:Src/mc_interface.c **** __weak bool MCI_RampCompleted(MCI_Handle_t *pHandle)
1078:Src/mc_interface.c **** {
 2429              		.loc 6 1078 1
 2430              		.cfi_startproc
 2431              		@ args = 0, pretend = 0, frame = 16
 2432              		@ frame_needed = 1, uses_anonymous_args = 0
 2433 0000 80B5     		push	{r7, lr}
 2434              	.LCFI198:
 2435              		.cfi_def_cfa_offset 8
 2436              		.cfi_offset 7, -8
 2437              		.cfi_offset 14, -4
 2438 0002 84B0     		sub	sp, sp, #16
 2439              	.LCFI199:
 2440              		.cfi_def_cfa_offset 24
 2441 0004 00AF     		add	r7, sp, #0
ARM GAS  /tmp/cc9hWwcq.s 			page 92


 2442              	.LCFI200:
 2443              		.cfi_def_cfa_register 7
 2444 0006 7860     		str	r0, [r7, #4]
1079:Src/mc_interface.c ****   bool retVal = false;
 2445              		.loc 6 1079 8
 2446 0008 0023     		movs	r3, #0
 2447 000a FB73     		strb	r3, [r7, #15]
1080:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1081:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1082:Src/mc_interface.c ****   {
1083:Src/mc_interface.c ****     /* Nothing to do */
1084:Src/mc_interface.c ****   }
1085:Src/mc_interface.c ****   else
1086:Src/mc_interface.c ****   {
1087:Src/mc_interface.c **** #endif
1088:Src/mc_interface.c ****     if (RUN == MCI_GetSTMState(pHandle))
 2448              		.loc 6 1088 16
 2449 000c 7868     		ldr	r0, [r7, #4]
 2450 000e FFF7FEFF 		bl	MCI_GetSTMState
 2451 0012 0346     		mov	r3, r0
 2452              		.loc 6 1088 8
 2453 0014 062B     		cmp	r3, #6
 2454 0016 06D1     		bne	.L111
1089:Src/mc_interface.c ****     {
1090:Src/mc_interface.c ****       retVal = STC_RampCompleted(pHandle->pSTC);
 2455              		.loc 6 1090 16
 2456 0018 7B68     		ldr	r3, [r7, #4]
 2457 001a 1B68     		ldr	r3, [r3]
 2458 001c 1846     		mov	r0, r3
 2459 001e FFF7FEFF 		bl	STC_RampCompleted
 2460 0022 0346     		mov	r3, r0
 2461 0024 FB73     		strb	r3, [r7, #15]
 2462              	.L111:
1091:Src/mc_interface.c ****     }
1092:Src/mc_interface.c ****     else
1093:Src/mc_interface.c ****     {
1094:Src/mc_interface.c ****       /* Nothing to do */
1095:Src/mc_interface.c ****     }
1096:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1097:Src/mc_interface.c ****   }
1098:Src/mc_interface.c **** #endif
1099:Src/mc_interface.c ****   return (retVal);
 2463              		.loc 6 1099 10
 2464 0026 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
1100:Src/mc_interface.c **** }
 2465              		.loc 6 1100 1
 2466 0028 1846     		mov	r0, r3
 2467 002a 1037     		adds	r7, r7, #16
 2468              	.LCFI201:
 2469              		.cfi_def_cfa_offset 8
 2470 002c BD46     		mov	sp, r7
 2471              	.LCFI202:
 2472              		.cfi_def_cfa_register 13
 2473              		@ sp needed
 2474 002e 80BD     		pop	{r7, pc}
 2475              		.cfi_endproc
 2476              	.LFE1740:
ARM GAS  /tmp/cc9hWwcq.s 			page 93


 2478              		.section	.text.MCI_StopSpeedRamp,"ax",%progbits
 2479              		.align	1
 2480              		.weak	MCI_StopSpeedRamp
 2481              		.syntax unified
 2482              		.thumb
 2483              		.thumb_func
 2484              		.fpu fpv4-sp-d16
 2486              	MCI_StopSpeedRamp:
 2487              	.LFB1741:
1101:Src/mc_interface.c **** 
1102:Src/mc_interface.c **** /**
1103:Src/mc_interface.c ****   * @brief  Stop the execution of speed ramp.
1104:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1105:Src/mc_interface.c ****   * @retval bool It returns true if the command is executed, false otherwise.
1106:Src/mc_interface.c ****   *
1107:Src/mc_interface.c ****   * @deprecated This function is deprecated and should not be used anymore. It will be
1108:Src/mc_interface.c ****   *             removed in a future version of the MCSDK. Use MCI_StopRamp() instead.
1109:Src/mc_interface.c ****   */
1110:Src/mc_interface.c **** __weak bool MCI_StopSpeedRamp(MCI_Handle_t *pHandle)
1111:Src/mc_interface.c **** {
 2488              		.loc 6 1111 1
 2489              		.cfi_startproc
 2490              		@ args = 0, pretend = 0, frame = 8
 2491              		@ frame_needed = 1, uses_anonymous_args = 0
 2492 0000 80B5     		push	{r7, lr}
 2493              	.LCFI203:
 2494              		.cfi_def_cfa_offset 8
 2495              		.cfi_offset 7, -8
 2496              		.cfi_offset 14, -4
 2497 0002 82B0     		sub	sp, sp, #8
 2498              	.LCFI204:
 2499              		.cfi_def_cfa_offset 16
 2500 0004 00AF     		add	r7, sp, #0
 2501              	.LCFI205:
 2502              		.cfi_def_cfa_register 7
 2503 0006 7860     		str	r0, [r7, #4]
1112:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1113:Src/mc_interface.c ****   return ((MC_NULL == pHandle) ? false : STC_StopSpeedRamp(pHandle->pSTC));
1114:Src/mc_interface.c **** #else
1115:Src/mc_interface.c ****   return (STC_StopSpeedRamp(pHandle->pSTC));
 2504              		.loc 6 1115 11
 2505 0008 7B68     		ldr	r3, [r7, #4]
 2506 000a 1B68     		ldr	r3, [r3]
 2507 000c 1846     		mov	r0, r3
 2508 000e FFF7FEFF 		bl	STC_StopSpeedRamp
 2509 0012 0346     		mov	r3, r0
1116:Src/mc_interface.c **** #endif
1117:Src/mc_interface.c **** }
 2510              		.loc 6 1117 1
 2511 0014 1846     		mov	r0, r3
 2512 0016 0837     		adds	r7, r7, #8
 2513              	.LCFI206:
 2514              		.cfi_def_cfa_offset 8
 2515 0018 BD46     		mov	sp, r7
 2516              	.LCFI207:
 2517              		.cfi_def_cfa_register 13
 2518              		@ sp needed
ARM GAS  /tmp/cc9hWwcq.s 			page 94


 2519 001a 80BD     		pop	{r7, pc}
 2520              		.cfi_endproc
 2521              	.LFE1741:
 2523              		.section	.text.MCI_StopRamp,"ax",%progbits
 2524              		.align	1
 2525              		.weak	MCI_StopRamp
 2526              		.syntax unified
 2527              		.thumb
 2528              		.thumb_func
 2529              		.fpu fpv4-sp-d16
 2531              	MCI_StopRamp:
 2532              	.LFB1742:
1118:Src/mc_interface.c **** 
1119:Src/mc_interface.c **** /**
1120:Src/mc_interface.c ****   * @brief  Stop the execution of ongoing ramp.
1121:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1122:Src/mc_interface.c ****   */
1123:Src/mc_interface.c **** __weak void MCI_StopRamp(MCI_Handle_t *pHandle)
1124:Src/mc_interface.c **** {
 2533              		.loc 6 1124 1
 2534              		.cfi_startproc
 2535              		@ args = 0, pretend = 0, frame = 8
 2536              		@ frame_needed = 1, uses_anonymous_args = 0
 2537 0000 80B5     		push	{r7, lr}
 2538              	.LCFI208:
 2539              		.cfi_def_cfa_offset 8
 2540              		.cfi_offset 7, -8
 2541              		.cfi_offset 14, -4
 2542 0002 82B0     		sub	sp, sp, #8
 2543              	.LCFI209:
 2544              		.cfi_def_cfa_offset 16
 2545 0004 00AF     		add	r7, sp, #0
 2546              	.LCFI210:
 2547              		.cfi_def_cfa_register 7
 2548 0006 7860     		str	r0, [r7, #4]
1125:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1126:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1127:Src/mc_interface.c ****   {
1128:Src/mc_interface.c ****     /* Nothing to do */
1129:Src/mc_interface.c ****   }
1130:Src/mc_interface.c ****   else
1131:Src/mc_interface.c ****   {
1132:Src/mc_interface.c **** #endif
1133:Src/mc_interface.c ****     STC_StopRamp(pHandle->pSTC);
 2549              		.loc 6 1133 5
 2550 0008 7B68     		ldr	r3, [r7, #4]
 2551 000a 1B68     		ldr	r3, [r3]
 2552 000c 1846     		mov	r0, r3
 2553 000e FFF7FEFF 		bl	STC_StopRamp
1134:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1135:Src/mc_interface.c ****   }
1136:Src/mc_interface.c **** #endif
1137:Src/mc_interface.c **** }
 2554              		.loc 6 1137 1
 2555 0012 00BF     		nop
 2556 0014 0837     		adds	r7, r7, #8
 2557              	.LCFI211:
ARM GAS  /tmp/cc9hWwcq.s 			page 95


 2558              		.cfi_def_cfa_offset 8
 2559 0016 BD46     		mov	sp, r7
 2560              	.LCFI212:
 2561              		.cfi_def_cfa_register 13
 2562              		@ sp needed
 2563 0018 80BD     		pop	{r7, pc}
 2564              		.cfi_endproc
 2565              	.LFE1742:
 2567              		.section	.text.MCI_GetSpdSensorReliability,"ax",%progbits
 2568              		.align	1
 2569              		.weak	MCI_GetSpdSensorReliability
 2570              		.syntax unified
 2571              		.thumb
 2572              		.thumb_func
 2573              		.fpu fpv4-sp-d16
 2575              	MCI_GetSpdSensorReliability:
 2576              	.LFB1743:
1138:Src/mc_interface.c **** 
1139:Src/mc_interface.c **** /**
1140:Src/mc_interface.c ****   * @brief  It returns speed sensor reliability with reference to the sensor
1141:Src/mc_interface.c ****   *         actually used for reference frame transformation
1142:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1143:Src/mc_interface.c ****   * @retval bool It returns true if the speed sensor utilized for reference
1144:Src/mc_interface.c ****   *         frame transformation and (in speed control mode) for speed
1145:Src/mc_interface.c ****   *         regulation is reliable, false otherwise
1146:Src/mc_interface.c ****   */
1147:Src/mc_interface.c **** __weak bool MCI_GetSpdSensorReliability(MCI_Handle_t *pHandle)
1148:Src/mc_interface.c **** {
 2577              		.loc 6 1148 1
 2578              		.cfi_startproc
 2579              		@ args = 0, pretend = 0, frame = 16
 2580              		@ frame_needed = 1, uses_anonymous_args = 0
 2581 0000 80B5     		push	{r7, lr}
 2582              	.LCFI213:
 2583              		.cfi_def_cfa_offset 8
 2584              		.cfi_offset 7, -8
 2585              		.cfi_offset 14, -4
 2586 0002 84B0     		sub	sp, sp, #16
 2587              	.LCFI214:
 2588              		.cfi_def_cfa_offset 24
 2589 0004 00AF     		add	r7, sp, #0
 2590              	.LCFI215:
 2591              		.cfi_def_cfa_register 7
 2592 0006 7860     		str	r0, [r7, #4]
1149:Src/mc_interface.c ****   bool status;
1150:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1151:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1152:Src/mc_interface.c ****   {
1153:Src/mc_interface.c ****     status = false;
1154:Src/mc_interface.c ****   }
1155:Src/mc_interface.c ****   else
1156:Src/mc_interface.c ****   {
1157:Src/mc_interface.c **** #endif
1158:Src/mc_interface.c ****     SpeednPosFdbk_Handle_t *SpeedSensor = STC_GetSpeedSensor(pHandle->pSTC);
 2593              		.loc 6 1158 43
 2594 0008 7B68     		ldr	r3, [r7, #4]
 2595 000a 1B68     		ldr	r3, [r3]
ARM GAS  /tmp/cc9hWwcq.s 			page 96


 2596 000c 1846     		mov	r0, r3
 2597 000e FFF7FEFF 		bl	STC_GetSpeedSensor
 2598 0012 F860     		str	r0, [r7, #12]
1159:Src/mc_interface.c ****     status = SPD_Check(SpeedSensor);
 2599              		.loc 6 1159 14
 2600 0014 F868     		ldr	r0, [r7, #12]
 2601 0016 FFF7FEFF 		bl	SPD_Check
 2602 001a 0346     		mov	r3, r0
 2603 001c FB72     		strb	r3, [r7, #11]
1160:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1161:Src/mc_interface.c ****   }
1162:Src/mc_interface.c **** #endif
1163:Src/mc_interface.c **** 
1164:Src/mc_interface.c ****   return (status);
 2604              		.loc 6 1164 10
 2605 001e FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
1165:Src/mc_interface.c **** }
 2606              		.loc 6 1165 1
 2607 0020 1846     		mov	r0, r3
 2608 0022 1037     		adds	r7, r7, #16
 2609              	.LCFI216:
 2610              		.cfi_def_cfa_offset 8
 2611 0024 BD46     		mov	sp, r7
 2612              	.LCFI217:
 2613              		.cfi_def_cfa_register 13
 2614              		@ sp needed
 2615 0026 80BD     		pop	{r7, pc}
 2616              		.cfi_endproc
 2617              	.LFE1743:
 2619              		.section	.text.MCI_GetAvrgMecSpeedUnit,"ax",%progbits
 2620              		.align	1
 2621              		.weak	MCI_GetAvrgMecSpeedUnit
 2622              		.syntax unified
 2623              		.thumb
 2624              		.thumb_func
 2625              		.fpu fpv4-sp-d16
 2627              	MCI_GetAvrgMecSpeedUnit:
 2628              	.LFB1744:
1166:Src/mc_interface.c **** 
1167:Src/mc_interface.c **** /**
1168:Src/mc_interface.c ****   * @brief  Returns the last computed average mechanical speed, expressed in
1169:Src/mc_interface.c ****   *         the unit defined by #SPEED_UNIT and related to the sensor actually
1170:Src/mc_interface.c ****   *         used by FOC algorithm
1171:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1172:Src/mc_interface.c ****   */
1173:Src/mc_interface.c **** __weak int16_t MCI_GetAvrgMecSpeedUnit(MCI_Handle_t *pHandle)
1174:Src/mc_interface.c **** {
 2629              		.loc 6 1174 1
 2630              		.cfi_startproc
 2631              		@ args = 0, pretend = 0, frame = 16
 2632              		@ frame_needed = 1, uses_anonymous_args = 0
 2633 0000 80B5     		push	{r7, lr}
 2634              	.LCFI218:
 2635              		.cfi_def_cfa_offset 8
 2636              		.cfi_offset 7, -8
 2637              		.cfi_offset 14, -4
 2638 0002 84B0     		sub	sp, sp, #16
ARM GAS  /tmp/cc9hWwcq.s 			page 97


 2639              	.LCFI219:
 2640              		.cfi_def_cfa_offset 24
 2641 0004 00AF     		add	r7, sp, #0
 2642              	.LCFI220:
 2643              		.cfi_def_cfa_register 7
 2644 0006 7860     		str	r0, [r7, #4]
1175:Src/mc_interface.c ****   int16_t temp_speed;
1176:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1177:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1178:Src/mc_interface.c ****   {
1179:Src/mc_interface.c ****     temp_speed = 0;
1180:Src/mc_interface.c ****   }
1181:Src/mc_interface.c ****   else
1182:Src/mc_interface.c ****   {
1183:Src/mc_interface.c **** #endif
1184:Src/mc_interface.c ****     SpeednPosFdbk_Handle_t * SpeedSensor = STC_GetSpeedSensor(pHandle->pSTC);
 2645              		.loc 6 1184 44
 2646 0008 7B68     		ldr	r3, [r7, #4]
 2647 000a 1B68     		ldr	r3, [r3]
 2648 000c 1846     		mov	r0, r3
 2649 000e FFF7FEFF 		bl	STC_GetSpeedSensor
 2650 0012 F860     		str	r0, [r7, #12]
1185:Src/mc_interface.c ****     temp_speed = SPD_GetAvrgMecSpeedUnit(SpeedSensor);
 2651              		.loc 6 1185 18
 2652 0014 F868     		ldr	r0, [r7, #12]
 2653 0016 FFF7FEFF 		bl	SPD_GetAvrgMecSpeedUnit
 2654 001a 0346     		mov	r3, r0
 2655 001c 7B81     		strh	r3, [r7, #10]	@ movhi
1186:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1187:Src/mc_interface.c ****   }
1188:Src/mc_interface.c **** #endif
1189:Src/mc_interface.c ****   return (temp_speed);
 2656              		.loc 6 1189 10
 2657 001e B7F90A30 		ldrsh	r3, [r7, #10]
1190:Src/mc_interface.c **** }
 2658              		.loc 6 1190 1
 2659 0022 1846     		mov	r0, r3
 2660 0024 1037     		adds	r7, r7, #16
 2661              	.LCFI221:
 2662              		.cfi_def_cfa_offset 8
 2663 0026 BD46     		mov	sp, r7
 2664              	.LCFI222:
 2665              		.cfi_def_cfa_register 13
 2666              		@ sp needed
 2667 0028 80BD     		pop	{r7, pc}
 2668              		.cfi_endproc
 2669              	.LFE1744:
 2671              		.section	.text.MCI_GetAvrgMecSpeed_F,"ax",%progbits
 2672              		.align	1
 2673              		.weak	MCI_GetAvrgMecSpeed_F
 2674              		.syntax unified
 2675              		.thumb
 2676              		.thumb_func
 2677              		.fpu fpv4-sp-d16
 2679              	MCI_GetAvrgMecSpeed_F:
 2680              	.LFB1745:
1191:Src/mc_interface.c **** 
ARM GAS  /tmp/cc9hWwcq.s 			page 98


1192:Src/mc_interface.c **** /**
1193:Src/mc_interface.c ****   * @brief  Returns the last computed average mechanical speed, expressed in rpm
1194:Src/mc_interface.c ****   *         and related to the sensor actually used by FOC algorithm.
1195:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1196:Src/mc_interface.c ****   */
1197:Src/mc_interface.c **** __weak float_t MCI_GetAvrgMecSpeed_F(MCI_Handle_t *pHandle)
1198:Src/mc_interface.c **** {
 2681              		.loc 6 1198 1
 2682              		.cfi_startproc
 2683              		@ args = 0, pretend = 0, frame = 16
 2684              		@ frame_needed = 1, uses_anonymous_args = 0
 2685 0000 80B5     		push	{r7, lr}
 2686              	.LCFI223:
 2687              		.cfi_def_cfa_offset 8
 2688              		.cfi_offset 7, -8
 2689              		.cfi_offset 14, -4
 2690 0002 84B0     		sub	sp, sp, #16
 2691              	.LCFI224:
 2692              		.cfi_def_cfa_offset 24
 2693 0004 00AF     		add	r7, sp, #0
 2694              	.LCFI225:
 2695              		.cfi_def_cfa_register 7
 2696 0006 7860     		str	r0, [r7, #4]
1199:Src/mc_interface.c ****   float_t returnAvrgSpeed;
1200:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1201:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1202:Src/mc_interface.c ****   {
1203:Src/mc_interface.c ****     returnAvrgSpeed = 0.0f;
1204:Src/mc_interface.c ****   }
1205:Src/mc_interface.c ****   else
1206:Src/mc_interface.c ****   {
1207:Src/mc_interface.c **** #endif
1208:Src/mc_interface.c ****     SpeednPosFdbk_Handle_t *SpeedSensor = STC_GetSpeedSensor(pHandle->pSTC);
 2697              		.loc 6 1208 43
 2698 0008 7B68     		ldr	r3, [r7, #4]
 2699 000a 1B68     		ldr	r3, [r3]
 2700 000c 1846     		mov	r0, r3
 2701 000e FFF7FEFF 		bl	STC_GetSpeedSensor
 2702 0012 F860     		str	r0, [r7, #12]
1209:Src/mc_interface.c ****     returnAvrgSpeed = (((float_t)SPD_GetAvrgMecSpeedUnit(SpeedSensor) * (float_t)U_RPM) / (float_t)
 2703              		.loc 6 1209 34
 2704 0014 F868     		ldr	r0, [r7, #12]
 2705 0016 FFF7FEFF 		bl	SPD_GetAvrgMecSpeedUnit
 2706 001a 0346     		mov	r3, r0
 2707 001c 07EE903A 		vmov	s15, r3	@ int
 2708              		.loc 6 1209 25
 2709 0020 F8EEE77A 		vcvt.f32.s32	s15, s15
 2710              		.loc 6 1209 71
 2711 0024 9FED087A 		vldr.32	s14, .L122
 2712 0028 27EE877A 		vmul.f32	s14, s15, s14
 2713              		.loc 6 1209 21
 2714 002c F2EE046A 		vmov.f32	s13, #1.0e+1
 2715 0030 C7EE267A 		vdiv.f32	s15, s14, s13
 2716 0034 C7ED027A 		vstr.32	s15, [r7, #8]
1210:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1211:Src/mc_interface.c ****   }
1212:Src/mc_interface.c **** #endif
ARM GAS  /tmp/cc9hWwcq.s 			page 99


1213:Src/mc_interface.c ****   return (returnAvrgSpeed);
 2717              		.loc 6 1213 10
 2718 0038 BB68     		ldr	r3, [r7, #8]	@ float
 2719 003a 07EE903A 		vmov	s15, r3
1214:Src/mc_interface.c **** }
 2720              		.loc 6 1214 1
 2721 003e B0EE670A 		vmov.f32	s0, s15
 2722 0042 1037     		adds	r7, r7, #16
 2723              	.LCFI226:
 2724              		.cfi_def_cfa_offset 8
 2725 0044 BD46     		mov	sp, r7
 2726              	.LCFI227:
 2727              		.cfi_def_cfa_register 13
 2728              		@ sp needed
 2729 0046 80BD     		pop	{r7, pc}
 2730              	.L123:
 2731              		.align	2
 2732              	.L122:
 2733 0048 00007042 		.word	1114636288
 2734              		.cfi_endproc
 2735              	.LFE1745:
 2737              		.section	.text.MCI_GetMecSpeedRefUnit,"ax",%progbits
 2738              		.align	1
 2739              		.weak	MCI_GetMecSpeedRefUnit
 2740              		.syntax unified
 2741              		.thumb
 2742              		.thumb_func
 2743              		.fpu fpv4-sp-d16
 2745              	MCI_GetMecSpeedRefUnit:
 2746              	.LFB1746:
1215:Src/mc_interface.c **** 
1216:Src/mc_interface.c **** /**
1217:Src/mc_interface.c ****   * @brief  Returns the current mechanical rotor speed reference expressed in the unit defined by #
1218:Src/mc_interface.c ****   *
1219:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1220:Src/mc_interface.c ****   *
1221:Src/mc_interface.c ****   */
1222:Src/mc_interface.c **** __weak int16_t MCI_GetMecSpeedRefUnit(MCI_Handle_t *pHandle)
1223:Src/mc_interface.c **** {
 2747              		.loc 6 1223 1
 2748              		.cfi_startproc
 2749              		@ args = 0, pretend = 0, frame = 8
 2750              		@ frame_needed = 1, uses_anonymous_args = 0
 2751 0000 80B5     		push	{r7, lr}
 2752              	.LCFI228:
 2753              		.cfi_def_cfa_offset 8
 2754              		.cfi_offset 7, -8
 2755              		.cfi_offset 14, -4
 2756 0002 82B0     		sub	sp, sp, #8
 2757              	.LCFI229:
 2758              		.cfi_def_cfa_offset 16
 2759 0004 00AF     		add	r7, sp, #0
 2760              	.LCFI230:
 2761              		.cfi_def_cfa_register 7
 2762 0006 7860     		str	r0, [r7, #4]
1224:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1225:Src/mc_interface.c ****   return ((MC_NULL == pHandle) ? 0 : STC_GetMecSpeedRefUnit(pHandle->pSTC));
ARM GAS  /tmp/cc9hWwcq.s 			page 100


1226:Src/mc_interface.c **** #else
1227:Src/mc_interface.c ****   return (STC_GetMecSpeedRefUnit(pHandle->pSTC));
 2763              		.loc 6 1227 11
 2764 0008 7B68     		ldr	r3, [r7, #4]
 2765 000a 1B68     		ldr	r3, [r3]
 2766 000c 1846     		mov	r0, r3
 2767 000e FFF7FEFF 		bl	STC_GetMecSpeedRefUnit
 2768 0012 0346     		mov	r3, r0
1228:Src/mc_interface.c **** #endif
1229:Src/mc_interface.c **** }
 2769              		.loc 6 1229 1
 2770 0014 1846     		mov	r0, r3
 2771 0016 0837     		adds	r7, r7, #8
 2772              	.LCFI231:
 2773              		.cfi_def_cfa_offset 8
 2774 0018 BD46     		mov	sp, r7
 2775              	.LCFI232:
 2776              		.cfi_def_cfa_register 13
 2777              		@ sp needed
 2778 001a 80BD     		pop	{r7, pc}
 2779              		.cfi_endproc
 2780              	.LFE1746:
 2782              		.section	.text.MCI_GetMecSpeedRef_F,"ax",%progbits
 2783              		.align	1
 2784              		.weak	MCI_GetMecSpeedRef_F
 2785              		.syntax unified
 2786              		.thumb
 2787              		.thumb_func
 2788              		.fpu fpv4-sp-d16
 2790              	MCI_GetMecSpeedRef_F:
 2791              	.LFB1747:
1230:Src/mc_interface.c **** 
1231:Src/mc_interface.c **** /**
1232:Src/mc_interface.c ****   * @brief  Returns the current mechanical rotor speed reference expressed in rpm.
1233:Src/mc_interface.c ****   *
1234:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1235:Src/mc_interface.c ****   *
1236:Src/mc_interface.c ****   */
1237:Src/mc_interface.c **** __weak float_t MCI_GetMecSpeedRef_F(MCI_Handle_t *pHandle)
1238:Src/mc_interface.c **** {
 2792              		.loc 6 1238 1
 2793              		.cfi_startproc
 2794              		@ args = 0, pretend = 0, frame = 8
 2795              		@ frame_needed = 1, uses_anonymous_args = 0
 2796 0000 80B5     		push	{r7, lr}
 2797              	.LCFI233:
 2798              		.cfi_def_cfa_offset 8
 2799              		.cfi_offset 7, -8
 2800              		.cfi_offset 14, -4
 2801 0002 82B0     		sub	sp, sp, #8
 2802              	.LCFI234:
 2803              		.cfi_def_cfa_offset 16
 2804 0004 00AF     		add	r7, sp, #0
 2805              	.LCFI235:
 2806              		.cfi_def_cfa_register 7
 2807 0006 7860     		str	r0, [r7, #4]
1239:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
ARM GAS  /tmp/cc9hWwcq.s 			page 101


1240:Src/mc_interface.c ****   return ((MC_NULL == pHandle) ? 0.0f :
1241:Src/mc_interface.c ****           (((float_t)STC_GetMecSpeedRefUnit(pHandle->pSTC) * (float_t)U_RPM) / (float_t)SPEED_UNIT)
1242:Src/mc_interface.c **** #else
1243:Src/mc_interface.c ****   return ((((float_t)STC_GetMecSpeedRefUnit(pHandle->pSTC) * (float_t)U_RPM) / (float_t)SPEED_UNIT)
 2808              		.loc 6 1243 22
 2809 0008 7B68     		ldr	r3, [r7, #4]
 2810 000a 1B68     		ldr	r3, [r3]
 2811 000c 1846     		mov	r0, r3
 2812 000e FFF7FEFF 		bl	STC_GetMecSpeedRefUnit
 2813 0012 0346     		mov	r3, r0
 2814 0014 07EE903A 		vmov	s15, r3	@ int
 2815              		.loc 6 1243 13
 2816 0018 F8EEE77A 		vcvt.f32.s32	s15, s15
 2817              		.loc 6 1243 60
 2818 001c 9FED077A 		vldr.32	s14, .L128
 2819 0020 67EE877A 		vmul.f32	s15, s15, s14
 2820              		.loc 6 1243 78
 2821 0024 B2EE047A 		vmov.f32	s14, #1.0e+1
 2822 0028 C7EE876A 		vdiv.f32	s13, s15, s14
 2823 002c F0EE667A 		vmov.f32	s15, s13
1244:Src/mc_interface.c **** #endif
1245:Src/mc_interface.c **** }
 2824              		.loc 6 1245 1
 2825 0030 B0EE670A 		vmov.f32	s0, s15
 2826 0034 0837     		adds	r7, r7, #8
 2827              	.LCFI236:
 2828              		.cfi_def_cfa_offset 8
 2829 0036 BD46     		mov	sp, r7
 2830              	.LCFI237:
 2831              		.cfi_def_cfa_register 13
 2832              		@ sp needed
 2833 0038 80BD     		pop	{r7, pc}
 2834              	.L129:
 2835 003a 00BF     		.align	2
 2836              	.L128:
 2837 003c 00007042 		.word	1114636288
 2838              		.cfi_endproc
 2839              	.LFE1747:
 2841              		.section	.text.MCI_GetIab,"ax",%progbits
 2842              		.align	1
 2843              		.weak	MCI_GetIab
 2844              		.syntax unified
 2845              		.thumb
 2846              		.thumb_func
 2847              		.fpu fpv4-sp-d16
 2849              	MCI_GetIab:
 2850              	.LFB1748:
1246:Src/mc_interface.c **** 
1247:Src/mc_interface.c **** /**
1248:Src/mc_interface.c ****   * @brief  It returns stator current Iab in ab_t format
1249:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1250:Src/mc_interface.c ****   * @retval ab_t Stator current Iab
1251:Src/mc_interface.c ****   */
1252:Src/mc_interface.c **** __weak ab_t MCI_GetIab(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1253:Src/mc_interface.c **** {
 2851              		.loc 6 1253 1
 2852              		.cfi_startproc
ARM GAS  /tmp/cc9hWwcq.s 			page 102


 2853              		@ args = 0, pretend = 0, frame = 16
 2854              		@ frame_needed = 1, uses_anonymous_args = 0
 2855              		@ link register save eliminated.
 2856 0000 80B4     		push	{r7}
 2857              	.LCFI238:
 2858              		.cfi_def_cfa_offset 4
 2859              		.cfi_offset 7, -4
 2860 0002 85B0     		sub	sp, sp, #20
 2861              	.LCFI239:
 2862              		.cfi_def_cfa_offset 24
 2863 0004 00AF     		add	r7, sp, #0
 2864              	.LCFI240:
 2865              		.cfi_def_cfa_register 7
 2866 0006 7860     		str	r0, [r7, #4]
1254:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1255:Src/mc_interface.c ****   ab_t tempVal;
1256:Src/mc_interface.c **** 
1257:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1258:Src/mc_interface.c ****   {
1259:Src/mc_interface.c ****     tempVal.a = 0;
1260:Src/mc_interface.c ****     tempVal.b = 0;
1261:Src/mc_interface.c ****   }
1262:Src/mc_interface.c ****   else
1263:Src/mc_interface.c ****   {
1264:Src/mc_interface.c ****     tempVal = pHandle->pFOCVars->Iab;
1265:Src/mc_interface.c ****   }
1266:Src/mc_interface.c ****   return (tempVal);
1267:Src/mc_interface.c **** #else
1268:Src/mc_interface.c ****   return (pHandle->pFOCVars->Iab);
 2867              		.loc 6 1268 18
 2868 0008 7B68     		ldr	r3, [r7, #4]
 2869 000a 5A68     		ldr	r2, [r3, #4]
 2870              		.loc 6 1268 28
 2871 000c 07F10C03 		add	r3, r7, #12
 2872 0010 1068     		ldr	r0, [r2]	@ unaligned
 2873 0012 1860     		str	r0, [r3]
 2874 0014 0023     		movs	r3, #0
 2875 0016 BA89     		ldrh	r2, [r7, #12]
 2876 0018 62F30F03 		bfi	r3, r2, #0, #16
 2877 001c FA89     		ldrh	r2, [r7, #14]
 2878 001e 62F31F43 		bfi	r3, r2, #16, #16
1269:Src/mc_interface.c **** #endif
1270:Src/mc_interface.c **** }
 2879              		.loc 6 1270 1
 2880 0022 1846     		mov	r0, r3
 2881 0024 1437     		adds	r7, r7, #20
 2882              	.LCFI241:
 2883              		.cfi_def_cfa_offset 4
 2884 0026 BD46     		mov	sp, r7
 2885              	.LCFI242:
 2886              		.cfi_def_cfa_register 13
 2887              		@ sp needed
 2888 0028 5DF8047B 		ldr	r7, [sp], #4
 2889              	.LCFI243:
 2890              		.cfi_restore 7
 2891              		.cfi_def_cfa_offset 0
 2892 002c 7047     		bx	lr
ARM GAS  /tmp/cc9hWwcq.s 			page 103


 2893              		.cfi_endproc
 2894              	.LFE1748:
 2896              		.section	.text.MCI_GetIab_F,"ax",%progbits
 2897              		.align	1
 2898              		.weak	MCI_GetIab_F
 2899              		.syntax unified
 2900              		.thumb
 2901              		.thumb_func
 2902              		.fpu fpv4-sp-d16
 2904              	MCI_GetIab_F:
 2905              	.LFB1749:
1271:Src/mc_interface.c **** 
1272:Src/mc_interface.c **** __weak ab_f_t MCI_GetIab_F(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1273:Src/mc_interface.c **** {
 2906              		.loc 6 1273 1
 2907              		.cfi_startproc
 2908              		@ args = 0, pretend = 0, frame = 32
 2909              		@ frame_needed = 1, uses_anonymous_args = 0
 2910              		@ link register save eliminated.
 2911 0000 80B4     		push	{r7}
 2912              	.LCFI244:
 2913              		.cfi_def_cfa_offset 4
 2914              		.cfi_offset 7, -4
 2915 0002 89B0     		sub	sp, sp, #36
 2916              	.LCFI245:
 2917              		.cfi_def_cfa_offset 40
 2918 0004 00AF     		add	r7, sp, #0
 2919              	.LCFI246:
 2920              		.cfi_def_cfa_register 7
 2921 0006 F860     		str	r0, [r7, #12]
1274:Src/mc_interface.c **** 
1275:Src/mc_interface.c ****   ab_f_t iab;
1276:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1277:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1278:Src/mc_interface.c ****   {
1279:Src/mc_interface.c ****     iab.a = 0.0f;
1280:Src/mc_interface.c ****     iab.b = 0.0f;
1281:Src/mc_interface.c ****   }
1282:Src/mc_interface.c ****   else
1283:Src/mc_interface.c ****   {
1284:Src/mc_interface.c **** #endif
1285:Src/mc_interface.c ****     iab.a = (float_t)((float_t)pHandle->pFOCVars->Iab.a * pHandle->pScale->current);
 2922              		.loc 6 1285 39
 2923 0008 FB68     		ldr	r3, [r7, #12]
 2924 000a 5B68     		ldr	r3, [r3, #4]
 2925              		.loc 6 1285 54
 2926 000c B3F90030 		ldrsh	r3, [r3]
 2927              		.loc 6 1285 23
 2928 0010 07EE903A 		vmov	s15, r3	@ int
 2929 0014 F8EEE77A 		vcvt.f32.s32	s15, s15
 2930              		.loc 6 1285 66
 2931 0018 FB68     		ldr	r3, [r7, #12]
 2932 001a 9B69     		ldr	r3, [r3, #24]
 2933              		.loc 6 1285 74
 2934 001c 5B68     		ldr	r3, [r3, #4]	@ unaligned
 2935              		.loc 6 1285 13
 2936 001e 07EE103A 		vmov	s14, r3
ARM GAS  /tmp/cc9hWwcq.s 			page 104


 2937 0022 67EE877A 		vmul.f32	s15, s15, s14
 2938              		.loc 6 1285 11
 2939 0026 C7ED047A 		vstr.32	s15, [r7, #16]
1286:Src/mc_interface.c ****     iab.b = (float_t)((float_t)pHandle->pFOCVars->Iab.b * pHandle->pScale->current);
 2940              		.loc 6 1286 39
 2941 002a FB68     		ldr	r3, [r7, #12]
 2942 002c 5B68     		ldr	r3, [r3, #4]
 2943              		.loc 6 1286 54
 2944 002e B3F90230 		ldrsh	r3, [r3, #2]
 2945              		.loc 6 1286 23
 2946 0032 07EE903A 		vmov	s15, r3	@ int
 2947 0036 F8EEE77A 		vcvt.f32.s32	s15, s15
 2948              		.loc 6 1286 66
 2949 003a FB68     		ldr	r3, [r7, #12]
 2950 003c 9B69     		ldr	r3, [r3, #24]
 2951              		.loc 6 1286 74
 2952 003e 5B68     		ldr	r3, [r3, #4]	@ unaligned
 2953              		.loc 6 1286 13
 2954 0040 07EE103A 		vmov	s14, r3
 2955 0044 67EE877A 		vmul.f32	s15, s15, s14
 2956              		.loc 6 1286 11
 2957 0048 C7ED057A 		vstr.32	s15, [r7, #20]
1287:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1288:Src/mc_interface.c ****   }
1289:Src/mc_interface.c **** #endif
1290:Src/mc_interface.c ****   return (iab);
 2958              		.loc 6 1290 10
 2959 004c 07F11803 		add	r3, r7, #24
 2960 0050 07F11002 		add	r2, r7, #16
 2961 0054 92E80300 		ldm	r2, {r0, r1}
 2962 0058 83E80300 		stm	r3, {r0, r1}
 2963 005c BA69     		ldr	r2, [r7, #24]	@ float
 2964 005e FB69     		ldr	r3, [r7, #28]	@ float
 2965 0060 07EE102A 		vmov	s14, r2
 2966 0064 07EE903A 		vmov	s15, r3
1291:Src/mc_interface.c **** 
1292:Src/mc_interface.c **** }
 2967              		.loc 6 1292 1
 2968 0068 B0EE470A 		vmov.f32	s0, s14
 2969 006c F0EE670A 		vmov.f32	s1, s15
 2970 0070 2437     		adds	r7, r7, #36
 2971              	.LCFI247:
 2972              		.cfi_def_cfa_offset 4
 2973 0072 BD46     		mov	sp, r7
 2974              	.LCFI248:
 2975              		.cfi_def_cfa_register 13
 2976              		@ sp needed
 2977 0074 5DF8047B 		ldr	r7, [sp], #4
 2978              	.LCFI249:
 2979              		.cfi_restore 7
 2980              		.cfi_def_cfa_offset 0
 2981 0078 7047     		bx	lr
 2982              		.cfi_endproc
 2983              	.LFE1749:
 2985              		.section	.text.MCI_GetIalphabeta,"ax",%progbits
 2986              		.align	1
 2987              		.weak	MCI_GetIalphabeta
ARM GAS  /tmp/cc9hWwcq.s 			page 105


 2988              		.syntax unified
 2989              		.thumb
 2990              		.thumb_func
 2991              		.fpu fpv4-sp-d16
 2993              	MCI_GetIalphabeta:
 2994              	.LFB1750:
1293:Src/mc_interface.c **** 
1294:Src/mc_interface.c **** /**
1295:Src/mc_interface.c ****   * @brief  It returns stator current Ialphabeta in alphabeta_t format
1296:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1297:Src/mc_interface.c ****   * @retval alphabeta_t Stator current Ialphabeta
1298:Src/mc_interface.c ****   */
1299:Src/mc_interface.c **** __weak alphabeta_t MCI_GetIalphabeta(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1300:Src/mc_interface.c **** {
 2995              		.loc 6 1300 1
 2996              		.cfi_startproc
 2997              		@ args = 0, pretend = 0, frame = 16
 2998              		@ frame_needed = 1, uses_anonymous_args = 0
 2999              		@ link register save eliminated.
 3000 0000 80B4     		push	{r7}
 3001              	.LCFI250:
 3002              		.cfi_def_cfa_offset 4
 3003              		.cfi_offset 7, -4
 3004 0002 85B0     		sub	sp, sp, #20
 3005              	.LCFI251:
 3006              		.cfi_def_cfa_offset 24
 3007 0004 00AF     		add	r7, sp, #0
 3008              	.LCFI252:
 3009              		.cfi_def_cfa_register 7
 3010 0006 7860     		str	r0, [r7, #4]
1301:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1302:Src/mc_interface.c ****   alphabeta_t tempVal;
1303:Src/mc_interface.c **** 
1304:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1305:Src/mc_interface.c ****   {
1306:Src/mc_interface.c ****     tempVal.alpha = 0;
1307:Src/mc_interface.c ****     tempVal.beta = 0;
1308:Src/mc_interface.c ****   }
1309:Src/mc_interface.c ****   else
1310:Src/mc_interface.c ****   {
1311:Src/mc_interface.c ****     tempVal = pHandle->pFOCVars->Ialphabeta;
1312:Src/mc_interface.c ****   }
1313:Src/mc_interface.c ****   return (tempVal);
1314:Src/mc_interface.c **** #else
1315:Src/mc_interface.c ****   return (pHandle->pFOCVars->Ialphabeta);
 3011              		.loc 6 1315 18
 3012 0008 7B68     		ldr	r3, [r7, #4]
 3013 000a 5A68     		ldr	r2, [r3, #4]
 3014              		.loc 6 1315 28
 3015 000c 07F10C03 		add	r3, r7, #12
 3016 0010 0432     		adds	r2, r2, #4
 3017 0012 1068     		ldr	r0, [r2]	@ unaligned
 3018 0014 1860     		str	r0, [r3]
 3019 0016 0023     		movs	r3, #0
 3020 0018 BA89     		ldrh	r2, [r7, #12]
 3021 001a 62F30F03 		bfi	r3, r2, #0, #16
 3022 001e FA89     		ldrh	r2, [r7, #14]
ARM GAS  /tmp/cc9hWwcq.s 			page 106


 3023 0020 62F31F43 		bfi	r3, r2, #16, #16
1316:Src/mc_interface.c **** #endif
1317:Src/mc_interface.c **** }
 3024              		.loc 6 1317 1
 3025 0024 1846     		mov	r0, r3
 3026 0026 1437     		adds	r7, r7, #20
 3027              	.LCFI253:
 3028              		.cfi_def_cfa_offset 4
 3029 0028 BD46     		mov	sp, r7
 3030              	.LCFI254:
 3031              		.cfi_def_cfa_register 13
 3032              		@ sp needed
 3033 002a 5DF8047B 		ldr	r7, [sp], #4
 3034              	.LCFI255:
 3035              		.cfi_restore 7
 3036              		.cfi_def_cfa_offset 0
 3037 002e 7047     		bx	lr
 3038              		.cfi_endproc
 3039              	.LFE1750:
 3041              		.section	.text.MCI_GetIqd,"ax",%progbits
 3042              		.align	1
 3043              		.weak	MCI_GetIqd
 3044              		.syntax unified
 3045              		.thumb
 3046              		.thumb_func
 3047              		.fpu fpv4-sp-d16
 3049              	MCI_GetIqd:
 3050              	.LFB1751:
1318:Src/mc_interface.c **** 
1319:Src/mc_interface.c **** /**
1320:Src/mc_interface.c ****   * @brief  It returns stator current Iqd in qd_t format
1321:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1322:Src/mc_interface.c ****   * @retval qd_t Stator current Iqd
1323:Src/mc_interface.c ****   */
1324:Src/mc_interface.c **** __weak qd_t MCI_GetIqd(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1325:Src/mc_interface.c **** {
 3051              		.loc 6 1325 1
 3052              		.cfi_startproc
 3053              		@ args = 0, pretend = 0, frame = 16
 3054              		@ frame_needed = 1, uses_anonymous_args = 0
 3055              		@ link register save eliminated.
 3056 0000 80B4     		push	{r7}
 3057              	.LCFI256:
 3058              		.cfi_def_cfa_offset 4
 3059              		.cfi_offset 7, -4
 3060 0002 85B0     		sub	sp, sp, #20
 3061              	.LCFI257:
 3062              		.cfi_def_cfa_offset 24
 3063 0004 00AF     		add	r7, sp, #0
 3064              	.LCFI258:
 3065              		.cfi_def_cfa_register 7
 3066 0006 7860     		str	r0, [r7, #4]
1326:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1327:Src/mc_interface.c ****   qd_t tempVal;
1328:Src/mc_interface.c **** 
1329:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1330:Src/mc_interface.c ****   {
ARM GAS  /tmp/cc9hWwcq.s 			page 107


1331:Src/mc_interface.c ****     tempVal.q = 0;
1332:Src/mc_interface.c ****     tempVal.d = 0;
1333:Src/mc_interface.c ****   }
1334:Src/mc_interface.c ****   else
1335:Src/mc_interface.c ****   {
1336:Src/mc_interface.c ****     tempVal = pHandle->pFOCVars->Iqd;
1337:Src/mc_interface.c ****   }
1338:Src/mc_interface.c ****   return (tempVal);
1339:Src/mc_interface.c **** #else
1340:Src/mc_interface.c ****   return (pHandle->pFOCVars->Iqd);
 3067              		.loc 6 1340 18
 3068 0008 7B68     		ldr	r3, [r7, #4]
 3069 000a 5A68     		ldr	r2, [r3, #4]
 3070              		.loc 6 1340 28
 3071 000c 07F10C03 		add	r3, r7, #12
 3072 0010 0C32     		adds	r2, r2, #12
 3073 0012 1068     		ldr	r0, [r2]	@ unaligned
 3074 0014 1860     		str	r0, [r3]
 3075 0016 0023     		movs	r3, #0
 3076 0018 BA89     		ldrh	r2, [r7, #12]
 3077 001a 62F30F03 		bfi	r3, r2, #0, #16
 3078 001e FA89     		ldrh	r2, [r7, #14]
 3079 0020 62F31F43 		bfi	r3, r2, #16, #16
1341:Src/mc_interface.c **** #endif
1342:Src/mc_interface.c **** }
 3080              		.loc 6 1342 1
 3081 0024 1846     		mov	r0, r3
 3082 0026 1437     		adds	r7, r7, #20
 3083              	.LCFI259:
 3084              		.cfi_def_cfa_offset 4
 3085 0028 BD46     		mov	sp, r7
 3086              	.LCFI260:
 3087              		.cfi_def_cfa_register 13
 3088              		@ sp needed
 3089 002a 5DF8047B 		ldr	r7, [sp], #4
 3090              	.LCFI261:
 3091              		.cfi_restore 7
 3092              		.cfi_def_cfa_offset 0
 3093 002e 7047     		bx	lr
 3094              		.cfi_endproc
 3095              	.LFE1751:
 3097              		.section	.text.MCI_GetIqd_F,"ax",%progbits
 3098              		.align	1
 3099              		.weak	MCI_GetIqd_F
 3100              		.syntax unified
 3101              		.thumb
 3102              		.thumb_func
 3103              		.fpu fpv4-sp-d16
 3105              	MCI_GetIqd_F:
 3106              	.LFB1752:
1343:Src/mc_interface.c **** 
1344:Src/mc_interface.c **** /**
1345:Src/mc_interface.c ****   * @brief  It returns stator current Iqd in float_t format
1346:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1347:Src/mc_interface.c ****   * @retval qd_f_t Stator current Iqd (in Ampere)
1348:Src/mc_interface.c ****   */
1349:Src/mc_interface.c **** __weak qd_f_t MCI_GetIqd_F(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
ARM GAS  /tmp/cc9hWwcq.s 			page 108


1350:Src/mc_interface.c **** {
 3107              		.loc 6 1350 1
 3108              		.cfi_startproc
 3109              		@ args = 0, pretend = 0, frame = 32
 3110              		@ frame_needed = 1, uses_anonymous_args = 0
 3111              		@ link register save eliminated.
 3112 0000 80B4     		push	{r7}
 3113              	.LCFI262:
 3114              		.cfi_def_cfa_offset 4
 3115              		.cfi_offset 7, -4
 3116 0002 89B0     		sub	sp, sp, #36
 3117              	.LCFI263:
 3118              		.cfi_def_cfa_offset 40
 3119 0004 00AF     		add	r7, sp, #0
 3120              	.LCFI264:
 3121              		.cfi_def_cfa_register 7
 3122 0006 F860     		str	r0, [r7, #12]
1351:Src/mc_interface.c ****   qd_f_t iqd;
1352:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1353:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1354:Src/mc_interface.c ****   {
1355:Src/mc_interface.c ****     iqd.d = 0.0f;
1356:Src/mc_interface.c ****     iqd.q = 0.0f;
1357:Src/mc_interface.c ****   }
1358:Src/mc_interface.c ****   else
1359:Src/mc_interface.c ****   {
1360:Src/mc_interface.c **** #endif
1361:Src/mc_interface.c ****   iqd.d = (float_t)((float_t)pHandle->pFOCVars->Iqd.d * pHandle->pScale->current);
 3123              		.loc 6 1361 37
 3124 0008 FB68     		ldr	r3, [r7, #12]
 3125 000a 5B68     		ldr	r3, [r3, #4]
 3126              		.loc 6 1361 52
 3127 000c B3F90E30 		ldrsh	r3, [r3, #14]
 3128              		.loc 6 1361 21
 3129 0010 07EE903A 		vmov	s15, r3	@ int
 3130 0014 F8EEE77A 		vcvt.f32.s32	s15, s15
 3131              		.loc 6 1361 64
 3132 0018 FB68     		ldr	r3, [r7, #12]
 3133 001a 9B69     		ldr	r3, [r3, #24]
 3134              		.loc 6 1361 72
 3135 001c 5B68     		ldr	r3, [r3, #4]	@ unaligned
 3136              		.loc 6 1361 11
 3137 001e 07EE103A 		vmov	s14, r3
 3138 0022 67EE877A 		vmul.f32	s15, s15, s14
 3139              		.loc 6 1361 9
 3140 0026 C7ED057A 		vstr.32	s15, [r7, #20]
1362:Src/mc_interface.c ****   iqd.q = (float_t)((float_t)pHandle->pFOCVars->Iqd.q * pHandle->pScale->current);
 3141              		.loc 6 1362 37
 3142 002a FB68     		ldr	r3, [r7, #12]
 3143 002c 5B68     		ldr	r3, [r3, #4]
 3144              		.loc 6 1362 52
 3145 002e B3F90C30 		ldrsh	r3, [r3, #12]
 3146              		.loc 6 1362 21
 3147 0032 07EE903A 		vmov	s15, r3	@ int
 3148 0036 F8EEE77A 		vcvt.f32.s32	s15, s15
 3149              		.loc 6 1362 64
 3150 003a FB68     		ldr	r3, [r7, #12]
ARM GAS  /tmp/cc9hWwcq.s 			page 109


 3151 003c 9B69     		ldr	r3, [r3, #24]
 3152              		.loc 6 1362 72
 3153 003e 5B68     		ldr	r3, [r3, #4]	@ unaligned
 3154              		.loc 6 1362 11
 3155 0040 07EE103A 		vmov	s14, r3
 3156 0044 67EE877A 		vmul.f32	s15, s15, s14
 3157              		.loc 6 1362 9
 3158 0048 C7ED047A 		vstr.32	s15, [r7, #16]
1363:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1364:Src/mc_interface.c ****   }
1365:Src/mc_interface.c **** #endif
1366:Src/mc_interface.c ****   return (iqd);
 3159              		.loc 6 1366 10
 3160 004c 07F11803 		add	r3, r7, #24
 3161 0050 07F11002 		add	r2, r7, #16
 3162 0054 92E80300 		ldm	r2, {r0, r1}
 3163 0058 83E80300 		stm	r3, {r0, r1}
 3164 005c BA69     		ldr	r2, [r7, #24]	@ float
 3165 005e FB69     		ldr	r3, [r7, #28]	@ float
 3166 0060 07EE102A 		vmov	s14, r2
 3167 0064 07EE903A 		vmov	s15, r3
1367:Src/mc_interface.c **** }
 3168              		.loc 6 1367 1
 3169 0068 B0EE470A 		vmov.f32	s0, s14
 3170 006c F0EE670A 		vmov.f32	s1, s15
 3171 0070 2437     		adds	r7, r7, #36
 3172              	.LCFI265:
 3173              		.cfi_def_cfa_offset 4
 3174 0072 BD46     		mov	sp, r7
 3175              	.LCFI266:
 3176              		.cfi_def_cfa_register 13
 3177              		@ sp needed
 3178 0074 5DF8047B 		ldr	r7, [sp], #4
 3179              	.LCFI267:
 3180              		.cfi_restore 7
 3181              		.cfi_def_cfa_offset 0
 3182 0078 7047     		bx	lr
 3183              		.cfi_endproc
 3184              	.LFE1752:
 3186              		.section	.text.MCI_GetIqdHF,"ax",%progbits
 3187              		.align	1
 3188              		.weak	MCI_GetIqdHF
 3189              		.syntax unified
 3190              		.thumb
 3191              		.thumb_func
 3192              		.fpu fpv4-sp-d16
 3194              	MCI_GetIqdHF:
 3195              	.LFB1753:
1368:Src/mc_interface.c **** 
1369:Src/mc_interface.c **** /**
1370:Src/mc_interface.c ****   * @brief  It returns stator current IqdHF in qd_t format
1371:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1372:Src/mc_interface.c ****   * @retval qd_t Stator current IqdHF if HFI is selected as main
1373:Src/mc_interface.c ****   *         sensor. Otherwise it returns { 0, 0}.
1374:Src/mc_interface.c ****   */
1375:Src/mc_interface.c **** __weak qd_t MCI_GetIqdHF(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1376:Src/mc_interface.c **** {
ARM GAS  /tmp/cc9hWwcq.s 			page 110


 3196              		.loc 6 1376 1
 3197              		.cfi_startproc
 3198              		@ args = 0, pretend = 0, frame = 16
 3199              		@ frame_needed = 1, uses_anonymous_args = 0
 3200              		@ link register save eliminated.
 3201 0000 80B4     		push	{r7}
 3202              	.LCFI268:
 3203              		.cfi_def_cfa_offset 4
 3204              		.cfi_offset 7, -4
 3205 0002 85B0     		sub	sp, sp, #20
 3206              	.LCFI269:
 3207              		.cfi_def_cfa_offset 24
 3208 0004 00AF     		add	r7, sp, #0
 3209              	.LCFI270:
 3210              		.cfi_def_cfa_register 7
 3211 0006 7860     		str	r0, [r7, #4]
1377:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1378:Src/mc_interface.c ****   qd_t tempVal;
1379:Src/mc_interface.c **** 
1380:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1381:Src/mc_interface.c ****   {
1382:Src/mc_interface.c ****     tempVal.q = 0;
1383:Src/mc_interface.c ****     tempVal.d = 0;
1384:Src/mc_interface.c ****   }
1385:Src/mc_interface.c ****   else
1386:Src/mc_interface.c ****   {
1387:Src/mc_interface.c ****     tempVal = pHandle->pFOCVars->IqdHF;
1388:Src/mc_interface.c ****   }
1389:Src/mc_interface.c ****   return (tempVal);
1390:Src/mc_interface.c **** #else
1391:Src/mc_interface.c ****   return (pHandle->pFOCVars->IqdHF);
 3212              		.loc 6 1391 18
 3213 0008 7B68     		ldr	r3, [r7, #4]
 3214 000a 5A68     		ldr	r2, [r3, #4]
 3215              		.loc 6 1391 28
 3216 000c 07F10C03 		add	r3, r7, #12
 3217 0010 0832     		adds	r2, r2, #8
 3218 0012 1068     		ldr	r0, [r2]	@ unaligned
 3219 0014 1860     		str	r0, [r3]
 3220 0016 0023     		movs	r3, #0
 3221 0018 BA89     		ldrh	r2, [r7, #12]
 3222 001a 62F30F03 		bfi	r3, r2, #0, #16
 3223 001e FA89     		ldrh	r2, [r7, #14]
 3224 0020 62F31F43 		bfi	r3, r2, #16, #16
1392:Src/mc_interface.c **** #endif
1393:Src/mc_interface.c **** }
 3225              		.loc 6 1393 1
 3226 0024 1846     		mov	r0, r3
 3227 0026 1437     		adds	r7, r7, #20
 3228              	.LCFI271:
 3229              		.cfi_def_cfa_offset 4
 3230 0028 BD46     		mov	sp, r7
 3231              	.LCFI272:
 3232              		.cfi_def_cfa_register 13
 3233              		@ sp needed
 3234 002a 5DF8047B 		ldr	r7, [sp], #4
 3235              	.LCFI273:
ARM GAS  /tmp/cc9hWwcq.s 			page 111


 3236              		.cfi_restore 7
 3237              		.cfi_def_cfa_offset 0
 3238 002e 7047     		bx	lr
 3239              		.cfi_endproc
 3240              	.LFE1753:
 3242              		.section	.text.MCI_GetIqdref,"ax",%progbits
 3243              		.align	1
 3244              		.weak	MCI_GetIqdref
 3245              		.syntax unified
 3246              		.thumb
 3247              		.thumb_func
 3248              		.fpu fpv4-sp-d16
 3250              	MCI_GetIqdref:
 3251              	.LFB1754:
1394:Src/mc_interface.c **** 
1395:Src/mc_interface.c **** /**
1396:Src/mc_interface.c ****   * @brief  It returns stator current Iqdref in qd_t format
1397:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1398:Src/mc_interface.c ****   * @retval qd_t Stator current Iqdref
1399:Src/mc_interface.c ****   */
1400:Src/mc_interface.c **** __weak qd_t MCI_GetIqdref(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1401:Src/mc_interface.c **** {
 3252              		.loc 6 1401 1
 3253              		.cfi_startproc
 3254              		@ args = 0, pretend = 0, frame = 16
 3255              		@ frame_needed = 1, uses_anonymous_args = 0
 3256              		@ link register save eliminated.
 3257 0000 80B4     		push	{r7}
 3258              	.LCFI274:
 3259              		.cfi_def_cfa_offset 4
 3260              		.cfi_offset 7, -4
 3261 0002 85B0     		sub	sp, sp, #20
 3262              	.LCFI275:
 3263              		.cfi_def_cfa_offset 24
 3264 0004 00AF     		add	r7, sp, #0
 3265              	.LCFI276:
 3266              		.cfi_def_cfa_register 7
 3267 0006 7860     		str	r0, [r7, #4]
1402:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1403:Src/mc_interface.c ****   qd_t tempVal;
1404:Src/mc_interface.c **** 
1405:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1406:Src/mc_interface.c ****   {
1407:Src/mc_interface.c ****     tempVal.q = 0;
1408:Src/mc_interface.c ****     tempVal.d = 0;
1409:Src/mc_interface.c ****   }
1410:Src/mc_interface.c ****   else
1411:Src/mc_interface.c ****   {
1412:Src/mc_interface.c ****     tempVal = pHandle->pFOCVars->Iqdref;
1413:Src/mc_interface.c ****   }
1414:Src/mc_interface.c ****   return (tempVal);
1415:Src/mc_interface.c **** #else
1416:Src/mc_interface.c ****   return (pHandle->pFOCVars->Iqdref);
 3268              		.loc 6 1416 18
 3269 0008 7B68     		ldr	r3, [r7, #4]
 3270 000a 5A68     		ldr	r2, [r3, #4]
 3271              		.loc 6 1416 28
ARM GAS  /tmp/cc9hWwcq.s 			page 112


 3272 000c 07F10C03 		add	r3, r7, #12
 3273 0010 1032     		adds	r2, r2, #16
 3274 0012 1068     		ldr	r0, [r2]	@ unaligned
 3275 0014 1860     		str	r0, [r3]
 3276 0016 0023     		movs	r3, #0
 3277 0018 BA89     		ldrh	r2, [r7, #12]
 3278 001a 62F30F03 		bfi	r3, r2, #0, #16
 3279 001e FA89     		ldrh	r2, [r7, #14]
 3280 0020 62F31F43 		bfi	r3, r2, #16, #16
1417:Src/mc_interface.c **** #endif
1418:Src/mc_interface.c **** }
 3281              		.loc 6 1418 1
 3282 0024 1846     		mov	r0, r3
 3283 0026 1437     		adds	r7, r7, #20
 3284              	.LCFI277:
 3285              		.cfi_def_cfa_offset 4
 3286 0028 BD46     		mov	sp, r7
 3287              	.LCFI278:
 3288              		.cfi_def_cfa_register 13
 3289              		@ sp needed
 3290 002a 5DF8047B 		ldr	r7, [sp], #4
 3291              	.LCFI279:
 3292              		.cfi_restore 7
 3293              		.cfi_def_cfa_offset 0
 3294 002e 7047     		bx	lr
 3295              		.cfi_endproc
 3296              	.LFE1754:
 3298              		.section	.text.MCI_GetIqdref_F,"ax",%progbits
 3299              		.align	1
 3300              		.weak	MCI_GetIqdref_F
 3301              		.syntax unified
 3302              		.thumb
 3303              		.thumb_func
 3304              		.fpu fpv4-sp-d16
 3306              	MCI_GetIqdref_F:
 3307              	.LFB1755:
1419:Src/mc_interface.c **** 
1420:Src/mc_interface.c **** /**
1421:Src/mc_interface.c ****   * @brief  It returns stator current Iqdref in float_t format
1422:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1423:Src/mc_interface.c ****   * @retval qd_f_t Stator current Iqdref (in Ampere)
1424:Src/mc_interface.c ****   */
1425:Src/mc_interface.c **** __weak qd_f_t MCI_GetIqdref_F(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1426:Src/mc_interface.c **** {
 3308              		.loc 6 1426 1
 3309              		.cfi_startproc
 3310              		@ args = 0, pretend = 0, frame = 32
 3311              		@ frame_needed = 1, uses_anonymous_args = 0
 3312              		@ link register save eliminated.
 3313 0000 80B4     		push	{r7}
 3314              	.LCFI280:
 3315              		.cfi_def_cfa_offset 4
 3316              		.cfi_offset 7, -4
 3317 0002 89B0     		sub	sp, sp, #36
 3318              	.LCFI281:
 3319              		.cfi_def_cfa_offset 40
 3320 0004 00AF     		add	r7, sp, #0
ARM GAS  /tmp/cc9hWwcq.s 			page 113


 3321              	.LCFI282:
 3322              		.cfi_def_cfa_register 7
 3323 0006 F860     		str	r0, [r7, #12]
1427:Src/mc_interface.c ****   qd_f_t iqdref;
1428:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1429:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1430:Src/mc_interface.c ****   {
1431:Src/mc_interface.c ****     iqdref.d = 0.0f;
1432:Src/mc_interface.c ****     iqdref.q = 0.0f;
1433:Src/mc_interface.c ****   }
1434:Src/mc_interface.c ****   else
1435:Src/mc_interface.c ****   {
1436:Src/mc_interface.c **** #endif
1437:Src/mc_interface.c ****     iqdref.d = (float_t)((float_t)pHandle->pFOCVars->Iqdref.d * pHandle->pScale->current);
 3324              		.loc 6 1437 42
 3325 0008 FB68     		ldr	r3, [r7, #12]
 3326 000a 5B68     		ldr	r3, [r3, #4]
 3327              		.loc 6 1437 60
 3328 000c B3F91230 		ldrsh	r3, [r3, #18]
 3329              		.loc 6 1437 26
 3330 0010 07EE903A 		vmov	s15, r3	@ int
 3331 0014 F8EEE77A 		vcvt.f32.s32	s15, s15
 3332              		.loc 6 1437 72
 3333 0018 FB68     		ldr	r3, [r7, #12]
 3334 001a 9B69     		ldr	r3, [r3, #24]
 3335              		.loc 6 1437 80
 3336 001c 5B68     		ldr	r3, [r3, #4]	@ unaligned
 3337              		.loc 6 1437 16
 3338 001e 07EE103A 		vmov	s14, r3
 3339 0022 67EE877A 		vmul.f32	s15, s15, s14
 3340              		.loc 6 1437 14
 3341 0026 C7ED057A 		vstr.32	s15, [r7, #20]
1438:Src/mc_interface.c ****     iqdref.q = (float_t)((float_t)pHandle->pFOCVars->Iqdref.q * pHandle->pScale->current);
 3342              		.loc 6 1438 42
 3343 002a FB68     		ldr	r3, [r7, #12]
 3344 002c 5B68     		ldr	r3, [r3, #4]
 3345              		.loc 6 1438 60
 3346 002e B3F91030 		ldrsh	r3, [r3, #16]
 3347              		.loc 6 1438 26
 3348 0032 07EE903A 		vmov	s15, r3	@ int
 3349 0036 F8EEE77A 		vcvt.f32.s32	s15, s15
 3350              		.loc 6 1438 72
 3351 003a FB68     		ldr	r3, [r7, #12]
 3352 003c 9B69     		ldr	r3, [r3, #24]
 3353              		.loc 6 1438 80
 3354 003e 5B68     		ldr	r3, [r3, #4]	@ unaligned
 3355              		.loc 6 1438 16
 3356 0040 07EE103A 		vmov	s14, r3
 3357 0044 67EE877A 		vmul.f32	s15, s15, s14
 3358              		.loc 6 1438 14
 3359 0048 C7ED047A 		vstr.32	s15, [r7, #16]
1439:Src/mc_interface.c ****  #ifdef NULL_PTR_CHECK_MC_INT
1440:Src/mc_interface.c ****   }
1441:Src/mc_interface.c **** #endif
1442:Src/mc_interface.c ****   return (iqdref);
 3360              		.loc 6 1442 10
 3361 004c 07F11803 		add	r3, r7, #24
ARM GAS  /tmp/cc9hWwcq.s 			page 114


 3362 0050 07F11002 		add	r2, r7, #16
 3363 0054 92E80300 		ldm	r2, {r0, r1}
 3364 0058 83E80300 		stm	r3, {r0, r1}
 3365 005c BA69     		ldr	r2, [r7, #24]	@ float
 3366 005e FB69     		ldr	r3, [r7, #28]	@ float
 3367 0060 07EE102A 		vmov	s14, r2
 3368 0064 07EE903A 		vmov	s15, r3
1443:Src/mc_interface.c **** }
 3369              		.loc 6 1443 1
 3370 0068 B0EE470A 		vmov.f32	s0, s14
 3371 006c F0EE670A 		vmov.f32	s1, s15
 3372 0070 2437     		adds	r7, r7, #36
 3373              	.LCFI283:
 3374              		.cfi_def_cfa_offset 4
 3375 0072 BD46     		mov	sp, r7
 3376              	.LCFI284:
 3377              		.cfi_def_cfa_register 13
 3378              		@ sp needed
 3379 0074 5DF8047B 		ldr	r7, [sp], #4
 3380              	.LCFI285:
 3381              		.cfi_restore 7
 3382              		.cfi_def_cfa_offset 0
 3383 0078 7047     		bx	lr
 3384              		.cfi_endproc
 3385              	.LFE1755:
 3387              		.section	.text.MCI_GetVqd,"ax",%progbits
 3388              		.align	1
 3389              		.weak	MCI_GetVqd
 3390              		.syntax unified
 3391              		.thumb
 3392              		.thumb_func
 3393              		.fpu fpv4-sp-d16
 3395              	MCI_GetVqd:
 3396              	.LFB1756:
1444:Src/mc_interface.c **** 
1445:Src/mc_interface.c **** /**
1446:Src/mc_interface.c ****   * @brief  It returns stator current Vqd in qd_t format
1447:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1448:Src/mc_interface.c ****   * @retval qd_t Stator current Vqd
1449:Src/mc_interface.c ****   */
1450:Src/mc_interface.c **** __weak qd_t MCI_GetVqd(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1451:Src/mc_interface.c **** {
 3397              		.loc 6 1451 1
 3398              		.cfi_startproc
 3399              		@ args = 0, pretend = 0, frame = 16
 3400              		@ frame_needed = 1, uses_anonymous_args = 0
 3401              		@ link register save eliminated.
 3402 0000 80B4     		push	{r7}
 3403              	.LCFI286:
 3404              		.cfi_def_cfa_offset 4
 3405              		.cfi_offset 7, -4
 3406 0002 85B0     		sub	sp, sp, #20
 3407              	.LCFI287:
 3408              		.cfi_def_cfa_offset 24
 3409 0004 00AF     		add	r7, sp, #0
 3410              	.LCFI288:
 3411              		.cfi_def_cfa_register 7
ARM GAS  /tmp/cc9hWwcq.s 			page 115


 3412 0006 7860     		str	r0, [r7, #4]
1452:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1453:Src/mc_interface.c ****   qd_t tempVal;
1454:Src/mc_interface.c **** 
1455:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1456:Src/mc_interface.c ****   {
1457:Src/mc_interface.c ****     tempVal.q = 0;
1458:Src/mc_interface.c ****     tempVal.d = 0;
1459:Src/mc_interface.c ****   }
1460:Src/mc_interface.c ****   else
1461:Src/mc_interface.c ****   {
1462:Src/mc_interface.c ****     tempVal = pHandle->pFOCVars->Vqd;
1463:Src/mc_interface.c ****   }
1464:Src/mc_interface.c ****   return (tempVal);
1465:Src/mc_interface.c **** #else
1466:Src/mc_interface.c ****   return (pHandle->pFOCVars->Vqd);
 3413              		.loc 6 1466 18
 3414 0008 7B68     		ldr	r3, [r7, #4]
 3415 000a 5A68     		ldr	r2, [r3, #4]
 3416              		.loc 6 1466 28
 3417 000c 07F10C03 		add	r3, r7, #12
 3418 0010 1632     		adds	r2, r2, #22
 3419 0012 1068     		ldr	r0, [r2]	@ unaligned
 3420 0014 1860     		str	r0, [r3]
 3421 0016 0023     		movs	r3, #0
 3422 0018 BA89     		ldrh	r2, [r7, #12]
 3423 001a 62F30F03 		bfi	r3, r2, #0, #16
 3424 001e FA89     		ldrh	r2, [r7, #14]
 3425 0020 62F31F43 		bfi	r3, r2, #16, #16
1467:Src/mc_interface.c **** #endif
1468:Src/mc_interface.c **** }
 3426              		.loc 6 1468 1
 3427 0024 1846     		mov	r0, r3
 3428 0026 1437     		adds	r7, r7, #20
 3429              	.LCFI289:
 3430              		.cfi_def_cfa_offset 4
 3431 0028 BD46     		mov	sp, r7
 3432              	.LCFI290:
 3433              		.cfi_def_cfa_register 13
 3434              		@ sp needed
 3435 002a 5DF8047B 		ldr	r7, [sp], #4
 3436              	.LCFI291:
 3437              		.cfi_restore 7
 3438              		.cfi_def_cfa_offset 0
 3439 002e 7047     		bx	lr
 3440              		.cfi_endproc
 3441              	.LFE1756:
 3443              		.section	.text.MCI_GetValphabeta,"ax",%progbits
 3444              		.align	1
 3445              		.weak	MCI_GetValphabeta
 3446              		.syntax unified
 3447              		.thumb
 3448              		.thumb_func
 3449              		.fpu fpv4-sp-d16
 3451              	MCI_GetValphabeta:
 3452              	.LFB1757:
1469:Src/mc_interface.c **** 
ARM GAS  /tmp/cc9hWwcq.s 			page 116


1470:Src/mc_interface.c **** /**
1471:Src/mc_interface.c ****   * @brief  It returns stator current Valphabeta in alphabeta_t format
1472:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1473:Src/mc_interface.c ****   * @retval alphabeta_t Stator current Valphabeta
1474:Src/mc_interface.c ****   */
1475:Src/mc_interface.c **** __weak alphabeta_t MCI_GetValphabeta(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1476:Src/mc_interface.c **** {
 3453              		.loc 6 1476 1
 3454              		.cfi_startproc
 3455              		@ args = 0, pretend = 0, frame = 16
 3456              		@ frame_needed = 1, uses_anonymous_args = 0
 3457              		@ link register save eliminated.
 3458 0000 80B4     		push	{r7}
 3459              	.LCFI292:
 3460              		.cfi_def_cfa_offset 4
 3461              		.cfi_offset 7, -4
 3462 0002 85B0     		sub	sp, sp, #20
 3463              	.LCFI293:
 3464              		.cfi_def_cfa_offset 24
 3465 0004 00AF     		add	r7, sp, #0
 3466              	.LCFI294:
 3467              		.cfi_def_cfa_register 7
 3468 0006 7860     		str	r0, [r7, #4]
1477:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1478:Src/mc_interface.c ****   alphabeta_t tempVal;
1479:Src/mc_interface.c **** 
1480:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1481:Src/mc_interface.c ****   {
1482:Src/mc_interface.c ****     tempVal.alpha = 0;
1483:Src/mc_interface.c ****     tempVal.beta = 0;
1484:Src/mc_interface.c ****   }
1485:Src/mc_interface.c ****   else
1486:Src/mc_interface.c ****   {
1487:Src/mc_interface.c ****     tempVal = pHandle->pFOCVars->Valphabeta;
1488:Src/mc_interface.c ****   }
1489:Src/mc_interface.c ****   return (tempVal);
1490:Src/mc_interface.c **** #else
1491:Src/mc_interface.c ****   return (pHandle->pFOCVars->Valphabeta);
 3469              		.loc 6 1491 18
 3470 0008 7B68     		ldr	r3, [r7, #4]
 3471 000a 5A68     		ldr	r2, [r3, #4]
 3472              		.loc 6 1491 28
 3473 000c 07F10C03 		add	r3, r7, #12
 3474 0010 1A32     		adds	r2, r2, #26
 3475 0012 1068     		ldr	r0, [r2]	@ unaligned
 3476 0014 1860     		str	r0, [r3]
 3477 0016 0023     		movs	r3, #0
 3478 0018 BA89     		ldrh	r2, [r7, #12]
 3479 001a 62F30F03 		bfi	r3, r2, #0, #16
 3480 001e FA89     		ldrh	r2, [r7, #14]
 3481 0020 62F31F43 		bfi	r3, r2, #16, #16
1492:Src/mc_interface.c **** #endif
1493:Src/mc_interface.c **** }
 3482              		.loc 6 1493 1
 3483 0024 1846     		mov	r0, r3
 3484 0026 1437     		adds	r7, r7, #20
 3485              	.LCFI295:
ARM GAS  /tmp/cc9hWwcq.s 			page 117


 3486              		.cfi_def_cfa_offset 4
 3487 0028 BD46     		mov	sp, r7
 3488              	.LCFI296:
 3489              		.cfi_def_cfa_register 13
 3490              		@ sp needed
 3491 002a 5DF8047B 		ldr	r7, [sp], #4
 3492              	.LCFI297:
 3493              		.cfi_restore 7
 3494              		.cfi_def_cfa_offset 0
 3495 002e 7047     		bx	lr
 3496              		.cfi_endproc
 3497              	.LFE1757:
 3499              		.section	.text.MCI_GetElAngledpp,"ax",%progbits
 3500              		.align	1
 3501              		.weak	MCI_GetElAngledpp
 3502              		.syntax unified
 3503              		.thumb
 3504              		.thumb_func
 3505              		.fpu fpv4-sp-d16
 3507              	MCI_GetElAngledpp:
 3508              	.LFB1758:
1494:Src/mc_interface.c **** 
1495:Src/mc_interface.c **** /**
1496:Src/mc_interface.c ****   * @brief  It returns the rotor electrical angle actually used for reference
1497:Src/mc_interface.c ****   *         frame transformation
1498:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1499:Src/mc_interface.c ****   * @retval int16_t Rotor electrical angle in dpp format
1500:Src/mc_interface.c ****   */
1501:Src/mc_interface.c **** __weak int16_t MCI_GetElAngledpp(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1502:Src/mc_interface.c **** {
 3509              		.loc 6 1502 1
 3510              		.cfi_startproc
 3511              		@ args = 0, pretend = 0, frame = 8
 3512              		@ frame_needed = 1, uses_anonymous_args = 0
 3513              		@ link register save eliminated.
 3514 0000 80B4     		push	{r7}
 3515              	.LCFI298:
 3516              		.cfi_def_cfa_offset 4
 3517              		.cfi_offset 7, -4
 3518 0002 83B0     		sub	sp, sp, #12
 3519              	.LCFI299:
 3520              		.cfi_def_cfa_offset 16
 3521 0004 00AF     		add	r7, sp, #0
 3522              	.LCFI300:
 3523              		.cfi_def_cfa_register 7
 3524 0006 7860     		str	r0, [r7, #4]
1503:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1504:Src/mc_interface.c ****   return ((MC_NULL == pHandle) ? 0 : pHandle->pFOCVars->hElAngle);
1505:Src/mc_interface.c **** #else
1506:Src/mc_interface.c ****   return (pHandle->pFOCVars->hElAngle);
 3525              		.loc 6 1506 18
 3526 0008 7B68     		ldr	r3, [r7, #4]
 3527 000a 5B68     		ldr	r3, [r3, #4]
 3528              		.loc 6 1506 28
 3529 000c B3F92030 		ldrsh	r3, [r3, #32]
1507:Src/mc_interface.c **** #endif
1508:Src/mc_interface.c **** }
ARM GAS  /tmp/cc9hWwcq.s 			page 118


 3530              		.loc 6 1508 1
 3531 0010 1846     		mov	r0, r3
 3532 0012 0C37     		adds	r7, r7, #12
 3533              	.LCFI301:
 3534              		.cfi_def_cfa_offset 4
 3535 0014 BD46     		mov	sp, r7
 3536              	.LCFI302:
 3537              		.cfi_def_cfa_register 13
 3538              		@ sp needed
 3539 0016 5DF8047B 		ldr	r7, [sp], #4
 3540              	.LCFI303:
 3541              		.cfi_restore 7
 3542              		.cfi_def_cfa_offset 0
 3543 001a 7047     		bx	lr
 3544              		.cfi_endproc
 3545              	.LFE1758:
 3547              		.section	.text.MCI_GetTeref,"ax",%progbits
 3548              		.align	1
 3549              		.weak	MCI_GetTeref
 3550              		.syntax unified
 3551              		.thumb
 3552              		.thumb_func
 3553              		.fpu fpv4-sp-d16
 3555              	MCI_GetTeref:
 3556              	.LFB1759:
1509:Src/mc_interface.c **** 
1510:Src/mc_interface.c **** /**
1511:Src/mc_interface.c ****   * @brief  It returns the reference electrical torque, fed to derived class for
1512:Src/mc_interface.c ****   *         Iqref and Idref computation
1513:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1514:Src/mc_interface.c ****   * @retval int16_t Teref
1515:Src/mc_interface.c ****   */
1516:Src/mc_interface.c **** __weak int16_t MCI_GetTeref(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1517:Src/mc_interface.c **** {
 3557              		.loc 6 1517 1
 3558              		.cfi_startproc
 3559              		@ args = 0, pretend = 0, frame = 8
 3560              		@ frame_needed = 1, uses_anonymous_args = 0
 3561              		@ link register save eliminated.
 3562 0000 80B4     		push	{r7}
 3563              	.LCFI304:
 3564              		.cfi_def_cfa_offset 4
 3565              		.cfi_offset 7, -4
 3566 0002 83B0     		sub	sp, sp, #12
 3567              	.LCFI305:
 3568              		.cfi_def_cfa_offset 16
 3569 0004 00AF     		add	r7, sp, #0
 3570              	.LCFI306:
 3571              		.cfi_def_cfa_register 7
 3572 0006 7860     		str	r0, [r7, #4]
1518:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1519:Src/mc_interface.c ****   return ((MC_NULL == pHandle) ? 0 : pHandle->pFOCVars->hTeref);
1520:Src/mc_interface.c **** #else
1521:Src/mc_interface.c ****   return (pHandle->pFOCVars->hTeref);
 3573              		.loc 6 1521 18
 3574 0008 7B68     		ldr	r3, [r7, #4]
 3575 000a 5B68     		ldr	r3, [r3, #4]
ARM GAS  /tmp/cc9hWwcq.s 			page 119


 3576              		.loc 6 1521 28
 3577 000c B3F91E30 		ldrsh	r3, [r3, #30]
1522:Src/mc_interface.c **** #endif
1523:Src/mc_interface.c **** }
 3578              		.loc 6 1523 1
 3579 0010 1846     		mov	r0, r3
 3580 0012 0C37     		adds	r7, r7, #12
 3581              	.LCFI307:
 3582              		.cfi_def_cfa_offset 4
 3583 0014 BD46     		mov	sp, r7
 3584              	.LCFI308:
 3585              		.cfi_def_cfa_register 13
 3586              		@ sp needed
 3587 0016 5DF8047B 		ldr	r7, [sp], #4
 3588              	.LCFI309:
 3589              		.cfi_restore 7
 3590              		.cfi_def_cfa_offset 0
 3591 001a 7047     		bx	lr
 3592              		.cfi_endproc
 3593              	.LFE1759:
 3595              		.section	.text.MCI_GetTeref_F,"ax",%progbits
 3596              		.align	1
 3597              		.weak	MCI_GetTeref_F
 3598              		.syntax unified
 3599              		.thumb
 3600              		.thumb_func
 3601              		.fpu fpv4-sp-d16
 3603              	MCI_GetTeref_F:
 3604              	.LFB1760:
1524:Src/mc_interface.c **** 
1525:Src/mc_interface.c **** /**
1526:Src/mc_interface.c ****   * @brief  It returns the reference electrical torque.
1527:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1528:Src/mc_interface.c ****   * @retval float_t Teref
1529:Src/mc_interface.c ****   */
1530:Src/mc_interface.c **** __weak float_t MCI_GetTeref_F(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1531:Src/mc_interface.c **** {
 3605              		.loc 6 1531 1
 3606              		.cfi_startproc
 3607              		@ args = 0, pretend = 0, frame = 8
 3608              		@ frame_needed = 1, uses_anonymous_args = 0
 3609              		@ link register save eliminated.
 3610 0000 80B4     		push	{r7}
 3611              	.LCFI310:
 3612              		.cfi_def_cfa_offset 4
 3613              		.cfi_offset 7, -4
 3614 0002 83B0     		sub	sp, sp, #12
 3615              	.LCFI311:
 3616              		.cfi_def_cfa_offset 16
 3617 0004 00AF     		add	r7, sp, #0
 3618              	.LCFI312:
 3619              		.cfi_def_cfa_register 7
 3620 0006 7860     		str	r0, [r7, #4]
1532:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1533:Src/mc_interface.c ****   return ((MC_NULL == pHandle) ? 0.0f : ((float_t)pHandle->pFOCVars->hTeref * (float_t)pHandle->pSc
1534:Src/mc_interface.c **** #else
1535:Src/mc_interface.c ****   return ((float_t)pHandle->pFOCVars->hTeref * (float_t)pHandle->pScale->current);
ARM GAS  /tmp/cc9hWwcq.s 			page 120


 3621              		.loc 6 1535 27
 3622 0008 7B68     		ldr	r3, [r7, #4]
 3623 000a 5B68     		ldr	r3, [r3, #4]
 3624              		.loc 6 1535 37
 3625 000c B3F91E30 		ldrsh	r3, [r3, #30]
 3626              		.loc 6 1535 11
 3627 0010 07EE903A 		vmov	s15, r3	@ int
 3628 0014 F8EEE77A 		vcvt.f32.s32	s15, s15
 3629              		.loc 6 1535 64
 3630 0018 7B68     		ldr	r3, [r7, #4]
 3631 001a 9B69     		ldr	r3, [r3, #24]
 3632              		.loc 6 1535 72
 3633 001c 5B68     		ldr	r3, [r3, #4]	@ unaligned
 3634              		.loc 6 1535 46
 3635 001e 07EE103A 		vmov	s14, r3
 3636 0022 67EE877A 		vmul.f32	s15, s15, s14
1536:Src/mc_interface.c **** #endif
1537:Src/mc_interface.c **** }
 3637              		.loc 6 1537 1
 3638 0026 B0EE670A 		vmov.f32	s0, s15
 3639 002a 0C37     		adds	r7, r7, #12
 3640              	.LCFI313:
 3641              		.cfi_def_cfa_offset 4
 3642 002c BD46     		mov	sp, r7
 3643              	.LCFI314:
 3644              		.cfi_def_cfa_register 13
 3645              		@ sp needed
 3646 002e 5DF8047B 		ldr	r7, [sp], #4
 3647              	.LCFI315:
 3648              		.cfi_restore 7
 3649              		.cfi_def_cfa_offset 0
 3650 0032 7047     		bx	lr
 3651              		.cfi_endproc
 3652              	.LFE1760:
 3654              		.section	.text.MCI_GetPhaseCurrentAmplitude,"ax",%progbits
 3655              		.align	1
 3656              		.weak	MCI_GetPhaseCurrentAmplitude
 3657              		.syntax unified
 3658              		.thumb
 3659              		.thumb_func
 3660              		.fpu fpv4-sp-d16
 3662              	MCI_GetPhaseCurrentAmplitude:
 3663              	.LFB1761:
1538:Src/mc_interface.c **** 
1539:Src/mc_interface.c **** /**
1540:Src/mc_interface.c ****   * @brief  It returns the motor phase current amplitude (0-to-peak) in s16A
1541:Src/mc_interface.c ****   *         To convert s16A into Ampere following formula must be used:
1542:Src/mc_interface.c ****   *         Current(Amp) = [Current(s16A) * Vdd micro] / [65536 * Rshunt * Aop]
1543:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1544:Src/mc_interface.c ****   * @retval int16_t Motor phase current (0-to-peak) in s16A
1545:Src/mc_interface.c ****   */
1546:Src/mc_interface.c **** __weak int16_t MCI_GetPhaseCurrentAmplitude(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1547:Src/mc_interface.c **** {
 3664              		.loc 6 1547 1
 3665              		.cfi_startproc
 3666              		@ args = 0, pretend = 0, frame = 16
 3667              		@ frame_needed = 1, uses_anonymous_args = 0
ARM GAS  /tmp/cc9hWwcq.s 			page 121


 3668 0000 80B5     		push	{r7, lr}
 3669              	.LCFI316:
 3670              		.cfi_def_cfa_offset 8
 3671              		.cfi_offset 7, -8
 3672              		.cfi_offset 14, -4
 3673 0002 84B0     		sub	sp, sp, #16
 3674              	.LCFI317:
 3675              		.cfi_def_cfa_offset 24
 3676 0004 00AF     		add	r7, sp, #0
 3677              	.LCFI318:
 3678              		.cfi_def_cfa_register 7
 3679 0006 7860     		str	r0, [r7, #4]
1548:Src/mc_interface.c ****   alphabeta_t Local_Curr;
1549:Src/mc_interface.c ****   int16_t wAux;
1550:Src/mc_interface.c **** 
1551:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1552:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1553:Src/mc_interface.c ****   {
1554:Src/mc_interface.c ****     wAux = 0;
1555:Src/mc_interface.c ****   }
1556:Src/mc_interface.c ****   else
1557:Src/mc_interface.c ****   {
1558:Src/mc_interface.c **** #endif
1559:Src/mc_interface.c ****   Local_Curr = pHandle->pFOCVars->Ialphabeta;
 3680              		.loc 6 1559 23
 3681 0008 7B68     		ldr	r3, [r7, #4]
 3682 000a 5A68     		ldr	r2, [r3, #4]
 3683              		.loc 6 1559 14
 3684 000c 07F10803 		add	r3, r7, #8
 3685 0010 0432     		adds	r2, r2, #4
 3686 0012 1068     		ldr	r0, [r2]	@ unaligned
 3687 0014 1860     		str	r0, [r3]
1560:Src/mc_interface.c ****   wAux = MCM_Modulus(Local_Curr.alpha, Local_Curr.beta);
 3688              		.loc 6 1560 10
 3689 0016 B7F90830 		ldrsh	r3, [r7, #8]
 3690 001a B7F90A20 		ldrsh	r2, [r7, #10]
 3691 001e 1146     		mov	r1, r2
 3692 0020 1846     		mov	r0, r3
 3693 0022 FFF7FEFF 		bl	MCM_Modulus
 3694 0026 0346     		mov	r3, r0
 3695 0028 FB81     		strh	r3, [r7, #14]	@ movhi
1561:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1562:Src/mc_interface.c ****   }
1563:Src/mc_interface.c **** #endif
1564:Src/mc_interface.c **** 
1565:Src/mc_interface.c ****   return (wAux);
 3696              		.loc 6 1565 10
 3697 002a B7F90E30 		ldrsh	r3, [r7, #14]
1566:Src/mc_interface.c **** }
 3698              		.loc 6 1566 1
 3699 002e 1846     		mov	r0, r3
 3700 0030 1037     		adds	r7, r7, #16
 3701              	.LCFI319:
 3702              		.cfi_def_cfa_offset 8
 3703 0032 BD46     		mov	sp, r7
 3704              	.LCFI320:
 3705              		.cfi_def_cfa_register 13
ARM GAS  /tmp/cc9hWwcq.s 			page 122


 3706              		@ sp needed
 3707 0034 80BD     		pop	{r7, pc}
 3708              		.cfi_endproc
 3709              	.LFE1761:
 3711              		.section	.text.MCI_GetPhaseVoltageAmplitude,"ax",%progbits
 3712              		.align	1
 3713              		.weak	MCI_GetPhaseVoltageAmplitude
 3714              		.syntax unified
 3715              		.thumb
 3716              		.thumb_func
 3717              		.fpu fpv4-sp-d16
 3719              	MCI_GetPhaseVoltageAmplitude:
 3720              	.LFB1762:
1567:Src/mc_interface.c **** 
1568:Src/mc_interface.c **** /**
1569:Src/mc_interface.c ****   * @brief  It returns the applied motor phase voltage amplitude (0-to-peak) in
1570:Src/mc_interface.c ****   *         s16V. To convert s16V into Volts following formula must be used:
1571:Src/mc_interface.c ****   *         PhaseVoltage(V) = [PhaseVoltage(s16A) * Vbus(V)] /[sqrt(3) *32767]
1572:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1573:Src/mc_interface.c ****   * @retval int16_t Motor phase voltage (0-to-peak) in s16V
1574:Src/mc_interface.c ****   */
1575:Src/mc_interface.c **** __weak int16_t MCI_GetPhaseVoltageAmplitude(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1576:Src/mc_interface.c **** {
 3721              		.loc 6 1576 1
 3722              		.cfi_startproc
 3723              		@ args = 0, pretend = 0, frame = 24
 3724              		@ frame_needed = 1, uses_anonymous_args = 0
 3725 0000 80B5     		push	{r7, lr}
 3726              	.LCFI321:
 3727              		.cfi_def_cfa_offset 8
 3728              		.cfi_offset 7, -8
 3729              		.cfi_offset 14, -4
 3730 0002 86B0     		sub	sp, sp, #24
 3731              	.LCFI322:
 3732              		.cfi_def_cfa_offset 32
 3733 0004 00AF     		add	r7, sp, #0
 3734              	.LCFI323:
 3735              		.cfi_def_cfa_register 7
 3736 0006 7860     		str	r0, [r7, #4]
1577:Src/mc_interface.c ****   int16_t temp_wAux;
1578:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1579:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1580:Src/mc_interface.c ****   {
1581:Src/mc_interface.c ****     temp_wAux = 0;
1582:Src/mc_interface.c ****   }
1583:Src/mc_interface.c ****   else
1584:Src/mc_interface.c ****   {
1585:Src/mc_interface.c **** #endif
1586:Src/mc_interface.c ****     alphabeta_t Local_Voltage;
1587:Src/mc_interface.c ****     int32_t wAux1;
1588:Src/mc_interface.c ****     int32_t wAux2;
1589:Src/mc_interface.c **** 
1590:Src/mc_interface.c ****     Local_Voltage = pHandle->pFOCVars->Valphabeta;
 3737              		.loc 6 1590 28
 3738 0008 7B68     		ldr	r3, [r7, #4]
 3739 000a 5A68     		ldr	r2, [r3, #4]
 3740              		.loc 6 1590 19
ARM GAS  /tmp/cc9hWwcq.s 			page 123


 3741 000c 07F10803 		add	r3, r7, #8
 3742 0010 1A32     		adds	r2, r2, #26
 3743 0012 1068     		ldr	r0, [r2]	@ unaligned
 3744 0014 1860     		str	r0, [r3]
1591:Src/mc_interface.c ****     wAux1 = (int32_t)(Local_Voltage.alpha) * Local_Voltage.alpha;
 3745              		.loc 6 1591 36
 3746 0016 B7F90830 		ldrsh	r3, [r7, #8]
 3747              		.loc 6 1591 59
 3748 001a B7F90820 		ldrsh	r2, [r7, #8]
 3749              		.loc 6 1591 11
 3750 001e 02FB03F3 		mul	r3, r2, r3
 3751 0022 7B61     		str	r3, [r7, #20]
1592:Src/mc_interface.c ****     wAux2 = (int32_t)(Local_Voltage.beta) * Local_Voltage.beta;
 3752              		.loc 6 1592 36
 3753 0024 B7F90A30 		ldrsh	r3, [r7, #10]
 3754              		.loc 6 1592 58
 3755 0028 B7F90A20 		ldrsh	r2, [r7, #10]
 3756              		.loc 6 1592 11
 3757 002c 02FB03F3 		mul	r3, r2, r3
 3758 0030 3B61     		str	r3, [r7, #16]
1593:Src/mc_interface.c **** 
1594:Src/mc_interface.c ****     wAux1 += wAux2;
 3759              		.loc 6 1594 11
 3760 0032 7A69     		ldr	r2, [r7, #20]
 3761 0034 3B69     		ldr	r3, [r7, #16]
 3762 0036 1344     		add	r3, r3, r2
 3763 0038 7B61     		str	r3, [r7, #20]
1595:Src/mc_interface.c ****     wAux1 = MCM_Sqrt(wAux1);
 3764              		.loc 6 1595 13
 3765 003a 7869     		ldr	r0, [r7, #20]
 3766 003c FFF7FEFF 		bl	MCM_Sqrt
 3767 0040 7861     		str	r0, [r7, #20]
1596:Src/mc_interface.c **** 
1597:Src/mc_interface.c ****     if (wAux1 > INT16_MAX)
 3768              		.loc 6 1597 8
 3769 0042 7B69     		ldr	r3, [r7, #20]
 3770 0044 B3F5004F 		cmp	r3, #32768
 3771 0048 02DB     		blt	.L159
1598:Src/mc_interface.c ****     {
1599:Src/mc_interface.c ****       wAux1 = (int32_t)INT16_MAX;
 3772              		.loc 6 1599 13
 3773 004a 47F6FF73 		movw	r3, #32767
 3774 004e 7B61     		str	r3, [r7, #20]
 3775              	.L159:
1600:Src/mc_interface.c ****     }
1601:Src/mc_interface.c ****     temp_wAux = (int16_t)wAux1;
 3776              		.loc 6 1601 15
 3777 0050 7B69     		ldr	r3, [r7, #20]
 3778 0052 FB81     		strh	r3, [r7, #14]	@ movhi
1602:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1603:Src/mc_interface.c ****   }
1604:Src/mc_interface.c **** #endif
1605:Src/mc_interface.c ****   return (temp_wAux);
 3779              		.loc 6 1605 10
 3780 0054 B7F90E30 		ldrsh	r3, [r7, #14]
1606:Src/mc_interface.c **** }
 3781              		.loc 6 1606 1
ARM GAS  /tmp/cc9hWwcq.s 			page 124


 3782 0058 1846     		mov	r0, r3
 3783 005a 1837     		adds	r7, r7, #24
 3784              	.LCFI324:
 3785              		.cfi_def_cfa_offset 8
 3786 005c BD46     		mov	sp, r7
 3787              	.LCFI325:
 3788              		.cfi_def_cfa_register 13
 3789              		@ sp needed
 3790 005e 80BD     		pop	{r7, pc}
 3791              		.cfi_endproc
 3792              	.LFE1762:
 3794              		.section	.text.MCI_Clear_Iqdref,"ax",%progbits
 3795              		.align	1
 3796              		.weak	MCI_Clear_Iqdref
 3797              		.syntax unified
 3798              		.thumb
 3799              		.thumb_func
 3800              		.fpu fpv4-sp-d16
 3802              	MCI_Clear_Iqdref:
 3803              	.LFB1763:
1607:Src/mc_interface.c **** 
1608:Src/mc_interface.c **** /**
1609:Src/mc_interface.c ****   * @brief  It re-initializes Iqdref variables with their default values.
1610:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1611:Src/mc_interface.c ****   */
1612:Src/mc_interface.c **** __weak void MCI_Clear_Iqdref(MCI_Handle_t *pHandle)
1613:Src/mc_interface.c **** {
 3804              		.loc 6 1613 1
 3805              		.cfi_startproc
 3806              		@ args = 0, pretend = 0, frame = 8
 3807              		@ frame_needed = 1, uses_anonymous_args = 0
 3808 0000 90B5     		push	{r4, r7, lr}
 3809              	.LCFI326:
 3810              		.cfi_def_cfa_offset 12
 3811              		.cfi_offset 4, -12
 3812              		.cfi_offset 7, -8
 3813              		.cfi_offset 14, -4
 3814 0002 83B0     		sub	sp, sp, #12
 3815              	.LCFI327:
 3816              		.cfi_def_cfa_offset 24
 3817 0004 00AF     		add	r7, sp, #0
 3818              	.LCFI328:
 3819              		.cfi_def_cfa_register 7
 3820 0006 7860     		str	r0, [r7, #4]
1614:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1615:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1616:Src/mc_interface.c ****   {
1617:Src/mc_interface.c ****     /* Nothing to do */
1618:Src/mc_interface.c ****   }
1619:Src/mc_interface.c ****   else
1620:Src/mc_interface.c ****   {
1621:Src/mc_interface.c **** #endif
1622:Src/mc_interface.c ****     pHandle->pFOCVars->Iqdref = STC_GetDefaultIqdref(pHandle->pSTC);
 3821              		.loc 6 1622 33
 3822 0008 7B68     		ldr	r3, [r7, #4]
 3823 000a 1A68     		ldr	r2, [r3]
 3824              		.loc 6 1622 12
ARM GAS  /tmp/cc9hWwcq.s 			page 125


 3825 000c 7B68     		ldr	r3, [r7, #4]
 3826 000e 5C68     		ldr	r4, [r3, #4]
 3827              		.loc 6 1622 33
 3828 0010 1046     		mov	r0, r2
 3829 0012 FFF7FEFF 		bl	STC_GetDefaultIqdref
 3830 0016 0346     		mov	r3, r0
 3831 0018 1A46     		mov	r2, r3	@ movhi
 3832 001a 2282     		strh	r2, [r4, #16]	@ movhi
 3833 001c C3F30F43 		ubfx	r3, r3, #16, #16
 3834 0020 6382     		strh	r3, [r4, #18]	@ movhi
1623:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1624:Src/mc_interface.c ****   }
1625:Src/mc_interface.c **** #endif
1626:Src/mc_interface.c **** }
 3835              		.loc 6 1626 1
 3836 0022 00BF     		nop
 3837 0024 0C37     		adds	r7, r7, #12
 3838              	.LCFI329:
 3839              		.cfi_def_cfa_offset 12
 3840 0026 BD46     		mov	sp, r7
 3841              	.LCFI330:
 3842              		.cfi_def_cfa_register 13
 3843              		@ sp needed
 3844 0028 90BD     		pop	{r4, r7, pc}
 3845              		.cfi_endproc
 3846              	.LFE1763:
 3848              		.section	.text.MCI_Clear_PerfMeasure,"ax",%progbits
 3849              		.align	1
 3850              		.weak	MCI_Clear_PerfMeasure
 3851              		.syntax unified
 3852              		.thumb
 3853              		.thumb_func
 3854              		.fpu fpv4-sp-d16
 3856              	MCI_Clear_PerfMeasure:
 3857              	.LFB1764:
1627:Src/mc_interface.c **** __weak void MCI_Clear_PerfMeasure(MCI_Handle_t *pHandle, uint8_t bMotor)
1628:Src/mc_interface.c **** {
 3858              		.loc 6 1628 1
 3859              		.cfi_startproc
 3860              		@ args = 0, pretend = 0, frame = 8
 3861              		@ frame_needed = 1, uses_anonymous_args = 0
 3862 0000 80B5     		push	{r7, lr}
 3863              	.LCFI331:
 3864              		.cfi_def_cfa_offset 8
 3865              		.cfi_offset 7, -8
 3866              		.cfi_offset 14, -4
 3867 0002 82B0     		sub	sp, sp, #8
 3868              	.LCFI332:
 3869              		.cfi_def_cfa_offset 16
 3870 0004 00AF     		add	r7, sp, #0
 3871              	.LCFI333:
 3872              		.cfi_def_cfa_register 7
 3873 0006 7860     		str	r0, [r7, #4]
 3874 0008 0B46     		mov	r3, r1
 3875 000a FB70     		strb	r3, [r7, #3]
1629:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1630:Src/mc_interface.c ****   if (MC_NULL == pHandle)
ARM GAS  /tmp/cc9hWwcq.s 			page 126


1631:Src/mc_interface.c ****   {
1632:Src/mc_interface.c ****     /* Nothing to do */
1633:Src/mc_interface.c ****   }
1634:Src/mc_interface.c ****   else
1635:Src/mc_interface.c ****   {
1636:Src/mc_interface.c **** #endif
1637:Src/mc_interface.c ****     MC_Perf_Clear(pHandle->pPerfMeasure,bMotor);
 3876              		.loc 6 1637 5
 3877 000c 7B68     		ldr	r3, [r7, #4]
 3878 000e 9B6A     		ldr	r3, [r3, #40]
 3879 0010 FA78     		ldrb	r2, [r7, #3]	@ zero_extendqisi2
 3880 0012 1146     		mov	r1, r2
 3881 0014 1846     		mov	r0, r3
 3882 0016 FFF7FEFF 		bl	MC_Perf_Clear
1638:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1639:Src/mc_interface.c ****   }
1640:Src/mc_interface.c **** #endif
1641:Src/mc_interface.c **** }
 3883              		.loc 6 1641 1
 3884 001a 00BF     		nop
 3885 001c 0837     		adds	r7, r7, #8
 3886              	.LCFI334:
 3887              		.cfi_def_cfa_offset 8
 3888 001e BD46     		mov	sp, r7
 3889              	.LCFI335:
 3890              		.cfi_def_cfa_register 13
 3891              		@ sp needed
 3892 0020 80BD     		pop	{r7, pc}
 3893              		.cfi_endproc
 3894              	.LFE1764:
 3896              		.text
 3897              	.Letext0:
 3898              		.file 7 "/usr/share/gcc-arm-none-eabi-10-2020-q4-major/arm-none-eabi/include/machine/_default_type
 3899              		.file 8 "/usr/share/gcc-arm-none-eabi-10-2020-q4-major/arm-none-eabi/include/sys/_stdint.h"
 3900              		.file 9 "Drivers/CMSIS/Device/ST/STM32G4xx/Include/stm32g431xx.h"
 3901              		.file 10 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_tim.h"
 3902              		.file 11 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_usart.h"
 3903              		.file 12 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_dma.h"
 3904              		.file 13 "Inc/mc_type.h"
 3905              		.file 14 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/pid_regulator.h"
 3906              		.file 15 "Inc/pwm_curr_fdbk.h"
 3907              		.file 16 "Inc/mc_perf.h"
 3908              		.file 17 "Inc/mc_interface.h"
ARM GAS  /tmp/cc9hWwcq.s 			page 127


DEFINED SYMBOLS
                            *ABS*:0000000000000000 mc_interface.c
     /tmp/cc9hWwcq.s:18     .rodata.OFFSET_TAB_CCMRx:0000000000000000 $d
     /tmp/cc9hWwcq.s:21     .rodata.OFFSET_TAB_CCMRx:0000000000000000 OFFSET_TAB_CCMRx
     /tmp/cc9hWwcq.s:24     .rodata.SHIFT_TAB_OCxx:0000000000000000 $d
     /tmp/cc9hWwcq.s:27     .rodata.SHIFT_TAB_OCxx:0000000000000000 SHIFT_TAB_OCxx
     /tmp/cc9hWwcq.s:30     .rodata.SHIFT_TAB_ICxx:0000000000000000 $d
     /tmp/cc9hWwcq.s:33     .rodata.SHIFT_TAB_ICxx:0000000000000000 SHIFT_TAB_ICxx
     /tmp/cc9hWwcq.s:36     .rodata.SHIFT_TAB_CCxP:0000000000000000 $d
     /tmp/cc9hWwcq.s:39     .rodata.SHIFT_TAB_CCxP:0000000000000000 SHIFT_TAB_CCxP
     /tmp/cc9hWwcq.s:42     .rodata.SHIFT_TAB_OISx:0000000000000000 $d
     /tmp/cc9hWwcq.s:45     .rodata.SHIFT_TAB_OISx:0000000000000000 SHIFT_TAB_OISx
     /tmp/cc9hWwcq.s:48     .rodata.USART_PRESCALER_TAB:0000000000000000 $d
     /tmp/cc9hWwcq.s:51     .rodata.USART_PRESCALER_TAB:0000000000000000 USART_PRESCALER_TAB
     /tmp/cc9hWwcq.s:65     .rodata.CHANNEL_OFFSET_TAB:0000000000000000 $d
     /tmp/cc9hWwcq.s:68     .rodata.CHANNEL_OFFSET_TAB:0000000000000000 CHANNEL_OFFSET_TAB
     /tmp/cc9hWwcq.s:71     .text.LL_CORDIC_IsActiveFlag_RRDY:0000000000000000 $t
     /tmp/cc9hWwcq.s:78     .text.LL_CORDIC_IsActiveFlag_RRDY:0000000000000000 LL_CORDIC_IsActiveFlag_RRDY
     /tmp/cc9hWwcq.s:129    .text.LL_CORDIC_WriteData:0000000000000000 $t
     /tmp/cc9hWwcq.s:135    .text.LL_CORDIC_WriteData:0000000000000000 LL_CORDIC_WriteData
     /tmp/cc9hWwcq.s:176    .text.LL_CORDIC_ReadData:0000000000000000 $t
     /tmp/cc9hWwcq.s:182    .text.LL_CORDIC_ReadData:0000000000000000 LL_CORDIC_ReadData
     /tmp/cc9hWwcq.s:221    .text.MCM_Modulus:0000000000000000 $t
     /tmp/cc9hWwcq.s:227    .text.MCM_Modulus:0000000000000000 MCM_Modulus
     /tmp/cc9hWwcq.s:327    .text.MCM_Modulus:000000000000005c $d
     /tmp/cc9hWwcq.s:333    .text.SPD_Check:0000000000000000 $t
     /tmp/cc9hWwcq.s:339    .text.SPD_Check:0000000000000000 SPD_Check
     /tmp/cc9hWwcq.s:394    .text.STC_StopRamp:0000000000000000 $t
     /tmp/cc9hWwcq.s:400    .text.STC_StopRamp:0000000000000000 STC_StopRamp
     /tmp/cc9hWwcq.s:445    .text.STC_RampCompleted:0000000000000000 $t
     /tmp/cc9hWwcq.s:451    .text.STC_RampCompleted:0000000000000000 STC_RampCompleted
     /tmp/cc9hWwcq.s:502    .text.STC_GetSpeedSensor:0000000000000000 $t
     /tmp/cc9hWwcq.s:508    .text.STC_GetSpeedSensor:0000000000000000 STC_GetSpeedSensor
     /tmp/cc9hWwcq.s:547    .text.MCI_ExecSpeedRamp:0000000000000000 $t
     /tmp/cc9hWwcq.s:554    .text.MCI_ExecSpeedRamp:0000000000000000 MCI_ExecSpeedRamp
     /tmp/cc9hWwcq.s:615    .text.MCI_ExecSpeedRamp_F:0000000000000000 $t
     /tmp/cc9hWwcq.s:622    .text.MCI_ExecSpeedRamp_F:0000000000000000 MCI_ExecSpeedRamp_F
     /tmp/cc9hWwcq.s:673    .text.MCI_ExecSpeedRamp_F:0000000000000048 $d
     /tmp/cc9hWwcq.s:678    .text.MCI_ExecTorqueRamp:0000000000000000 $t
     /tmp/cc9hWwcq.s:685    .text.MCI_ExecTorqueRamp:0000000000000000 MCI_ExecTorqueRamp
     /tmp/cc9hWwcq.s:745    .text.MCI_ExecTorqueRamp_F:0000000000000000 $t
     /tmp/cc9hWwcq.s:752    .text.MCI_ExecTorqueRamp_F:0000000000000000 MCI_ExecTorqueRamp_F
     /tmp/cc9hWwcq.s:800    .text.MCI_ExecTorqueRamp_F:0000000000000040 $d
     /tmp/cc9hWwcq.s:805    .text.MCI_SetCurrentReferences:0000000000000000 $t
     /tmp/cc9hWwcq.s:812    .text.MCI_SetCurrentReferences:0000000000000000 MCI_SetCurrentReferences
     /tmp/cc9hWwcq.s:871    .text.MCI_SetCurrentReferences_F:0000000000000000 $t
     /tmp/cc9hWwcq.s:878    .text.MCI_SetCurrentReferences_F:0000000000000000 MCI_SetCurrentReferences_F
     /tmp/cc9hWwcq.s:947    .text.MCI_SetCurrentReferences_F:0000000000000068 $d
     /tmp/cc9hWwcq.s:952    .text.MCI_StartMotor:0000000000000000 $t
     /tmp/cc9hWwcq.s:959    .text.MCI_StartMotor:0000000000000000 MCI_StartMotor
     /tmp/cc9hWwcq.s:1804   .text.MCI_GetSTMState:0000000000000000 MCI_GetSTMState
     /tmp/cc9hWwcq.s:1850   .text.MCI_GetOccurredFaults:0000000000000000 MCI_GetOccurredFaults
     /tmp/cc9hWwcq.s:1896   .text.MCI_GetCurrentFaults:0000000000000000 MCI_GetCurrentFaults
     /tmp/cc9hWwcq.s:1029   .text.MCI_StartWithPolarizationMotor:0000000000000000 $t
     /tmp/cc9hWwcq.s:1036   .text.MCI_StartWithPolarizationMotor:0000000000000000 MCI_StartWithPolarizationMotor
     /tmp/cc9hWwcq.s:1112   .text.MCI_StartOffsetMeasurments:0000000000000000 $t
     /tmp/cc9hWwcq.s:1119   .text.MCI_StartOffsetMeasurments:0000000000000000 MCI_StartOffsetMeasurments
ARM GAS  /tmp/cc9hWwcq.s 			page 128


     /tmp/cc9hWwcq.s:1191   .text.MCI_GetCalibratedOffsetsMotor:0000000000000000 $t
     /tmp/cc9hWwcq.s:1198   .text.MCI_GetCalibratedOffsetsMotor:0000000000000000 MCI_GetCalibratedOffsetsMotor
     /tmp/cc9hWwcq.s:1254   .text.MCI_SetCalibratedOffsetsMotor:0000000000000000 $t
     /tmp/cc9hWwcq.s:1261   .text.MCI_SetCalibratedOffsetsMotor:0000000000000000 MCI_SetCalibratedOffsetsMotor
     /tmp/cc9hWwcq.s:1336   .text.MCI_StopMotor:0000000000000000 $t
     /tmp/cc9hWwcq.s:1343   .text.MCI_StopMotor:0000000000000000 MCI_StopMotor
     /tmp/cc9hWwcq.s:1429   .text.MCI_FaultAcknowledged:0000000000000000 $t
     /tmp/cc9hWwcq.s:1436   .text.MCI_FaultAcknowledged:0000000000000000 MCI_FaultAcknowledged
     /tmp/cc9hWwcq.s:1499   .text.MCI_FaultProcessing:0000000000000000 $t
     /tmp/cc9hWwcq.s:1506   .text.MCI_FaultProcessing:0000000000000000 MCI_FaultProcessing
     /tmp/cc9hWwcq.s:1571   .text.MCI_ExecBufferedCommands:0000000000000000 $t
     /tmp/cc9hWwcq.s:1578   .text.MCI_ExecBufferedCommands:0000000000000000 MCI_ExecBufferedCommands
     /tmp/cc9hWwcq.s:1734   .text.MCI_IsCommandAcknowledged:0000000000000000 $t
     /tmp/cc9hWwcq.s:1741   .text.MCI_IsCommandAcknowledged:0000000000000000 MCI_IsCommandAcknowledged
     /tmp/cc9hWwcq.s:1797   .text.MCI_GetSTMState:0000000000000000 $t
     /tmp/cc9hWwcq.s:1843   .text.MCI_GetOccurredFaults:0000000000000000 $t
     /tmp/cc9hWwcq.s:1889   .text.MCI_GetCurrentFaults:0000000000000000 $t
     /tmp/cc9hWwcq.s:1935   .text.MCI_GetFaultState:0000000000000000 $t
     /tmp/cc9hWwcq.s:1942   .text.MCI_GetFaultState:0000000000000000 MCI_GetFaultState
     /tmp/cc9hWwcq.s:1994   .text.MCI_GetControlMode:0000000000000000 $t
     /tmp/cc9hWwcq.s:2001   .text.MCI_GetControlMode:0000000000000000 MCI_GetControlMode
     /tmp/cc9hWwcq.s:2040   .text.MCI_GetImposedMotorDirection:0000000000000000 $t
     /tmp/cc9hWwcq.s:2047   .text.MCI_GetImposedMotorDirection:0000000000000000 MCI_GetImposedMotorDirection
     /tmp/cc9hWwcq.s:2154   .text.MCI_GetLastRampFinalSpeed:0000000000000000 $t
     /tmp/cc9hWwcq.s:2161   .text.MCI_GetLastRampFinalSpeed:0000000000000000 MCI_GetLastRampFinalSpeed
     /tmp/cc9hWwcq.s:2200   .text.MCI_GetLastRampFinalTorque:0000000000000000 $t
     /tmp/cc9hWwcq.s:2207   .text.MCI_GetLastRampFinalTorque:0000000000000000 MCI_GetLastRampFinalTorque
     /tmp/cc9hWwcq.s:2246   .text.MCI_GetLastRampFinalTorque_F:0000000000000000 $t
     /tmp/cc9hWwcq.s:2253   .text.MCI_GetLastRampFinalTorque_F:0000000000000000 MCI_GetLastRampFinalTorque_F
     /tmp/cc9hWwcq.s:2303   .text.MCI_GetLastRampFinalDuration:0000000000000000 $t
     /tmp/cc9hWwcq.s:2310   .text.MCI_GetLastRampFinalDuration:0000000000000000 MCI_GetLastRampFinalDuration
     /tmp/cc9hWwcq.s:2349   .text.MCI_GetLastRampFinalSpeed_F:0000000000000000 $t
     /tmp/cc9hWwcq.s:2356   .text.MCI_GetLastRampFinalSpeed_F:0000000000000000 MCI_GetLastRampFinalSpeed_F
     /tmp/cc9hWwcq.s:2415   .text.MCI_GetLastRampFinalSpeed_F:000000000000004c $d
     /tmp/cc9hWwcq.s:2420   .text.MCI_RampCompleted:0000000000000000 $t
     /tmp/cc9hWwcq.s:2427   .text.MCI_RampCompleted:0000000000000000 MCI_RampCompleted
     /tmp/cc9hWwcq.s:2479   .text.MCI_StopSpeedRamp:0000000000000000 $t
     /tmp/cc9hWwcq.s:2486   .text.MCI_StopSpeedRamp:0000000000000000 MCI_StopSpeedRamp
     /tmp/cc9hWwcq.s:2524   .text.MCI_StopRamp:0000000000000000 $t
     /tmp/cc9hWwcq.s:2531   .text.MCI_StopRamp:0000000000000000 MCI_StopRamp
     /tmp/cc9hWwcq.s:2568   .text.MCI_GetSpdSensorReliability:0000000000000000 $t
     /tmp/cc9hWwcq.s:2575   .text.MCI_GetSpdSensorReliability:0000000000000000 MCI_GetSpdSensorReliability
     /tmp/cc9hWwcq.s:2620   .text.MCI_GetAvrgMecSpeedUnit:0000000000000000 $t
     /tmp/cc9hWwcq.s:2627   .text.MCI_GetAvrgMecSpeedUnit:0000000000000000 MCI_GetAvrgMecSpeedUnit
     /tmp/cc9hWwcq.s:2672   .text.MCI_GetAvrgMecSpeed_F:0000000000000000 $t
     /tmp/cc9hWwcq.s:2679   .text.MCI_GetAvrgMecSpeed_F:0000000000000000 MCI_GetAvrgMecSpeed_F
     /tmp/cc9hWwcq.s:2733   .text.MCI_GetAvrgMecSpeed_F:0000000000000048 $d
     /tmp/cc9hWwcq.s:2738   .text.MCI_GetMecSpeedRefUnit:0000000000000000 $t
     /tmp/cc9hWwcq.s:2745   .text.MCI_GetMecSpeedRefUnit:0000000000000000 MCI_GetMecSpeedRefUnit
     /tmp/cc9hWwcq.s:2783   .text.MCI_GetMecSpeedRef_F:0000000000000000 $t
     /tmp/cc9hWwcq.s:2790   .text.MCI_GetMecSpeedRef_F:0000000000000000 MCI_GetMecSpeedRef_F
     /tmp/cc9hWwcq.s:2837   .text.MCI_GetMecSpeedRef_F:000000000000003c $d
     /tmp/cc9hWwcq.s:2842   .text.MCI_GetIab:0000000000000000 $t
     /tmp/cc9hWwcq.s:2849   .text.MCI_GetIab:0000000000000000 MCI_GetIab
     /tmp/cc9hWwcq.s:2897   .text.MCI_GetIab_F:0000000000000000 $t
     /tmp/cc9hWwcq.s:2904   .text.MCI_GetIab_F:0000000000000000 MCI_GetIab_F
     /tmp/cc9hWwcq.s:2986   .text.MCI_GetIalphabeta:0000000000000000 $t
ARM GAS  /tmp/cc9hWwcq.s 			page 129


     /tmp/cc9hWwcq.s:2993   .text.MCI_GetIalphabeta:0000000000000000 MCI_GetIalphabeta
     /tmp/cc9hWwcq.s:3042   .text.MCI_GetIqd:0000000000000000 $t
     /tmp/cc9hWwcq.s:3049   .text.MCI_GetIqd:0000000000000000 MCI_GetIqd
     /tmp/cc9hWwcq.s:3098   .text.MCI_GetIqd_F:0000000000000000 $t
     /tmp/cc9hWwcq.s:3105   .text.MCI_GetIqd_F:0000000000000000 MCI_GetIqd_F
     /tmp/cc9hWwcq.s:3187   .text.MCI_GetIqdHF:0000000000000000 $t
     /tmp/cc9hWwcq.s:3194   .text.MCI_GetIqdHF:0000000000000000 MCI_GetIqdHF
     /tmp/cc9hWwcq.s:3243   .text.MCI_GetIqdref:0000000000000000 $t
     /tmp/cc9hWwcq.s:3250   .text.MCI_GetIqdref:0000000000000000 MCI_GetIqdref
     /tmp/cc9hWwcq.s:3299   .text.MCI_GetIqdref_F:0000000000000000 $t
     /tmp/cc9hWwcq.s:3306   .text.MCI_GetIqdref_F:0000000000000000 MCI_GetIqdref_F
     /tmp/cc9hWwcq.s:3388   .text.MCI_GetVqd:0000000000000000 $t
     /tmp/cc9hWwcq.s:3395   .text.MCI_GetVqd:0000000000000000 MCI_GetVqd
     /tmp/cc9hWwcq.s:3444   .text.MCI_GetValphabeta:0000000000000000 $t
     /tmp/cc9hWwcq.s:3451   .text.MCI_GetValphabeta:0000000000000000 MCI_GetValphabeta
     /tmp/cc9hWwcq.s:3500   .text.MCI_GetElAngledpp:0000000000000000 $t
     /tmp/cc9hWwcq.s:3507   .text.MCI_GetElAngledpp:0000000000000000 MCI_GetElAngledpp
     /tmp/cc9hWwcq.s:3548   .text.MCI_GetTeref:0000000000000000 $t
     /tmp/cc9hWwcq.s:3555   .text.MCI_GetTeref:0000000000000000 MCI_GetTeref
     /tmp/cc9hWwcq.s:3596   .text.MCI_GetTeref_F:0000000000000000 $t
     /tmp/cc9hWwcq.s:3603   .text.MCI_GetTeref_F:0000000000000000 MCI_GetTeref_F
     /tmp/cc9hWwcq.s:3655   .text.MCI_GetPhaseCurrentAmplitude:0000000000000000 $t
     /tmp/cc9hWwcq.s:3662   .text.MCI_GetPhaseCurrentAmplitude:0000000000000000 MCI_GetPhaseCurrentAmplitude
     /tmp/cc9hWwcq.s:3712   .text.MCI_GetPhaseVoltageAmplitude:0000000000000000 $t
     /tmp/cc9hWwcq.s:3719   .text.MCI_GetPhaseVoltageAmplitude:0000000000000000 MCI_GetPhaseVoltageAmplitude
     /tmp/cc9hWwcq.s:3795   .text.MCI_Clear_Iqdref:0000000000000000 $t
     /tmp/cc9hWwcq.s:3802   .text.MCI_Clear_Iqdref:0000000000000000 MCI_Clear_Iqdref
     /tmp/cc9hWwcq.s:3849   .text.MCI_Clear_PerfMeasure:0000000000000000 $t
     /tmp/cc9hWwcq.s:3856   .text.MCI_Clear_PerfMeasure:0000000000000000 MCI_Clear_PerfMeasure

UNDEFINED SYMBOLS
PWMC_GetOffsetCalib
PWMC_SetOffsetCalib
STC_SetControlMode
STC_ExecRamp
STC_StopSpeedRamp
SPD_GetAvrgMecSpeedUnit
STC_GetMecSpeedRefUnit
MCM_Sqrt
STC_GetDefaultIqdref
MC_Perf_Clear
