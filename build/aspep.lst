ARM GAS  /tmp/cc0OBPYV.s 			page 1


   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 2
  13              		.file	"aspep.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.rodata.OFFSET_TAB_CCMRx,"a"
  18              		.align	2
  21              	OFFSET_TAB_CCMRx:
  22 0000 00000000 		.ascii	"\000\000\000\000\004\004\004\00488"
  22      04040404 
  22      3838
  23              		.section	.rodata.SHIFT_TAB_OCxx,"a"
  24              		.align	2
  27              	SHIFT_TAB_OCxx:
  28 0000 00000800 		.ascii	"\000\000\010\000\000\000\010\000\000\010"
  28      00000800 
  28      0008
  29              		.section	.rodata.SHIFT_TAB_ICxx,"a"
  30              		.align	2
  33              	SHIFT_TAB_ICxx:
  34 0000 00000800 		.ascii	"\000\000\010\000\000\000\010\000\000\000"
  34      00000800 
  34      0000
  35              		.section	.rodata.SHIFT_TAB_CCxP,"a"
  36              		.align	2
  39              	SHIFT_TAB_CCxP:
  40 0000 00020406 		.ascii	"\000\002\004\006\010\012\014\016\020\024"
  40      080A0C0E 
  40      1014
  41              		.section	.rodata.SHIFT_TAB_OISx,"a"
  42              		.align	2
  45              	SHIFT_TAB_OISx:
  46 0000 00010203 		.ascii	"\000\001\002\003\004\005\006\007\010\012"
  46      04050607 
  46      080A
  47              		.section	.rodata.USART_PRESCALER_TAB,"a"
  48              		.align	2
  51              	USART_PRESCALER_TAB:
  52 0000 01000000 		.word	1
  53 0004 02000000 		.word	2
  54 0008 04000000 		.word	4
  55 000c 06000000 		.word	6
  56 0010 08000000 		.word	8
  57 0014 0A000000 		.word	10
  58 0018 0C000000 		.word	12
  59 001c 10000000 		.word	16
ARM GAS  /tmp/cc0OBPYV.s 			page 2


  60 0020 20000000 		.word	32
  61 0024 40000000 		.word	64
  62 0028 80000000 		.word	128
  63 002c 00010000 		.word	256
  64              		.section	.rodata.CHANNEL_OFFSET_TAB,"a"
  65              		.align	2
  68              	CHANNEL_OFFSET_TAB:
  69 0000 081C3044 		.ascii	"\010\0340DXl"
  69      586C
  70              		.section	.rodata.CRC4_Lookup8,"a"
  71              		.align	2
  74              	CRC4_Lookup8:
  75 0000 00020406 		.ascii	"\000\002\004\006\010\012\014\016\007\005\003\001\017"
  75      080A0C0E 
  75      07050301 
  75      0F
  76 000d 0D0B0907 		.ascii	"\015\013\011\007\005\003\001\017\015\013\011\000\002"
  76      0503010F 
  76      0D0B0900 
  76      02
  77 001a 0406080A 		.ascii	"\004\006\010\012\014\016\016\014\012\010\006\004\002"
  77      0C0E0E0C 
  77      0A080604 
  77      02
  78 0027 00090B0D 		.ascii	"\000\011\013\015\017\001\003\005\007\011\013\015\017"
  78      0F010305 
  78      07090B0D 
  78      0F
  79 0034 01030507 		.ascii	"\001\003\005\007\016\014\012\010\006\004\002\000\013"
  79      0E0C0A08 
  79      06040200 
  79      0B
  80 0041 090F0D03 		.ascii	"\011\017\015\003\001\007\005\014\016\010\012\004\006"
  80      0107050C 
  80      0E080A04 
  80      06
  81 004e 00020C0E 		.ascii	"\000\002\014\016\010\012\004\006\000\002\013\011\017"
  81      080A0406 
  81      00020B09 
  81      0F
  82 005b 0D030107 		.ascii	"\015\003\001\007\005\005\007\001\003\015\017\011\013"
  82      05050701 
  82      030D0F09 
  82      0B
  83 0068 02000604 		.ascii	"\002\000\006\004\012\010\016\014\002\000\006\004\012"
  83      0A080E0C 
  83      02000604 
  83      0A
  84 0075 080E0C05 		.ascii	"\010\016\014\005\007\001\003\015\017\011\013\001\003"
  84      0701030D 
  84      0F090B01 
  84      03
  85 0082 0507090B 		.ascii	"\005\007\011\013\015\017\006\004\002\000\016\014\012"
  85      0D0F0604 
  85      02000E0C 
  85      0A
  86 008f 08060402 		.ascii	"\010\006\004\002\000\016\014\012\010\001\003\005\007"
ARM GAS  /tmp/cc0OBPYV.s 			page 3


  86      000E0C0A 
  86      08010305 
  86      07
  87 009c 090B0D0F 		.ascii	"\011\013\015\017\017\015\013\011\007\005\003\001\010"
  87      0F0D0B09 
  87      07050301 
  87      08
  88 00a9 0A0C0E00 		.ascii	"\012\014\016\000\002\004\006\010\012\014\016\000\002"
  88      02040608 
  88      0A0C0E00 
  88      02
  89 00b6 04060F0D 		.ascii	"\004\006\017\015\013\011\007\005\003\001\012\010\016"
  89      0B090705 
  89      03010A08 
  89      0E
  90 00c3 0C020006 		.ascii	"\014\002\000\006\004\015\017\011\013\005\007\001\003"
  90      040D0F09 
  90      0B050701 
  90      03
  91 00d0 0D0F090B 		.ascii	"\015\017\011\013\005\007\001\003\012\010\016\014\002"
  91      05070103 
  91      0A080E0C 
  91      02
  92 00dd 00060404 		.ascii	"\000\006\004\004\006\000\002\014\016\010\012\003\001"
  92      0600020C 
  92      0E080A03 
  92      01
  93 00ea 07050B09 		.ascii	"\007\005\013\011\017\015\003\001\007\005\013\011\017"
  93      0F0D0301 
  93      07050B09 
  93      0F
  94 00f7 0D040600 		.ascii	"\015\004\006\000\002\014\016\010\012"
  94      020C0E08 
  94      0A
  95              		.section	.rodata.CRC4_Lookup4,"a"
  96              		.align	2
  99              	CRC4_Lookup4:
 100 0000 00070E09 		.ascii	"\000\007\016\011\013\014\005\002\001\006\017\010\012"
 100      0B0C0502 
 100      01060F08 
 100      0A
 101 000d 0D0403   		.ascii	"\015\004\003"
 102              		.section	.text.ASPEP_ComputeHeaderCRC,"ax",%progbits
 103              		.align	1
 104              		.arch armv7e-m
 105              		.syntax unified
 106              		.thumb
 107              		.thumb_func
 108              		.fpu fpv4-sp-d16
 110              	ASPEP_ComputeHeaderCRC:
 111              	.LFB1437:
 112              		.file 1 "Src/aspep.c"
   1:Src/aspep.c   **** 
   2:Src/aspep.c   **** /**
   3:Src/aspep.c   ****   ******************************************************************************
   4:Src/aspep.c   ****   * @file   aspep.c
   5:Src/aspep.c   ****   * @author Motor Control SDK Team, ST Microelectronics
ARM GAS  /tmp/cc0OBPYV.s 			page 4


   6:Src/aspep.c   ****   * @brief  This file provides firmware functions that implement the aspep protocol
   7:Src/aspep.c   ****   *
   8:Src/aspep.c   ****   *
   9:Src/aspep.c   ****   ******************************************************************************
  10:Src/aspep.c   ****   * @attention
  11:Src/aspep.c   ****   *
  12:Src/aspep.c   ****   * <h2><center>&copy; Copyright (c) 2024 STMicroelectronics.
  13:Src/aspep.c   ****   * All rights reserved.</center></h2>
  14:Src/aspep.c   ****   *
  15:Src/aspep.c   ****   * This software component is licensed by ST under Ultimate Liberty license
  16:Src/aspep.c   ****   * SLA0044, the "License"; You may not use this file except in compliance with
  17:Src/aspep.c   ****   * the License. You may obtain a copy of the License at:
  18:Src/aspep.c   ****   *                             www.st.com/SLA0044
  19:Src/aspep.c   ****   *
  20:Src/aspep.c   ****   ******************************************************************************
  21:Src/aspep.c   ****   */
  22:Src/aspep.c   **** 
  23:Src/aspep.c   **** #include <stdint.h>
  24:Src/aspep.c   **** #include "aspep.h"
  25:Src/aspep.c   **** 
  26:Src/aspep.c   **** /* Local definition */
  27:Src/aspep.c   **** #define MIN(a,b) ( ((a) < (b)) ? (a) : (b) )
  28:Src/aspep.c   **** 
  29:Src/aspep.c   **** /* Local functions */
  30:Src/aspep.c   **** static bool ASPEP_CheckBeacon (ASPEP_Handle_t *pHandle);
  31:Src/aspep.c   **** static uint8_t ASPEP_TXframeProcess(ASPEP_Handle_t *pHandle, uint8_t packetType, void *txBuffer, ui
  32:Src/aspep.c   **** void ASPEP_sendBeacon(ASPEP_Handle_t *pHandle, ASPEP_Capabilities_def *capabilities);
  33:Src/aspep.c   **** void ASPEP_sendPing(ASPEP_Handle_t *pHandle, uint8_t state, uint16_t PacketNumber);
  34:Src/aspep.c   **** 
  35:Src/aspep.c   **** /** @addtogroup MCSDK
  36:Src/aspep.c   ****   * @{
  37:Src/aspep.c   ****   */
  38:Src/aspep.c   **** 
  39:Src/aspep.c   **** /** @addtogroup MCP
  40:Src/aspep.c   ****   * @{
  41:Src/aspep.c   ****   */
  42:Src/aspep.c   **** 
  43:Src/aspep.c   **** #ifndef CRC4_PER_NIBBLE
  44:Src/aspep.c   **** /**
  45:Src/aspep.c   ****   * @brief CRC-4 lookup table with 256 entries
  46:Src/aspep.c   ****   *
  47:Src/aspep.c   ****   * Computes and checks the CRC on the header with the BYTE granularity.
  48:Src/aspep.c   ****   *
  49:Src/aspep.c   ****   * When computing the CRC, the 7th nibble must to be processed with the CRC_Lookup4
  50:Src/aspep.c   ****   * table. Indeed, the header contains 7 nibbles (28 bits) of data on which the CRC is
  51:Src/aspep.c   ****   * to be computed. Hence, the CRC4_Lookup8 table cannot be used for the last nibble.
  52:Src/aspep.c   ****   *
  53:Src/aspep.c   ****   * Using only this lookup table requires that the amount of input data is a multiple of
  54:Src/aspep.c   ****   * 8 bits.
  55:Src/aspep.c   ****   */
  56:Src/aspep.c   **** static uint8_t const CRC4_Lookup8[] =
  57:Src/aspep.c   **** {
  58:Src/aspep.c   ****   /*          0,    1,    2,    3,    4,    5,    6,    7,    8,    9,   A,     B,    C,    D,    E
  59:Src/aspep.c   ****   /* 0 */  0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x07, 0x05, 0x03, 0x01, 0x0f, 0x0d, 0x0b
  60:Src/aspep.c   ****   /* 1 */  0x07, 0x05, 0x03, 0x01, 0x0f, 0x0d, 0x0b, 0x09, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c
  61:Src/aspep.c   ****   /* 2 */  0x0e, 0x0c, 0x0a, 0x08, 0x06, 0x04, 0x02, 0x00, 0x09, 0x0b, 0x0d, 0x0f, 0x01, 0x03, 0x05
  62:Src/aspep.c   ****   /* 3 */  0x09, 0x0b, 0x0d, 0x0f, 0x01, 0x03, 0x05, 0x07, 0x0e, 0x0c, 0x0a, 0x08, 0x06, 0x04, 0x02
ARM GAS  /tmp/cc0OBPYV.s 			page 5


  63:Src/aspep.c   ****   /* 4 */  0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05, 0x0c, 0x0e, 0x08, 0x0a, 0x04, 0x06, 0x00
  64:Src/aspep.c   ****   /* 5 */  0x0c, 0x0e, 0x08, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07
  65:Src/aspep.c   ****   /* 6 */  0x05, 0x07, 0x01, 0x03, 0x0d, 0x0f, 0x09, 0x0b, 0x02, 0x00, 0x06, 0x04, 0x0a, 0x08, 0x0e
  66:Src/aspep.c   ****   /* 7 */  0x02, 0x00, 0x06, 0x04, 0x0a, 0x08, 0x0e, 0x0c, 0x05, 0x07, 0x01, 0x03, 0x0d, 0x0f, 0x09
  67:Src/aspep.c   ****   /* 8 */  0x01, 0x03, 0x05, 0x07, 0x09, 0x0b, 0x0d, 0x0f, 0x06, 0x04, 0x02, 0x00, 0x0e, 0x0c, 0x0a
  68:Src/aspep.c   ****   /* 9 */  0x06, 0x04, 0x02, 0x00, 0x0e, 0x0c, 0x0a, 0x08, 0x01, 0x03, 0x05, 0x07, 0x09, 0x0b, 0x0d
  69:Src/aspep.c   ****   /* A */  0x0f, 0x0d, 0x0b, 0x09, 0x07, 0x05, 0x03, 0x01, 0x08, 0x0a, 0x0c, 0x0e, 0x00, 0x02, 0x04
  70:Src/aspep.c   ****   /* B */  0x08, 0x0a, 0x0c, 0x0e, 0x00, 0x02, 0x04, 0x06, 0x0f, 0x0d, 0x0b, 0x09, 0x07, 0x05, 0x03
  71:Src/aspep.c   ****   /* C */  0x0a, 0x08, 0x0e, 0x0c, 0x02, 0x00, 0x06, 0x04, 0x0d, 0x0f, 0x09, 0x0b, 0x05, 0x07, 0x01
  72:Src/aspep.c   ****   /* D */  0x0d, 0x0f, 0x09, 0x0b, 0x05, 0x07, 0x01, 0x03, 0x0a, 0x08, 0x0e, 0x0c, 0x02, 0x00, 0x06
  73:Src/aspep.c   ****   /* E */  0x04, 0x06, 0x00, 0x02, 0x0c, 0x0e, 0x08, 0x0a, 0x03, 0x01, 0x07, 0x05, 0x0b, 0x09, 0x0f
  74:Src/aspep.c   ****   /* F */  0x03, 0x01, 0x07, 0x05, 0x0b, 0x09, 0x0f, 0x0d, 0x04, 0x06, 0x00, 0x02, 0x0c, 0x0e, 0x08
  75:Src/aspep.c   **** };
  76:Src/aspep.c   **** 
  77:Src/aspep.c   **** /**
  78:Src/aspep.c   ****   * @brief CRC-4 lookup table with 16 entries
  79:Src/aspep.c   ****   *
  80:Src/aspep.c   ****   *  Used to compute and check the CRC on the header with either the BYTE or NIBBLE granularity
  81:Src/aspep.c   ****   * In case the BYTE granularity is used, the table is used only with the 7th nibble of the header
  82:Src/aspep.c   ****   * (bits 24 to 27) when computing the CRC.
  83:Src/aspep.c   ****   */
  84:Src/aspep.c   ****   //cstat !MISRAC2012-Rule-8.9_a
  85:Src/aspep.c   **** static uint8_t const CRC4_Lookup4[] =
  86:Src/aspep.c   **** {
  87:Src/aspep.c   ****   /*   0,    1,    2,    3,    4,    5,    6,    7,    8,    9,   A,     B,    C,    D,    E,    F 
  88:Src/aspep.c   ****   0x00, 0x07, 0x0e, 0x09, 0x0b, 0x0c, 0x05, 0x02, 0x01, 0x06, 0x0f, 0x08, 0x0a, 0x0d, 0x04, 0x03
  89:Src/aspep.c   **** };
  90:Src/aspep.c   **** #endif /* CRC4_PER_NIBBLE */
  91:Src/aspep.c   **** 
  92:Src/aspep.c   **** /**
  93:Src/aspep.c   ****   * @brief Computes a 4-bit CRC on the 28 LSBs of @p header and returns it in the 4 MSB of the head
  94:Src/aspep.c   ****   *
  95:Src/aspep.c   ****   *  The generator polynomial used for the CRC is x^4+x+1 (ref. CCITT-G704).
  96:Src/aspep.c   ****   *
  97:Src/aspep.c   ****   *  The 28 input bits are split into 7 nibbles that are processed from the least significant to th
  98:Src/aspep.c   ****   * most significant one as follows:
  99:Src/aspep.c   ****   *
 100:Src/aspep.c   ****   *  - the least significant (4-bit) nibble is processed first as if it were the most significant p
 101:Src/aspep.c   ****   *    of the divident;
 102:Src/aspep.c   ****   *  - the order of bits in each nibble is unchanged for processing which would leads to the follow
 103:Src/aspep.c   ****   *    bit processing sequence: 3, 2, 1, 0, 7, 6, 5, 4, 11, 10, 9, 8, 15, 14, 13, 12, 19, 18, 17, 1
 104:Src/aspep.c   ****   *    23, 22, 21, 20, 27, 26, 25, 24.
 105:Src/aspep.c   ****   *
 106:Src/aspep.c   ****   *  Two lookup tables based implementations are proposed: one solely relying on a 16 entries looku
 107:Src/aspep.c   ****   * table and another one that also uses a 256 entries lookup table. This last one is the default. 
 108:Src/aspep.c   ****   * requires 256 more bytes than the first but is also roughly two times faster.
 109:Src/aspep.c   ****   *
 110:Src/aspep.c   ****   *  The 16 entries lookup table based implementation is enabled when the CRC4_PER_NIBBLE preproces
 111:Src/aspep.c   ****   * flag is defined.
 112:Src/aspep.c   ****   *
 113:Src/aspep.c   ****   *  Note that the default, 256 entries lookup table based implementation also uses the 16 entries 
 114:Src/aspep.c   ****   * table because the amount of input data is not a multiple of 8 bits.
 115:Src/aspep.c   ****   *
 116:Src/aspep.c   ****   * The resulting CRC is written in bits 28 to 31 of @p header and the whole header is returned.
 117:Src/aspep.c   ****   */
 118:Src/aspep.c   **** static void ASPEP_ComputeHeaderCRC(uint32_t *headerPtr)
 119:Src/aspep.c   **** {
ARM GAS  /tmp/cc0OBPYV.s 			page 6


 113              		.loc 1 119 1
 114              		.cfi_startproc
 115              		@ args = 0, pretend = 0, frame = 16
 116              		@ frame_needed = 1, uses_anonymous_args = 0
 117              		@ link register save eliminated.
 118 0000 80B4     		push	{r7}
 119              	.LCFI0:
 120              		.cfi_def_cfa_offset 4
 121              		.cfi_offset 7, -4
 122 0002 85B0     		sub	sp, sp, #20
 123              	.LCFI1:
 124              		.cfi_def_cfa_offset 24
 125 0004 00AF     		add	r7, sp, #0
 126              	.LCFI2:
 127              		.cfi_def_cfa_register 7
 128 0006 7860     		str	r0, [r7, #4]
 120:Src/aspep.c   ****   uint8_t crc = 0;
 129              		.loc 1 120 11
 130 0008 0023     		movs	r3, #0
 131 000a FB73     		strb	r3, [r7, #15]
 121:Src/aspep.c   ****   uint32_t header = *headerPtr;
 132              		.loc 1 121 12
 133 000c 7B68     		ldr	r3, [r7, #4]
 134 000e 1B68     		ldr	r3, [r3]
 135 0010 BB60     		str	r3, [r7, #8]
 122:Src/aspep.c   **** 
 123:Src/aspep.c   **** #ifndef CRC4_PER_NIBBLE
 124:Src/aspep.c   ****   header &= 0x0fffffffU;
 136              		.loc 1 124 10
 137 0012 BB68     		ldr	r3, [r7, #8]
 138 0014 23F07043 		bic	r3, r3, #-268435456
 139 0018 BB60     		str	r3, [r7, #8]
 125:Src/aspep.c   **** 
 126:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)(header         & 0xffU)];
 140              		.loc 1 126 28
 141 001a BB68     		ldr	r3, [r7, #8]
 142 001c DAB2     		uxtb	r2, r3
 143              		.loc 1 126 26
 144 001e FB7B     		ldrb	r3, [r7, #15]
 145 0020 5340     		eors	r3, r3, r2
 146 0022 DBB2     		uxtb	r3, r3
 147 0024 1A46     		mov	r2, r3
 148              		.loc 1 126 7
 149 0026 174B     		ldr	r3, .L2
 150 0028 9B5C     		ldrb	r3, [r3, r2]
 151 002a FB73     		strb	r3, [r7, #15]
 127:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 152              		.loc 1 127 46
 153 002c BB68     		ldr	r3, [r7, #8]
 154 002e 1B0A     		lsrs	r3, r3, #8
 155              		.loc 1 127 28
 156 0030 DAB2     		uxtb	r2, r3
 157              		.loc 1 127 26
 158 0032 FB7B     		ldrb	r3, [r7, #15]
 159 0034 5340     		eors	r3, r3, r2
 160 0036 DBB2     		uxtb	r3, r3
 161 0038 1A46     		mov	r2, r3
ARM GAS  /tmp/cc0OBPYV.s 			page 7


 162              		.loc 1 127 7
 163 003a 124B     		ldr	r3, .L2
 164 003c 9B5C     		ldrb	r3, [r3, r2]
 165 003e FB73     		strb	r3, [r7, #15]
 128:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 166              		.loc 1 128 46
 167 0040 BB68     		ldr	r3, [r7, #8]
 168 0042 1B0C     		lsrs	r3, r3, #16
 169              		.loc 1 128 28
 170 0044 DAB2     		uxtb	r2, r3
 171              		.loc 1 128 26
 172 0046 FB7B     		ldrb	r3, [r7, #15]
 173 0048 5340     		eors	r3, r3, r2
 174 004a DBB2     		uxtb	r3, r3
 175 004c 1A46     		mov	r2, r3
 176              		.loc 1 128 7
 177 004e 0D4B     		ldr	r3, .L2
 178 0050 9B5C     		ldrb	r3, [r3, r2]
 179 0052 FB73     		strb	r3, [r7, #15]
 129:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 180              		.loc 1 129 26
 181 0054 FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 182              		.loc 1 129 46
 183 0056 BB68     		ldr	r3, [r7, #8]
 184 0058 1B0E     		lsrs	r3, r3, #24
 185              		.loc 1 129 28
 186 005a DBB2     		uxtb	r3, r3
 187 005c 03F00F03 		and	r3, r3, #15
 188              		.loc 1 129 26
 189 0060 5340     		eors	r3, r3, r2
 190              		.loc 1 129 7
 191 0062 094A     		ldr	r2, .L2+4
 192 0064 D35C     		ldrb	r3, [r2, r3]
 193 0066 FB73     		strb	r3, [r7, #15]
 130:Src/aspep.c   **** #else /* CRC4_PER_NIBBLE */
 131:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)(header         & 0xfU)];
 132:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >>  4U) & 0xfU)];
 133:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >>  8U) & 0xfU)];
 134:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 12U) & 0xfU)];
 135:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 16U) & 0xfU)];
 136:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 20U) & 0xfU)];
 137:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0xfU)];
 138:Src/aspep.c   **** #endif /* CRC4_PER_NIBBLE */
 139:Src/aspep.c   **** 
 140:Src/aspep.c   ****   *headerPtr |= (uint32_t)crc << 28;
 194              		.loc 1 140 14
 195 0068 7B68     		ldr	r3, [r7, #4]
 196 006a 1A68     		ldr	r2, [r3]
 197              		.loc 1 140 17
 198 006c FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 199              		.loc 1 140 31
 200 006e 1B07     		lsls	r3, r3, #28
 201              		.loc 1 140 14
 202 0070 1A43     		orrs	r2, r2, r3
 203 0072 7B68     		ldr	r3, [r7, #4]
 204 0074 1A60     		str	r2, [r3]
 141:Src/aspep.c   **** 
ARM GAS  /tmp/cc0OBPYV.s 			page 8


 142:Src/aspep.c   **** }
 205              		.loc 1 142 1
 206 0076 00BF     		nop
 207 0078 1437     		adds	r7, r7, #20
 208              	.LCFI3:
 209              		.cfi_def_cfa_offset 4
 210 007a BD46     		mov	sp, r7
 211              	.LCFI4:
 212              		.cfi_def_cfa_register 13
 213              		@ sp needed
 214 007c 5DF8047B 		ldr	r7, [sp], #4
 215              	.LCFI5:
 216              		.cfi_restore 7
 217              		.cfi_def_cfa_offset 0
 218 0080 7047     		bx	lr
 219              	.L3:
 220 0082 00BF     		.align	2
 221              	.L2:
 222 0084 00000000 		.word	CRC4_Lookup8
 223 0088 00000000 		.word	CRC4_Lookup4
 224              		.cfi_endproc
 225              	.LFE1437:
 227              		.section	.text.ASPEP_CheckHeaderCRC,"ax",%progbits
 228              		.align	1
 229              		.syntax unified
 230              		.thumb
 231              		.thumb_func
 232              		.fpu fpv4-sp-d16
 234              	ASPEP_CheckHeaderCRC:
 235              	.LFB1438:
 143:Src/aspep.c   **** 
 144:Src/aspep.c   **** /**
 145:Src/aspep.c   ****   * @brief Checks if @p header contains a valid 4-bit CRC and return true if this is the case and f
 146:Src/aspep.c   ****   *
 147:Src/aspep.c   ****   *  The CRC is computed over the 32 bits of the @p header. If the result is 0, the CRC is consider
 148:Src/aspep.c   ****   * and true is returned. If the result is not 0, false is returned.
 149:Src/aspep.c   ****   *
 150:Src/aspep.c   ****   * @sa ASPEP_ComputeHeaderCRC
 151:Src/aspep.c   ****   */
 152:Src/aspep.c   **** static bool ASPEP_CheckHeaderCRC(uint32_t header)
 153:Src/aspep.c   **** {
 236              		.loc 1 153 1
 237              		.cfi_startproc
 238              		@ args = 0, pretend = 0, frame = 16
 239              		@ frame_needed = 1, uses_anonymous_args = 0
 240              		@ link register save eliminated.
 241 0000 80B4     		push	{r7}
 242              	.LCFI6:
 243              		.cfi_def_cfa_offset 4
 244              		.cfi_offset 7, -4
 245 0002 85B0     		sub	sp, sp, #20
 246              	.LCFI7:
 247              		.cfi_def_cfa_offset 24
 248 0004 00AF     		add	r7, sp, #0
 249              	.LCFI8:
 250              		.cfi_def_cfa_register 7
 251 0006 7860     		str	r0, [r7, #4]
ARM GAS  /tmp/cc0OBPYV.s 			page 9


 154:Src/aspep.c   ****   uint8_t crc = 0;
 252              		.loc 1 154 11
 253 0008 0023     		movs	r3, #0
 254 000a FB73     		strb	r3, [r7, #15]
 155:Src/aspep.c   **** 
 156:Src/aspep.c   **** #ifndef CRC4_PER_NIBBLE
 157:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)(header         & 0xffU)];
 255              		.loc 1 157 28
 256 000c 7B68     		ldr	r3, [r7, #4]
 257 000e DAB2     		uxtb	r2, r3
 258              		.loc 1 157 26
 259 0010 FB7B     		ldrb	r3, [r7, #15]
 260 0012 5340     		eors	r3, r3, r2
 261 0014 DBB2     		uxtb	r3, r3
 262 0016 1A46     		mov	r2, r3
 263              		.loc 1 157 7
 264 0018 164B     		ldr	r3, .L6
 265 001a 9B5C     		ldrb	r3, [r3, r2]
 266 001c FB73     		strb	r3, [r7, #15]
 158:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 267              		.loc 1 158 46
 268 001e 7B68     		ldr	r3, [r7, #4]
 269 0020 1B0A     		lsrs	r3, r3, #8
 270              		.loc 1 158 28
 271 0022 DAB2     		uxtb	r2, r3
 272              		.loc 1 158 26
 273 0024 FB7B     		ldrb	r3, [r7, #15]
 274 0026 5340     		eors	r3, r3, r2
 275 0028 DBB2     		uxtb	r3, r3
 276 002a 1A46     		mov	r2, r3
 277              		.loc 1 158 7
 278 002c 114B     		ldr	r3, .L6
 279 002e 9B5C     		ldrb	r3, [r3, r2]
 280 0030 FB73     		strb	r3, [r7, #15]
 159:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 281              		.loc 1 159 46
 282 0032 7B68     		ldr	r3, [r7, #4]
 283 0034 1B0C     		lsrs	r3, r3, #16
 284              		.loc 1 159 28
 285 0036 DAB2     		uxtb	r2, r3
 286              		.loc 1 159 26
 287 0038 FB7B     		ldrb	r3, [r7, #15]
 288 003a 5340     		eors	r3, r3, r2
 289 003c DBB2     		uxtb	r3, r3
 290 003e 1A46     		mov	r2, r3
 291              		.loc 1 159 7
 292 0040 0C4B     		ldr	r3, .L6
 293 0042 9B5C     		ldrb	r3, [r3, r2]
 294 0044 FB73     		strb	r3, [r7, #15]
 160:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 24U) & 0xffU)];
 295              		.loc 1 160 46
 296 0046 7B68     		ldr	r3, [r7, #4]
 297 0048 1B0E     		lsrs	r3, r3, #24
 298              		.loc 1 160 28
 299 004a DAB2     		uxtb	r2, r3
 300              		.loc 1 160 26
 301 004c FB7B     		ldrb	r3, [r7, #15]
ARM GAS  /tmp/cc0OBPYV.s 			page 10


 302 004e 5340     		eors	r3, r3, r2
 303 0050 DBB2     		uxtb	r3, r3
 304 0052 1A46     		mov	r2, r3
 305              		.loc 1 160 7
 306 0054 074B     		ldr	r3, .L6
 307 0056 9B5C     		ldrb	r3, [r3, r2]
 308 0058 FB73     		strb	r3, [r7, #15]
 161:Src/aspep.c   **** #else /* CRC4_PER_NIBBLE */
 162:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)(header         & 0xfU)];
 163:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >>  4U) & 0xfU)];
 164:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >>  8U) & 0xfU)];
 165:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 12U) & 0xfU)];
 166:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 16U) & 0xfU)];
 167:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 20U) & 0xfU)];
 168:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0xfU)];
 169:Src/aspep.c   ****   crc = crc ^ (uint8_t)((header >> 28) & 0xf);
 170:Src/aspep.c   **** #endif /* CRC4_PER_NIBBLE */
 171:Src/aspep.c   **** 
 172:Src/aspep.c   ****   return (crc == 0U);
 309              		.loc 1 172 15
 310 005a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 311 005c 002B     		cmp	r3, #0
 312 005e 0CBF     		ite	eq
 313 0060 0123     		moveq	r3, #1
 314 0062 0023     		movne	r3, #0
 315 0064 DBB2     		uxtb	r3, r3
 173:Src/aspep.c   **** }
 316              		.loc 1 173 1
 317 0066 1846     		mov	r0, r3
 318 0068 1437     		adds	r7, r7, #20
 319              	.LCFI9:
 320              		.cfi_def_cfa_offset 4
 321 006a BD46     		mov	sp, r7
 322              	.LCFI10:
 323              		.cfi_def_cfa_register 13
 324              		@ sp needed
 325 006c 5DF8047B 		ldr	r7, [sp], #4
 326              	.LCFI11:
 327              		.cfi_restore 7
 328              		.cfi_def_cfa_offset 0
 329 0070 7047     		bx	lr
 330              	.L7:
 331 0072 00BF     		.align	2
 332              	.L6:
 333 0074 00000000 		.word	CRC4_Lookup8
 334              		.cfi_endproc
 335              	.LFE1438:
 337              		.section	.text.ASPEP_start,"ax",%progbits
 338              		.align	1
 339              		.global	ASPEP_start
 340              		.syntax unified
 341              		.thumb
 342              		.thumb_func
 343              		.fpu fpv4-sp-d16
 345              	ASPEP_start:
 346              	.LFB1439:
 174:Src/aspep.c   **** 
ARM GAS  /tmp/cc0OBPYV.s 			page 11


 175:Src/aspep.c   **** /**
 176:Src/aspep.c   ****   * @brief  Starts ASPEP communication by configuring UART.
 177:Src/aspep.c   ****   *
 178:Src/aspep.c   ****   * @param  *pHandle Handler of the current instance of the ASPEP component
 179:Src/aspep.c   ****   */
 180:Src/aspep.c   **** void ASPEP_start(ASPEP_Handle_t *pHandle)
 181:Src/aspep.c   **** {
 347              		.loc 1 181 1
 348              		.cfi_startproc
 349              		@ args = 0, pretend = 0, frame = 8
 350              		@ frame_needed = 1, uses_anonymous_args = 0
 351 0000 80B5     		push	{r7, lr}
 352              	.LCFI12:
 353              		.cfi_def_cfa_offset 8
 354              		.cfi_offset 7, -8
 355              		.cfi_offset 14, -4
 356 0002 82B0     		sub	sp, sp, #8
 357              	.LCFI13:
 358              		.cfi_def_cfa_offset 16
 359 0004 00AF     		add	r7, sp, #0
 360              	.LCFI14:
 361              		.cfi_def_cfa_register 7
 362 0006 7860     		str	r0, [r7, #4]
 182:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 183:Src/aspep.c   ****   if (MC_NULL == pHandle)
 184:Src/aspep.c   ****   {
 185:Src/aspep.c   ****     /* Nothing to do */
 186:Src/aspep.c   ****   }
 187:Src/aspep.c   ****   else
 188:Src/aspep.c   ****   {
 189:Src/aspep.c   **** #endif
 190:Src/aspep.c   ****     pHandle->fASPEP_HWInit(pHandle->ASPEPIp);
 363              		.loc 1 190 12
 364 0008 7B68     		ldr	r3, [r7, #4]
 365 000a DB6C     		ldr	r3, [r3, #76]
 366              		.loc 1 190 5
 367 000c 7A68     		ldr	r2, [r7, #4]
 368 000e 5269     		ldr	r2, [r2, #20]
 369 0010 1046     		mov	r0, r2
 370 0012 9847     		blx	r3
 371              	.LVL0:
 191:Src/aspep.c   ****     pHandle->ASPEP_State = ASPEP_IDLE;
 372              		.loc 1 191 26
 373 0014 7B68     		ldr	r3, [r7, #4]
 374 0016 0022     		movs	r2, #0
 375 0018 83F86420 		strb	r2, [r3, #100]
 192:Src/aspep.c   ****     pHandle->ASPEP_TL_State = WAITING_PACKET;
 376              		.loc 1 192 29
 377 001c 7B68     		ldr	r3, [r7, #4]
 378 001e 0022     		movs	r2, #0
 379 0020 83F86520 		strb	r2, [r3, #101]
 193:Src/aspep.c   ****     pHandle->syncPacketCount = 0; /* Sync packet counter is reset only at startup*/
 380              		.loc 1 193 30
 381 0024 7B68     		ldr	r3, [r7, #4]
 382 0026 0022     		movs	r2, #0
 383 0028 83F86020 		strb	r2, [r3, #96]
 194:Src/aspep.c   ****     /* Configure UART to receive first packet*/
ARM GAS  /tmp/cc0OBPYV.s 			page 12


 195:Src/aspep.c   ****     pHandle->fASPEP_cfg_recept(pHandle->ASPEPIp, pHandle->rxHeader, ASPEP_HEADER_SIZE);
 384              		.loc 1 195 12
 385 002c 7B68     		ldr	r3, [r7, #4]
 386 002e 5B6D     		ldr	r3, [r3, #84]
 387              		.loc 1 195 5
 388 0030 7A68     		ldr	r2, [r7, #4]
 389 0032 5069     		ldr	r0, [r2, #20]
 390              		.loc 1 195 57
 391 0034 7A68     		ldr	r2, [r7, #4]
 392 0036 02F11C01 		add	r1, r2, #28
 393              		.loc 1 195 5
 394 003a 0422     		movs	r2, #4
 395 003c 9847     		blx	r3
 396              	.LVL1:
 196:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 197:Src/aspep.c   ****   }
 198:Src/aspep.c   **** #endif
 199:Src/aspep.c   **** }
 397              		.loc 1 199 1
 398 003e 00BF     		nop
 399 0040 0837     		adds	r7, r7, #8
 400              	.LCFI15:
 401              		.cfi_def_cfa_offset 8
 402 0042 BD46     		mov	sp, r7
 403              	.LCFI16:
 404              		.cfi_def_cfa_register 13
 405              		@ sp needed
 406 0044 80BD     		pop	{r7, pc}
 407              		.cfi_endproc
 408              	.LFE1439:
 410              		.section	.text.ASPEP_sendBeacon,"ax",%progbits
 411              		.align	1
 412              		.global	ASPEP_sendBeacon
 413              		.syntax unified
 414              		.thumb
 415              		.thumb_func
 416              		.fpu fpv4-sp-d16
 418              	ASPEP_sendBeacon:
 419              	.LFB1440:
 200:Src/aspep.c   **** 
 201:Src/aspep.c   **** /**
 202:Src/aspep.c   ****   * @brief  Sends BEACON to controller containing matched capabilities between controller and perfo
 203:Src/aspep.c   ****   *
 204:Src/aspep.c   ****   * @param  *pHandle Handler of the current instance of the ASPEP component
 205:Src/aspep.c   ****   * @param  *capabilities Matched capabilities between controller and performer
 206:Src/aspep.c   ****   */
 207:Src/aspep.c   **** void ASPEP_sendBeacon(ASPEP_Handle_t *pHandle, ASPEP_Capabilities_def *capabilities)
 208:Src/aspep.c   **** {
 420              		.loc 1 208 1
 421              		.cfi_startproc
 422              		@ args = 0, pretend = 0, frame = 16
 423              		@ frame_needed = 1, uses_anonymous_args = 0
 424 0000 80B5     		push	{r7, lr}
 425              	.LCFI17:
 426              		.cfi_def_cfa_offset 8
 427              		.cfi_offset 7, -8
 428              		.cfi_offset 14, -4
ARM GAS  /tmp/cc0OBPYV.s 			page 13


 429 0002 84B0     		sub	sp, sp, #16
 430              	.LCFI18:
 431              		.cfi_def_cfa_offset 24
 432 0004 00AF     		add	r7, sp, #0
 433              	.LCFI19:
 434              		.cfi_def_cfa_register 7
 435 0006 7860     		str	r0, [r7, #4]
 436 0008 3960     		str	r1, [r7]
 209:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 210:Src/aspep.c   ****   if ((MC_NULL == pHandle) || (NULL == capabilities))
 211:Src/aspep.c   ****   {
 212:Src/aspep.c   ****     /* Nothing to do */
 213:Src/aspep.c   ****   }
 214:Src/aspep.c   ****   else
 215:Src/aspep.c   ****   {
 216:Src/aspep.c   **** #endif
 217:Src/aspep.c   ****     uint32_t *packet = (uint32_t *)pHandle->ctrlBuffer.buffer; //cstat !MISRAC2012-Rule-11.3
 437              		.loc 1 217 15
 438 000a 7B68     		ldr	r3, [r7, #4]
 439 000c 2033     		adds	r3, r3, #32
 440 000e FB60     		str	r3, [r7, #12]
 218:Src/aspep.c   ****     *packet = (BEACON
 219:Src/aspep.c   ****              | (((uint32_t)capabilities->version) << 4U)
 441              		.loc 1 219 40
 442 0010 3B68     		ldr	r3, [r7]
 443 0012 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 444              		.loc 1 219 51
 445 0014 1A01     		lsls	r2, r3, #4
 220:Src/aspep.c   ****              | (((uint32_t)capabilities->DATA_CRC) << 7U)
 446              		.loc 1 220 40
 447 0016 3B68     		ldr	r3, [r7]
 448 0018 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 449              		.loc 1 220 52
 450 001a DB01     		lsls	r3, r3, #7
 451              		.loc 1 220 14
 452 001c 1A43     		orrs	r2, r2, r3
 221:Src/aspep.c   ****              | (((uint32_t)capabilities->RX_maxSize) << 8U)
 453              		.loc 1 221 40
 454 001e 3B68     		ldr	r3, [r7]
 455 0020 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 456              		.loc 1 221 54
 457 0022 1B02     		lsls	r3, r3, #8
 458              		.loc 1 221 14
 459 0024 1A43     		orrs	r2, r2, r3
 222:Src/aspep.c   ****              | (((uint32_t)capabilities->TXS_maxSize) << 14U)
 460              		.loc 1 222 40
 461 0026 3B68     		ldr	r3, [r7]
 462 0028 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 463              		.loc 1 222 55
 464 002a 9B03     		lsls	r3, r3, #14
 465              		.loc 1 222 14
 466 002c 1A43     		orrs	r2, r2, r3
 223:Src/aspep.c   ****              | (((uint32_t)capabilities->TXA_maxSize) << 21U));
 467              		.loc 1 223 40
 468 002e 3B68     		ldr	r3, [r7]
 469 0030 DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 470              		.loc 1 223 55
ARM GAS  /tmp/cc0OBPYV.s 			page 14


 471 0032 5B05     		lsls	r3, r3, #21
 472              		.loc 1 223 14
 473 0034 1343     		orrs	r3, r3, r2
 474 0036 43F00502 		orr	r2, r3, #5
 218:Src/aspep.c   ****              | (((uint32_t)capabilities->version) << 4U)
 475              		.loc 1 218 13
 476 003a FB68     		ldr	r3, [r7, #12]
 477 003c 1A60     		str	r2, [r3]
 224:Src/aspep.c   **** 
 225:Src/aspep.c   ****     (void)ASPEP_TXframeProcess(pHandle, ASPEP_CTRL, &pHandle->ctrlBuffer, ASPEP_CTRL_SIZE);
 478              		.loc 1 225 53
 479 003e 7B68     		ldr	r3, [r7, #4]
 480 0040 03F12002 		add	r2, r3, #32
 481              		.loc 1 225 11
 482 0044 0423     		movs	r3, #4
 483 0046 0021     		movs	r1, #0
 484 0048 7868     		ldr	r0, [r7, #4]
 485 004a FFF7FEFF 		bl	ASPEP_TXframeProcess
 226:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 227:Src/aspep.c   ****   }
 228:Src/aspep.c   **** #endif
 229:Src/aspep.c   **** }
 486              		.loc 1 229 1
 487 004e 00BF     		nop
 488 0050 1037     		adds	r7, r7, #16
 489              	.LCFI20:
 490              		.cfi_def_cfa_offset 8
 491 0052 BD46     		mov	sp, r7
 492              	.LCFI21:
 493              		.cfi_def_cfa_register 13
 494              		@ sp needed
 495 0054 80BD     		pop	{r7, pc}
 496              		.cfi_endproc
 497              	.LFE1440:
 499              		.section	.text.ASPEP_sendNack,"ax",%progbits
 500              		.align	1
 501              		.syntax unified
 502              		.thumb
 503              		.thumb_func
 504              		.fpu fpv4-sp-d16
 506              	ASPEP_sendNack:
 507              	.LFB1441:
 230:Src/aspep.c   **** 
 231:Src/aspep.c   **** /**
 232:Src/aspep.c   ****   * @brief  Sends back to controller a NOT_ACKNOWLEDGED message.
 233:Src/aspep.c   ****   *
 234:Src/aspep.c   ****   * @param  *pHandle Handler of the current instance of the ASPEP component
 235:Src/aspep.c   ****   * @param  errorInfo Information on the encountered error
 236:Src/aspep.c   ****   */
 237:Src/aspep.c   **** static void ASPEP_sendNack(ASPEP_Handle_t *pHandle, uint8_t errorInfo)
 238:Src/aspep.c   **** {
 508              		.loc 1 238 1
 509              		.cfi_startproc
 510              		@ args = 0, pretend = 0, frame = 16
 511              		@ frame_needed = 1, uses_anonymous_args = 0
 512 0000 80B5     		push	{r7, lr}
 513              	.LCFI22:
ARM GAS  /tmp/cc0OBPYV.s 			page 15


 514              		.cfi_def_cfa_offset 8
 515              		.cfi_offset 7, -8
 516              		.cfi_offset 14, -4
 517 0002 84B0     		sub	sp, sp, #16
 518              	.LCFI23:
 519              		.cfi_def_cfa_offset 24
 520 0004 00AF     		add	r7, sp, #0
 521              	.LCFI24:
 522              		.cfi_def_cfa_register 7
 523 0006 7860     		str	r0, [r7, #4]
 524 0008 0B46     		mov	r3, r1
 525 000a FB70     		strb	r3, [r7, #3]
 239:Src/aspep.c   ****   uint32_t *packet = (uint32_t *)pHandle->ctrlBuffer.buffer; //cstat !MISRAC2012-Rule-11.3
 526              		.loc 1 239 13
 527 000c 7B68     		ldr	r3, [r7, #4]
 528 000e 2033     		adds	r3, r3, #32
 529 0010 FB60     		str	r3, [r7, #12]
 240:Src/aspep.c   ****   *packet = NACK | (uint32_t)(((uint32_t) errorInfo) << 8U) | (uint32_t)(((uint32_t) errorInfo) << 
 530              		.loc 1 240 32
 531 0012 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 532              		.loc 1 240 20
 533 0014 1A02     		lsls	r2, r3, #8
 534              		.loc 1 240 75
 535 0016 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 536              		.loc 1 240 63
 537 0018 1B04     		lsls	r3, r3, #16
 538              		.loc 1 240 61
 539 001a 1343     		orrs	r3, r3, r2
 540 001c 43F00F02 		orr	r2, r3, #15
 541              		.loc 1 240 11
 542 0020 FB68     		ldr	r3, [r7, #12]
 543 0022 1A60     		str	r2, [r3]
 241:Src/aspep.c   ****   (void)ASPEP_TXframeProcess(pHandle, ASPEP_CTRL, &pHandle->ctrlBuffer, ASPEP_CTRL_SIZE);
 544              		.loc 1 241 51
 545 0024 7B68     		ldr	r3, [r7, #4]
 546 0026 03F12002 		add	r2, r3, #32
 547              		.loc 1 241 9
 548 002a 0423     		movs	r3, #4
 549 002c 0021     		movs	r1, #0
 550 002e 7868     		ldr	r0, [r7, #4]
 551 0030 FFF7FEFF 		bl	ASPEP_TXframeProcess
 242:Src/aspep.c   **** }
 552              		.loc 1 242 1
 553 0034 00BF     		nop
 554 0036 1037     		adds	r7, r7, #16
 555              	.LCFI25:
 556              		.cfi_def_cfa_offset 8
 557 0038 BD46     		mov	sp, r7
 558              	.LCFI26:
 559              		.cfi_def_cfa_register 13
 560              		@ sp needed
 561 003a 80BD     		pop	{r7, pc}
 562              		.cfi_endproc
 563              	.LFE1441:
 565              		.section	.text.ASPEP_sendPing,"ax",%progbits
 566              		.align	1
 567              		.global	ASPEP_sendPing
ARM GAS  /tmp/cc0OBPYV.s 			page 16


 568              		.syntax unified
 569              		.thumb
 570              		.thumb_func
 571              		.fpu fpv4-sp-d16
 573              	ASPEP_sendPing:
 574              	.LFB1442:
 243:Src/aspep.c   **** 
 244:Src/aspep.c   **** /**
 245:Src/aspep.c   ****   * @brief  Sends back ping to controller once connection has been established.
 246:Src/aspep.c   ****   *
 247:Src/aspep.c   ****   * @param  *pHandle Handler of the current instance of the ASPEP component
 248:Src/aspep.c   ****   * @param  cBit Set to 1 if Performer has not been reset during communication
 249:Src/aspep.c   ****   * @param  packetNumber Number of requested packet incremented throughout the entire communication
 250:Src/aspep.c   ****   */
 251:Src/aspep.c   **** void ASPEP_sendPing(ASPEP_Handle_t *pHandle, uint8_t cBit, uint16_t packetNumber)
 252:Src/aspep.c   **** {
 575              		.loc 1 252 1
 576              		.cfi_startproc
 577              		@ args = 0, pretend = 0, frame = 16
 578              		@ frame_needed = 1, uses_anonymous_args = 0
 579 0000 80B5     		push	{r7, lr}
 580              	.LCFI27:
 581              		.cfi_def_cfa_offset 8
 582              		.cfi_offset 7, -8
 583              		.cfi_offset 14, -4
 584 0002 84B0     		sub	sp, sp, #16
 585              	.LCFI28:
 586              		.cfi_def_cfa_offset 24
 587 0004 00AF     		add	r7, sp, #0
 588              	.LCFI29:
 589              		.cfi_def_cfa_register 7
 590 0006 7860     		str	r0, [r7, #4]
 591 0008 0B46     		mov	r3, r1
 592 000a FB70     		strb	r3, [r7, #3]
 593 000c 1346     		mov	r3, r2	@ movhi
 594 000e 3B80     		strh	r3, [r7]	@ movhi
 253:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 254:Src/aspep.c   ****   if (MC_NULL == pHandle)
 255:Src/aspep.c   ****   {
 256:Src/aspep.c   ****     /* Nothing to do */
 257:Src/aspep.c   ****   }
 258:Src/aspep.c   ****   else
 259:Src/aspep.c   ****   {
 260:Src/aspep.c   **** #endif
 261:Src/aspep.c   ****     uint32_t *packet = (uint32_t *)pHandle->ctrlBuffer.buffer; //cstat !MISRAC2012-Rule-11.3
 595              		.loc 1 261 15
 596 0010 7B68     		ldr	r3, [r7, #4]
 597 0012 2033     		adds	r3, r3, #32
 598 0014 FB60     		str	r3, [r7, #12]
 262:Src/aspep.c   ****     uint8_t Nbit = pHandle->syncPacketCount & 0x1U; /* Keep only LSB */
 599              		.loc 1 262 27
 600 0016 7B68     		ldr	r3, [r7, #4]
 601 0018 93F86030 		ldrb	r3, [r3, #96]	@ zero_extendqisi2
 602              		.loc 1 262 13
 603 001c 03F00103 		and	r3, r3, #1
 604 0020 FB72     		strb	r3, [r7, #11]
 263:Src/aspep.c   ****     uint8_t ipID = pHandle->liid & 0xFU;
ARM GAS  /tmp/cc0OBPYV.s 			page 17


 605              		.loc 1 263 27
 606 0022 7B68     		ldr	r3, [r7, #4]
 607 0024 93F86330 		ldrb	r3, [r3, #99]	@ zero_extendqisi2
 608              		.loc 1 263 13
 609 0028 03F00F03 		and	r3, r3, #15
 610 002c BB72     		strb	r3, [r7, #10]
 264:Src/aspep.c   ****     *packet = PING | (uint32_t)((uint32_t)cBit << 4U)
 611              		.loc 1 264 33
 612 002e FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 613              		.loc 1 264 22
 614 0030 1A01     		lsls	r2, r3, #4
 265:Src/aspep.c   ****                    | (uint32_t)((uint32_t)cBit << 5U)
 615              		.loc 1 265 33
 616 0032 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 617              		.loc 1 265 22
 618 0034 5B01     		lsls	r3, r3, #5
 619              		.loc 1 265 20
 620 0036 1A43     		orrs	r2, r2, r3
 266:Src/aspep.c   ****                    | (uint32_t)((uint32_t)Nbit << 6U)
 621              		.loc 1 266 33
 622 0038 FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 623              		.loc 1 266 22
 624 003a 9B01     		lsls	r3, r3, #6
 625              		.loc 1 266 20
 626 003c 1A43     		orrs	r2, r2, r3
 267:Src/aspep.c   ****                    | (uint32_t)((uint32_t)Nbit << 7U)
 627              		.loc 1 267 33
 628 003e FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 629              		.loc 1 267 22
 630 0040 DB01     		lsls	r3, r3, #7
 631              		.loc 1 267 20
 632 0042 1A43     		orrs	r2, r2, r3
 268:Src/aspep.c   ****                    | (uint32_t)((uint32_t)ipID << 8U)
 633              		.loc 1 268 33
 634 0044 BB7A     		ldrb	r3, [r7, #10]	@ zero_extendqisi2
 635              		.loc 1 268 22
 636 0046 1B02     		lsls	r3, r3, #8
 637              		.loc 1 268 20
 638 0048 1A43     		orrs	r2, r2, r3
 269:Src/aspep.c   ****                    | (uint32_t)(((uint32_t) packetNumber) << 12U);
 639              		.loc 1 269 34
 640 004a 3B88     		ldrh	r3, [r7]
 641              		.loc 1 269 22
 642 004c 1B03     		lsls	r3, r3, #12
 643              		.loc 1 269 20
 644 004e 1343     		orrs	r3, r3, r2
 645 0050 43F00602 		orr	r2, r3, #6
 264:Src/aspep.c   ****                    | (uint32_t)((uint32_t)cBit << 5U)
 646              		.loc 1 264 13
 647 0054 FB68     		ldr	r3, [r7, #12]
 648 0056 1A60     		str	r2, [r3]
 270:Src/aspep.c   ****     (void)ASPEP_TXframeProcess(pHandle, ASPEP_CTRL, &pHandle->ctrlBuffer, ASPEP_CTRL_SIZE);
 649              		.loc 1 270 53
 650 0058 7B68     		ldr	r3, [r7, #4]
 651 005a 03F12002 		add	r2, r3, #32
 652              		.loc 1 270 11
 653 005e 0423     		movs	r3, #4
ARM GAS  /tmp/cc0OBPYV.s 			page 18


 654 0060 0021     		movs	r1, #0
 655 0062 7868     		ldr	r0, [r7, #4]
 656 0064 FFF7FEFF 		bl	ASPEP_TXframeProcess
 271:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 272:Src/aspep.c   ****   }
 273:Src/aspep.c   **** #endif
 274:Src/aspep.c   **** }
 657              		.loc 1 274 1
 658 0068 00BF     		nop
 659 006a 1037     		adds	r7, r7, #16
 660              	.LCFI30:
 661              		.cfi_def_cfa_offset 8
 662 006c BD46     		mov	sp, r7
 663              	.LCFI31:
 664              		.cfi_def_cfa_register 13
 665              		@ sp needed
 666 006e 80BD     		pop	{r7, pc}
 667              		.cfi_endproc
 668              	.LFE1442:
 670              		.section	.text.ASPEP_getBuffer,"ax",%progbits
 671              		.align	1
 672              		.global	ASPEP_getBuffer
 673              		.syntax unified
 674              		.thumb
 675              		.thumb_func
 676              		.fpu fpv4-sp-d16
 678              	ASPEP_getBuffer:
 679              	.LFB1443:
 275:Src/aspep.c   **** 
 276:Src/aspep.c   **** /**
 277:Src/aspep.c   ****   * @brief  Assigns new buffer depending on buffer type request and prevents overwriting.
 278:Src/aspep.c   ****   *
 279:Src/aspep.c   ****   * @param  *pSupHandle Handler of the current instance of the MCTL component
 280:Src/aspep.c   ****   * @param  **buffer Pointer to the buffer to be assigned
 281:Src/aspep.c   ****   * @param  syncAsync Type of requested buffer, can be synchronous or asynchronous
 282:Src/aspep.c   ****   *
 283:Src/aspep.c   ****   * @return Returns true if there is a writable buffer. False otherwise.
 284:Src/aspep.c   ****   */
 285:Src/aspep.c   **** bool ASPEP_getBuffer(MCTL_Handle_t *pSupHandle, void **buffer,  uint8_t syncAsync)
 286:Src/aspep.c   **** {
 680              		.loc 1 286 1
 681              		.cfi_startproc
 682              		@ args = 0, pretend = 0, frame = 24
 683              		@ frame_needed = 1, uses_anonymous_args = 0
 684              		@ link register save eliminated.
 685 0000 80B4     		push	{r7}
 686              	.LCFI32:
 687              		.cfi_def_cfa_offset 4
 688              		.cfi_offset 7, -4
 689 0002 87B0     		sub	sp, sp, #28
 690              	.LCFI33:
 691              		.cfi_def_cfa_offset 32
 692 0004 00AF     		add	r7, sp, #0
 693              	.LCFI34:
 694              		.cfi_def_cfa_register 7
 695 0006 F860     		str	r0, [r7, #12]
 696 0008 B960     		str	r1, [r7, #8]
ARM GAS  /tmp/cc0OBPYV.s 			page 19


 697 000a 1346     		mov	r3, r2
 698 000c FB71     		strb	r3, [r7, #7]
 287:Src/aspep.c   ****   bool result = true;
 699              		.loc 1 287 8
 700 000e 0123     		movs	r3, #1
 701 0010 FB75     		strb	r3, [r7, #23]
 288:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 289:Src/aspep.c   ****   if (MC_NULL == buffer)
 290:Src/aspep.c   ****   {
 291:Src/aspep.c   ****     result = false;
 292:Src/aspep.c   ****   }
 293:Src/aspep.c   ****   else
 294:Src/aspep.c   ****   {
 295:Src/aspep.c   **** #endif
 296:Src/aspep.c   ****     ASPEP_Handle_t *pHandle = (ASPEP_Handle_t *)pSupHandle; //cstat !MISRAC2012-Rule-11.3
 702              		.loc 1 296 21
 703 0012 FB68     		ldr	r3, [r7, #12]
 704 0014 3B61     		str	r3, [r7, #16]
 297:Src/aspep.c   **** 
 298:Src/aspep.c   ****     if (MCTL_SYNC == syncAsync)
 705              		.loc 1 298 8
 706 0016 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 707 0018 0A2B     		cmp	r3, #10
 708 001a 11D1     		bne	.L13
 299:Src/aspep.c   ****     {
 300:Src/aspep.c   ****       if (pHandle->syncBuffer.state <= writeLock) /* Possible values are free or writeLock*/
 709              		.loc 1 300 30
 710 001c 3B69     		ldr	r3, [r7, #16]
 711 001e 93F82E30 		ldrb	r3, [r3, #46]	@ zero_extendqisi2
 712              		.loc 1 300 10
 713 0022 012B     		cmp	r3, #1
 714 0024 09D8     		bhi	.L14
 301:Src/aspep.c   ****       {
 302:Src/aspep.c   ****         *buffer = &pHandle->syncBuffer.buffer[ASPEP_HEADER_SIZE];
 715              		.loc 1 302 39
 716 0026 3B69     		ldr	r3, [r7, #16]
 717 0028 9B6A     		ldr	r3, [r3, #40]
 718              		.loc 1 302 19
 719 002a 1A1D     		adds	r2, r3, #4
 720              		.loc 1 302 17
 721 002c BB68     		ldr	r3, [r7, #8]
 722 002e 1A60     		str	r2, [r3]
 303:Src/aspep.c   ****         pHandle->syncBuffer.state = writeLock;
 723              		.loc 1 303 35
 724 0030 3B69     		ldr	r3, [r7, #16]
 725 0032 0122     		movs	r2, #1
 726 0034 83F82E20 		strb	r2, [r3, #46]
 727 0038 36E0     		b	.L15
 728              	.L14:
 304:Src/aspep.c   ****       }
 305:Src/aspep.c   ****       else
 306:Src/aspep.c   ****       {
 307:Src/aspep.c   ****         result = false;
 729              		.loc 1 307 16
 730 003a 0023     		movs	r3, #0
 731 003c FB75     		strb	r3, [r7, #23]
 732 003e 33E0     		b	.L15
ARM GAS  /tmp/cc0OBPYV.s 			page 20


 733              	.L13:
 308:Src/aspep.c   ****       }
 309:Src/aspep.c   ****     }
 310:Src/aspep.c   ****     else /* Asynchronous buffer request */
 311:Src/aspep.c   ****     {
 312:Src/aspep.c   ****       if ((pHandle->asyncBufferA.state > writeLock) && (pHandle->asyncBufferB.state > writeLock))
 734              		.loc 1 312 33
 735 0040 3B69     		ldr	r3, [r7, #16]
 736 0042 93F83630 		ldrb	r3, [r3, #54]	@ zero_extendqisi2
 737              		.loc 1 312 10
 738 0046 012B     		cmp	r3, #1
 739 0048 07D9     		bls	.L16
 740              		.loc 1 312 78 discriminator 1
 741 004a 3B69     		ldr	r3, [r7, #16]
 742 004c 93F83E30 		ldrb	r3, [r3, #62]	@ zero_extendqisi2
 743              		.loc 1 312 53 discriminator 1
 744 0050 012B     		cmp	r3, #1
 745 0052 02D9     		bls	.L16
 313:Src/aspep.c   ****       {
 314:Src/aspep.c   ****         result = false;
 746              		.loc 1 314 16
 747 0054 0023     		movs	r3, #0
 748 0056 FB75     		strb	r3, [r7, #23]
 749 0058 26E0     		b	.L15
 750              	.L16:
 315:Src/aspep.c   ****       }
 316:Src/aspep.c   ****       else
 317:Src/aspep.c   ****       {
 318:Src/aspep.c   ****         if (pHandle->asyncBufferA.state <= writeLock)
 751              		.loc 1 318 34
 752 005a 3B69     		ldr	r3, [r7, #16]
 753 005c 93F83630 		ldrb	r3, [r3, #54]	@ zero_extendqisi2
 754              		.loc 1 318 12
 755 0060 012B     		cmp	r3, #1
 756 0062 0ED8     		bhi	.L17
 319:Src/aspep.c   ****         {
 320:Src/aspep.c   ****           pHandle->asyncBufferA.state = writeLock;
 757              		.loc 1 320 39
 758 0064 3B69     		ldr	r3, [r7, #16]
 759 0066 0122     		movs	r2, #1
 760 0068 83F83620 		strb	r2, [r3, #54]
 321:Src/aspep.c   ****           pHandle->lastRequestedAsyncBuff = &pHandle->asyncBufferA;
 761              		.loc 1 321 45
 762 006c 3B69     		ldr	r3, [r7, #16]
 763 006e 03F13002 		add	r2, r3, #48
 764              		.loc 1 321 43
 765 0072 3B69     		ldr	r3, [r7, #16]
 766 0074 1A64     		str	r2, [r3, #64]
 322:Src/aspep.c   ****           *buffer = &pHandle->asyncBufferA.buffer[ASPEP_HEADER_SIZE];
 767              		.loc 1 322 43
 768 0076 3B69     		ldr	r3, [r7, #16]
 769 0078 1B6B     		ldr	r3, [r3, #48]
 770              		.loc 1 322 21
 771 007a 1A1D     		adds	r2, r3, #4
 772              		.loc 1 322 19
 773 007c BB68     		ldr	r3, [r7, #8]
 774 007e 1A60     		str	r2, [r3]
ARM GAS  /tmp/cc0OBPYV.s 			page 21


 775 0080 12E0     		b	.L15
 776              	.L17:
 323:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 324:Src/aspep.c   ****           pHandle->asyncBufferA.RequestedNumber++;
 325:Src/aspep.c   **** #endif
 326:Src/aspep.c   ****         }
 327:Src/aspep.c   ****         else if (pHandle->asyncBufferB.state <= writeLock)
 777              		.loc 1 327 39
 778 0082 3B69     		ldr	r3, [r7, #16]
 779 0084 93F83E30 		ldrb	r3, [r3, #62]	@ zero_extendqisi2
 780              		.loc 1 327 17
 781 0088 012B     		cmp	r3, #1
 782 008a 0DD8     		bhi	.L15
 328:Src/aspep.c   ****         {
 329:Src/aspep.c   ****           pHandle->asyncBufferB.state = writeLock;
 783              		.loc 1 329 39
 784 008c 3B69     		ldr	r3, [r7, #16]
 785 008e 0122     		movs	r2, #1
 786 0090 83F83E20 		strb	r2, [r3, #62]
 330:Src/aspep.c   ****           pHandle->lastRequestedAsyncBuff = &pHandle->asyncBufferB;
 787              		.loc 1 330 45
 788 0094 3B69     		ldr	r3, [r7, #16]
 789 0096 03F13802 		add	r2, r3, #56
 790              		.loc 1 330 43
 791 009a 3B69     		ldr	r3, [r7, #16]
 792 009c 1A64     		str	r2, [r3, #64]
 331:Src/aspep.c   ****           *buffer = &pHandle->asyncBufferB.buffer[ASPEP_HEADER_SIZE];
 793              		.loc 1 331 43
 794 009e 3B69     		ldr	r3, [r7, #16]
 795 00a0 9B6B     		ldr	r3, [r3, #56]
 796              		.loc 1 331 21
 797 00a2 1A1D     		adds	r2, r3, #4
 798              		.loc 1 331 19
 799 00a4 BB68     		ldr	r3, [r7, #8]
 800 00a6 1A60     		str	r2, [r3]
 801              	.L15:
 332:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 333:Src/aspep.c   ****           pHandle->asyncBufferB.RequestedNumber++;
 334:Src/aspep.c   **** #endif
 335:Src/aspep.c   ****         }
 336:Src/aspep.c   ****         else
 337:Src/aspep.c   ****         {
 338:Src/aspep.c   ****           /* Nothing to do */
 339:Src/aspep.c   ****         }
 340:Src/aspep.c   ****       }
 341:Src/aspep.c   ****     }
 342:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 343:Src/aspep.c   ****   }
 344:Src/aspep.c   **** #endif
 345:Src/aspep.c   ****   return (result);
 802              		.loc 1 345 10
 803 00a8 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 346:Src/aspep.c   **** }
 804              		.loc 1 346 1
 805 00aa 1846     		mov	r0, r3
 806 00ac 1C37     		adds	r7, r7, #28
 807              	.LCFI35:
ARM GAS  /tmp/cc0OBPYV.s 			page 22


 808              		.cfi_def_cfa_offset 4
 809 00ae BD46     		mov	sp, r7
 810              	.LCFI36:
 811              		.cfi_def_cfa_register 13
 812              		@ sp needed
 813 00b0 5DF8047B 		ldr	r7, [sp], #4
 814              	.LCFI37:
 815              		.cfi_restore 7
 816              		.cfi_def_cfa_offset 0
 817 00b4 7047     		bx	lr
 818              		.cfi_endproc
 819              	.LFE1443:
 821              		.section	.text.ASPEP_CheckBeacon,"ax",%progbits
 822              		.align	1
 823              		.syntax unified
 824              		.thumb
 825              		.thumb_func
 826              		.fpu fpv4-sp-d16
 828              	ASPEP_CheckBeacon:
 829              	.LFB1444:
 347:Src/aspep.c   **** 
 348:Src/aspep.c   **** /**
 349:Src/aspep.c   ****   * @brief  Checks controller's capabilities and compare them to performer's capabilities.
 350:Src/aspep.c   ****   *
 351:Src/aspep.c   ****   * @param  *pHandle Handler of the current instance of the ASPEP component
 352:Src/aspep.c   ****   *
 353:Src/aspep.c   ****   * @return Returns true if controller's capabilities match performer's one. False otherwise.
 354:Src/aspep.c   ****   */
 355:Src/aspep.c   **** bool ASPEP_CheckBeacon (ASPEP_Handle_t *pHandle)
 356:Src/aspep.c   **** {
 830              		.loc 1 356 1
 831              		.cfi_startproc
 832              		@ args = 0, pretend = 0, frame = 24
 833              		@ frame_needed = 1, uses_anonymous_args = 0
 834              		@ link register save eliminated.
 835 0000 80B4     		push	{r7}
 836              	.LCFI38:
 837              		.cfi_def_cfa_offset 4
 838              		.cfi_offset 7, -4
 839 0002 87B0     		sub	sp, sp, #28
 840              	.LCFI39:
 841              		.cfi_def_cfa_offset 32
 842 0004 00AF     		add	r7, sp, #0
 843              	.LCFI40:
 844              		.cfi_def_cfa_register 7
 845 0006 7860     		str	r0, [r7, #4]
 357:Src/aspep.c   ****   bool result = true;
 846              		.loc 1 357 8
 847 0008 0123     		movs	r3, #1
 848 000a FB75     		strb	r3, [r7, #23]
 358:Src/aspep.c   **** 
 359:Src/aspep.c   ****   uint32_t packetHeader = *((uint32_t *)pHandle->rxHeader); //cstat !MISRAC2012-Rule-11.3
 849              		.loc 1 359 41
 850 000c 7B68     		ldr	r3, [r7, #4]
 851 000e 1C33     		adds	r3, r3, #28
 852              		.loc 1 359 12
 853 0010 1B68     		ldr	r3, [r3]
ARM GAS  /tmp/cc0OBPYV.s 			page 23


 854 0012 3B61     		str	r3, [r7, #16]
 360:Src/aspep.c   ****   ASPEP_Capabilities_def MasterCapabilities;
 361:Src/aspep.c   ****   MasterCapabilities.version = (uint8_t)((packetHeader &0x70U)>> 4U);           /*Bits 4 to 6*/
 855              		.loc 1 361 63
 856 0014 3B69     		ldr	r3, [r7, #16]
 857 0016 1B09     		lsrs	r3, r3, #4
 858              		.loc 1 361 32
 859 0018 DBB2     		uxtb	r3, r3
 860 001a 03F00703 		and	r3, r3, #7
 861 001e DBB2     		uxtb	r3, r3
 862              		.loc 1 361 30
 863 0020 3B73     		strb	r3, [r7, #12]
 362:Src/aspep.c   ****   MasterCapabilities.DATA_CRC = pHandle->rxHeader[0] >> 7U ;                     /*Bit 7 */
 864              		.loc 1 362 50
 865 0022 7B68     		ldr	r3, [r7, #4]
 866 0024 1B7F     		ldrb	r3, [r3, #28]	@ zero_extendqisi2
 867              		.loc 1 362 31
 868 0026 DB09     		lsrs	r3, r3, #7
 869 0028 DBB2     		uxtb	r3, r3
 870 002a 3B72     		strb	r3, [r7, #8]
 363:Src/aspep.c   ****   MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 871              		.loc 1 363 52
 872 002c 7B68     		ldr	r3, [r7, #4]
 873 002e 5B7F     		ldrb	r3, [r3, #29]	@ zero_extendqisi2
 874              		.loc 1 363 56
 875 0030 03F03F03 		and	r3, r3, #63
 876 0034 DBB2     		uxtb	r3, r3
 877              		.loc 1 363 33
 878 0036 7B72     		strb	r3, [r7, #9]
 364:Src/aspep.c   ****   MasterCapabilities.TXS_maxSize = (uint8_t)((packetHeader&0x01FC000U)  >> 14); /*Bits 14 to 20 */
 879              		.loc 1 364 73
 880 0038 3B69     		ldr	r3, [r7, #16]
 881 003a 9B0B     		lsrs	r3, r3, #14
 882              		.loc 1 364 36
 883 003c DBB2     		uxtb	r3, r3
 884 003e 03F07F03 		and	r3, r3, #127
 885 0042 DBB2     		uxtb	r3, r3
 886              		.loc 1 364 34
 887 0044 BB72     		strb	r3, [r7, #10]
 365:Src/aspep.c   ****   MasterCapabilities.TXA_maxSize = (uint8_t)((packetHeader&0xFE00000U) >> 21);  /*Bits 21 to 27  */
 888              		.loc 1 365 72
 889 0046 3B69     		ldr	r3, [r7, #16]
 890 0048 5B0D     		lsrs	r3, r3, #21
 891              		.loc 1 365 36
 892 004a DBB2     		uxtb	r3, r3
 893 004c 03F07F03 		and	r3, r3, #127
 894 0050 DBB2     		uxtb	r3, r3
 895              		.loc 1 365 34
 896 0052 FB72     		strb	r3, [r7, #11]
 366:Src/aspep.c   **** 
 367:Src/aspep.c   ****   pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC)
 897              		.loc 1 367 36
 898 0054 3A7A     		ldrb	r2, [r7, #8]	@ zero_extendqisi2
 899 0056 7B68     		ldr	r3, [r7, #4]
 900 0058 93F86C30 		ldrb	r3, [r3, #108]	@ zero_extendqisi2
 901 005c 9342     		cmp	r3, r2
 902 005e 28BF     		it	cs
ARM GAS  /tmp/cc0OBPYV.s 			page 24


 903 0060 1346     		movcs	r3, r2
 904 0062 DAB2     		uxtb	r2, r3
 905              		.loc 1 367 34
 906 0064 7B68     		ldr	r3, [r7, #4]
 907 0066 83F86C20 		strb	r2, [r3, #108]
 368:Src/aspep.c   ****   pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_ma
 908              		.loc 1 368 38
 909 006a 7A7A     		ldrb	r2, [r7, #9]	@ zero_extendqisi2
 910 006c 7B68     		ldr	r3, [r7, #4]
 911 006e 93F86D30 		ldrb	r3, [r3, #109]	@ zero_extendqisi2
 912 0072 9342     		cmp	r3, r2
 913 0074 28BF     		it	cs
 914 0076 1346     		movcs	r3, r2
 915 0078 DAB2     		uxtb	r2, r3
 916              		.loc 1 368 36
 917 007a 7B68     		ldr	r3, [r7, #4]
 918 007c 83F86D20 		strb	r2, [r3, #109]
 369:Src/aspep.c   ****   pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS
 919              		.loc 1 369 39
 920 0080 BA7A     		ldrb	r2, [r7, #10]	@ zero_extendqisi2
 921 0082 7B68     		ldr	r3, [r7, #4]
 922 0084 93F86E30 		ldrb	r3, [r3, #110]	@ zero_extendqisi2
 923 0088 9342     		cmp	r3, r2
 924 008a 28BF     		it	cs
 925 008c 1346     		movcs	r3, r2
 926 008e DAB2     		uxtb	r2, r3
 927              		.loc 1 369 37
 928 0090 7B68     		ldr	r3, [r7, #4]
 929 0092 83F86E20 		strb	r2, [r3, #110]
 370:Src/aspep.c   ****   pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA
 930              		.loc 1 370 39
 931 0096 FA7A     		ldrb	r2, [r7, #11]	@ zero_extendqisi2
 932 0098 7B68     		ldr	r3, [r7, #4]
 933 009a 93F86F30 		ldrb	r3, [r3, #111]	@ zero_extendqisi2
 934 009e 9342     		cmp	r3, r2
 935 00a0 28BF     		it	cs
 936 00a2 1346     		movcs	r3, r2
 937 00a4 DAB2     		uxtb	r2, r3
 938              		.loc 1 370 37
 939 00a6 7B68     		ldr	r3, [r7, #4]
 940 00a8 83F86F20 		strb	r2, [r3, #111]
 371:Src/aspep.c   **** 
 372:Src/aspep.c   ****   if ((MasterCapabilities.DATA_CRC != pHandle->Capabilities.DATA_CRC)
 941              		.loc 1 372 26
 942 00ac 3A7A     		ldrb	r2, [r7, #8]	@ zero_extendqisi2
 943              		.loc 1 372 60
 944 00ae 7B68     		ldr	r3, [r7, #4]
 945 00b0 93F86C30 		ldrb	r3, [r3, #108]	@ zero_extendqisi2
 946              		.loc 1 372 6
 947 00b4 9A42     		cmp	r2, r3
 948 00b6 17D1     		bne	.L20
 373:Src/aspep.c   ****    /* Data packet the controller can send is bigger than performer can receive */
 374:Src/aspep.c   ****    || (MasterCapabilities.RX_maxSize > pHandle->Capabilities.RX_maxSize)
 949              		.loc 1 374 26
 950 00b8 7A7A     		ldrb	r2, [r7, #9]	@ zero_extendqisi2
 951              		.loc 1 374 61
 952 00ba 7B68     		ldr	r3, [r7, #4]
ARM GAS  /tmp/cc0OBPYV.s 			page 25


 953 00bc 93F86D30 		ldrb	r3, [r3, #109]	@ zero_extendqisi2
 954              		.loc 1 374 4
 955 00c0 9A42     		cmp	r2, r3
 956 00c2 11D8     		bhi	.L20
 375:Src/aspep.c   ****    /* Sync packet size alignement is required in order for the controller to be able to store it, a
 376:Src/aspep.c   ****     * response bigger than performer capability */
 377:Src/aspep.c   ****    || (pHandle->Capabilities.TXS_maxSize != MasterCapabilities.TXS_maxSize )
 957              		.loc 1 377 29
 958 00c4 7B68     		ldr	r3, [r7, #4]
 959 00c6 93F86E20 		ldrb	r2, [r3, #110]	@ zero_extendqisi2
 960              		.loc 1 377 63
 961 00ca BB7A     		ldrb	r3, [r7, #10]	@ zero_extendqisi2
 962              		.loc 1 377 4
 963 00cc 9A42     		cmp	r2, r3
 964 00ce 0BD1     		bne	.L20
 378:Src/aspep.c   ****    /* Async packet the performer can send is bigger than the controller can receive (but controller
 379:Src/aspep.c   ****     * packet than performer can transmit) */
 380:Src/aspep.c   ****    || (pHandle->Capabilities.TXA_maxSize != MasterCapabilities.TXA_maxSize )
 965              		.loc 1 380 29
 966 00d0 7B68     		ldr	r3, [r7, #4]
 967 00d2 93F86F20 		ldrb	r2, [r3, #111]	@ zero_extendqisi2
 968              		.loc 1 380 63
 969 00d6 FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 970              		.loc 1 380 4
 971 00d8 9A42     		cmp	r2, r3
 972 00da 05D1     		bne	.L20
 381:Src/aspep.c   ****    /* For the time being, controller version has to match performer version */
 382:Src/aspep.c   ****    || (MasterCapabilities.version != pHandle->Capabilities.version) )
 973              		.loc 1 382 26
 974 00dc 3A7B     		ldrb	r2, [r7, #12]	@ zero_extendqisi2
 975              		.loc 1 382 59
 976 00de 7B68     		ldr	r3, [r7, #4]
 977 00e0 93F87030 		ldrb	r3, [r3, #112]	@ zero_extendqisi2
 978              		.loc 1 382 4
 979 00e4 9A42     		cmp	r2, r3
 980 00e6 01D0     		beq	.L21
 981              	.L20:
 383:Src/aspep.c   ****   {
 384:Src/aspep.c   ****     result = false;
 982              		.loc 1 384 12
 983 00e8 0023     		movs	r3, #0
 984 00ea FB75     		strb	r3, [r7, #23]
 985              	.L21:
 385:Src/aspep.c   ****   }
 386:Src/aspep.c   ****   else
 387:Src/aspep.c   ****   {
 388:Src/aspep.c   ****     /* Nothing to do */
 389:Src/aspep.c   ****   }
 390:Src/aspep.c   **** 
 391:Src/aspep.c   ****   return (result);
 986              		.loc 1 391 10
 987 00ec FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 392:Src/aspep.c   **** }
 988              		.loc 1 392 1
 989 00ee 1846     		mov	r0, r3
 990 00f0 1C37     		adds	r7, r7, #28
 991              	.LCFI41:
ARM GAS  /tmp/cc0OBPYV.s 			page 26


 992              		.cfi_def_cfa_offset 4
 993 00f2 BD46     		mov	sp, r7
 994              	.LCFI42:
 995              		.cfi_def_cfa_register 13
 996              		@ sp needed
 997 00f4 5DF8047B 		ldr	r7, [sp], #4
 998              	.LCFI43:
 999              		.cfi_restore 7
 1000              		.cfi_def_cfa_offset 0
 1001 00f8 7047     		bx	lr
 1002              		.cfi_endproc
 1003              	.LFE1444:
 1005              		.section	.text.ASPEP_sendPacket,"ax",%progbits
 1006              		.align	1
 1007              		.global	ASPEP_sendPacket
 1008              		.syntax unified
 1009              		.thumb
 1010              		.thumb_func
 1011              		.fpu fpv4-sp-d16
 1013              	ASPEP_sendPacket:
 1014              	.LFB1445:
 393:Src/aspep.c   **** 
 394:Src/aspep.c   **** /**
 395:Src/aspep.c   ****   * @brief  Checks if any error has occurred and calls the ASPEP_TXframeProcess function.
 396:Src/aspep.c   ****   *
 397:Src/aspep.c   ****   * @param  *pSupHandle Handler of the current instance of the MCTL component
 398:Src/aspep.c   ****   * @param  *txBuffer can be 8, 16 or 32 bits, but must be 32 bits aligned
 399:Src/aspep.c   ****   * @param  txDataLength Size of useful data in byte
 400:Src/aspep.c   ****   * @param  syncAsync nature of the communication : synchronous or asynchronous
 401:Src/aspep.c   ****   *
 402:Src/aspep.c   ****   * @return Returns an ASPEP response defined in aspep.h
 403:Src/aspep.c   ****   */
 404:Src/aspep.c   **** uint8_t ASPEP_sendPacket(MCTL_Handle_t *pSupHandle, void *txBuffer, uint16_t txDataLength, uint8_t 
 405:Src/aspep.c   **** {
 1015              		.loc 1 405 1
 1016              		.cfi_startproc
 1017              		@ args = 0, pretend = 0, frame = 40
 1018              		@ frame_needed = 1, uses_anonymous_args = 0
 1019 0000 80B5     		push	{r7, lr}
 1020              	.LCFI44:
 1021              		.cfi_def_cfa_offset 8
 1022              		.cfi_offset 7, -8
 1023              		.cfi_offset 14, -4
 1024 0002 8AB0     		sub	sp, sp, #40
 1025              	.LCFI45:
 1026              		.cfi_def_cfa_offset 48
 1027 0004 00AF     		add	r7, sp, #0
 1028              	.LCFI46:
 1029              		.cfi_def_cfa_register 7
 1030 0006 F860     		str	r0, [r7, #12]
 1031 0008 B960     		str	r1, [r7, #8]
 1032 000a 1146     		mov	r1, r2
 1033 000c 1A46     		mov	r2, r3
 1034 000e 0B46     		mov	r3, r1	@ movhi
 1035 0010 FB80     		strh	r3, [r7, #6]	@ movhi
 1036 0012 1346     		mov	r3, r2
 1037 0014 7B71     		strb	r3, [r7, #5]
ARM GAS  /tmp/cc0OBPYV.s 			page 27


 406:Src/aspep.c   ****   uint8_t result = ASPEP_OK;
 1038              		.loc 1 406 11
 1039 0016 0023     		movs	r3, #0
 1040 0018 87F82730 		strb	r3, [r7, #39]
 407:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 408:Src/aspep.c   ****   if ((MC_NULL == pSupHandle) || (MC_NULL == txBuffer))
 409:Src/aspep.c   ****   {
 410:Src/aspep.c   ****     result = ASPEP_BUFFER_ERROR;
 411:Src/aspep.c   ****   }
 412:Src/aspep.c   ****   else
 413:Src/aspep.c   ****   {
 414:Src/aspep.c   **** #endif
 415:Src/aspep.c   ****     uint32_t *header;
 416:Src/aspep.c   ****     uint32_t tmpHeader;
 417:Src/aspep.c   ****     uint16_t txDataLengthTemp;
 418:Src/aspep.c   ****     uint8_t *packet;
 419:Src/aspep.c   **** 
 420:Src/aspep.c   ****     txDataLengthTemp = txDataLength;
 1041              		.loc 1 420 22
 1042 001c FB88     		ldrh	r3, [r7, #6]	@ movhi
 1043 001e BB84     		strh	r3, [r7, #36]	@ movhi
 421:Src/aspep.c   ****     ASPEP_Handle_t *pHandle = (ASPEP_Handle_t *)pSupHandle; //cstat !MISRAC2012-Rule-11.3
 1044              		.loc 1 421 21
 1045 0020 FB68     		ldr	r3, [r7, #12]
 1046 0022 3B62     		str	r3, [r7, #32]
 422:Src/aspep.c   **** 
 423:Src/aspep.c   ****     if (ASPEP_CONNECTED == pHandle-> ASPEP_State)
 1047              		.loc 1 423 35
 1048 0024 3B6A     		ldr	r3, [r7, #32]
 1049 0026 93F86430 		ldrb	r3, [r3, #100]	@ zero_extendqisi2
 1050              		.loc 1 423 8
 1051 002a 022B     		cmp	r3, #2
 1052 002c 3FD1     		bne	.L24
 424:Src/aspep.c   ****     {
 425:Src/aspep.c   ****       /*We must add packet header on  */
 426:Src/aspep.c   ****       /* | [0101|0011] | Length 13b | Reserved |CRCH 4b| */
 427:Src/aspep.c   ****       packet = (uint8_t *)txBuffer; //cstat !MISRAC2012-Rule-11.5
 1053              		.loc 1 427 14
 1054 002e BB68     		ldr	r3, [r7, #8]
 1055 0030 FB61     		str	r3, [r7, #28]
 428:Src/aspep.c   ****       header = (uint32_t *)txBuffer; //cstat !MISRAC2012-Rule-11.5
 1056              		.loc 1 428 14
 1057 0032 BB68     		ldr	r3, [r7, #8]
 1058 0034 BB61     		str	r3, [r7, #24]
 429:Src/aspep.c   ****       header--; /* Header ues 4*8 bits on top of txBuffer*/
 1059              		.loc 1 429 13
 1060 0036 BB69     		ldr	r3, [r7, #24]
 1061 0038 043B     		subs	r3, r3, #4
 1062 003a BB61     		str	r3, [r7, #24]
 430:Src/aspep.c   ****       tmpHeader = ((uint32_t)((uint32_t)txDataLengthTemp << (uint32_t)4) | (uint32_t)syncAsync);
 1063              		.loc 1 430 31
 1064 003c BB8C     		ldrh	r3, [r7, #36]
 1065              		.loc 1 430 20
 1066 003e 1A01     		lsls	r2, r3, #4
 1067              		.loc 1 430 76
 1068 0040 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 1069              		.loc 1 430 17
ARM GAS  /tmp/cc0OBPYV.s 			page 28


 1070 0042 1343     		orrs	r3, r3, r2
 1071 0044 7B61     		str	r3, [r7, #20]
 431:Src/aspep.c   ****       *header = tmpHeader;
 1072              		.loc 1 431 15
 1073 0046 BB69     		ldr	r3, [r7, #24]
 1074 0048 7A69     		ldr	r2, [r7, #20]
 1075 004a 1A60     		str	r2, [r3]
 432:Src/aspep.c   ****       if (1U == pHandle->Capabilities.DATA_CRC)
 1076              		.loc 1 432 38
 1077 004c 3B6A     		ldr	r3, [r7, #32]
 1078 004e 93F86C30 		ldrb	r3, [r3, #108]	@ zero_extendqisi2
 1079              		.loc 1 432 10
 1080 0052 012B     		cmp	r3, #1
 1081 0054 0DD1     		bne	.L25
 433:Src/aspep.c   ****       {
 434:Src/aspep.c   ****         /* TODO : Compute real CRC*/
 435:Src/aspep.c   ****         packet[txDataLengthTemp] = (uint8_t)0xCA; /* Dummy CRC */
 1082              		.loc 1 435 15
 1083 0056 BB8C     		ldrh	r3, [r7, #36]
 1084 0058 FA69     		ldr	r2, [r7, #28]
 1085 005a 1344     		add	r3, r3, r2
 1086              		.loc 1 435 34
 1087 005c CA22     		movs	r2, #202
 1088 005e 1A70     		strb	r2, [r3]
 436:Src/aspep.c   ****         packet[txDataLengthTemp + 1U] = (uint8_t)0xFE; /* Dummy CRC */
 1089              		.loc 1 436 15
 1090 0060 BB8C     		ldrh	r3, [r7, #36]
 1091 0062 0133     		adds	r3, r3, #1
 1092 0064 FA69     		ldr	r2, [r7, #28]
 1093 0066 1344     		add	r3, r3, r2
 1094              		.loc 1 436 39
 1095 0068 FE22     		movs	r2, #254
 1096 006a 1A70     		strb	r2, [r3]
 437:Src/aspep.c   ****         txDataLengthTemp += (uint16_t)ASPEP_DATACRC_SIZE;
 1097              		.loc 1 437 26
 1098 006c BB8C     		ldrh	r3, [r7, #36]	@ movhi
 1099 006e 0233     		adds	r3, r3, #2
 1100 0070 BB84     		strh	r3, [r7, #36]	@ movhi
 1101              	.L25:
 438:Src/aspep.c   ****       }
 439:Src/aspep.c   ****       if (MCTL_SYNC == syncAsync)
 1102              		.loc 1 439 10
 1103 0072 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 1104 0074 0A2B     		cmp	r3, #10
 1105 0076 0AD1     		bne	.L26
 440:Src/aspep.c   ****       {
 441:Src/aspep.c   ****         if (pSupHandle->MCP_PacketAvailable)
 1106              		.loc 1 441 23
 1107 0078 FB68     		ldr	r3, [r7, #12]
 1108 007a 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 1109              		.loc 1 441 12
 1110 007c 002B     		cmp	r3, #0
 1111 007e 03D0     		beq	.L27
 442:Src/aspep.c   ****         {
 443:Src/aspep.c   ****           pSupHandle->MCP_PacketAvailable = false; /* CMD from controller is processed*/
 1112              		.loc 1 443 43
 1113 0080 FB68     		ldr	r3, [r7, #12]
ARM GAS  /tmp/cc0OBPYV.s 			page 29


 1114 0082 0022     		movs	r2, #0
 1115 0084 1A74     		strb	r2, [r3, #16]
 1116 0086 02E0     		b	.L26
 1117              	.L27:
 444:Src/aspep.c   ****         }
 445:Src/aspep.c   ****         else
 446:Src/aspep.c   ****         {
 447:Src/aspep.c   ****           result = MCTL_SYNC_NOT_EXPECTED;
 1118              		.loc 1 447 18
 1119 0088 0123     		movs	r3, #1
 1120 008a 87F82730 		strb	r3, [r7, #39]
 1121              	.L26:
 448:Src/aspep.c   ****         }
 449:Src/aspep.c   ****       }
 450:Src/aspep.c   ****       if (ASPEP_OK == result) /* Send packet only if no error detected so far*/
 1122              		.loc 1 450 10
 1123 008e 97F82730 		ldrb	r3, [r7, #39]	@ zero_extendqisi2
 1124 0092 002B     		cmp	r3, #0
 1125 0094 0ED1     		bne	.L28
 451:Src/aspep.c   ****       {
 452:Src/aspep.c   ****         result = ASPEP_TXframeProcess(pHandle, syncAsync, header, txDataLengthTemp + (uint16_t)ASPE
 1126              		.loc 1 452 18
 1127 0096 BB8C     		ldrh	r3, [r7, #36]	@ movhi
 1128 0098 0433     		adds	r3, r3, #4
 1129 009a 9BB2     		uxth	r3, r3
 1130 009c 7979     		ldrb	r1, [r7, #5]	@ zero_extendqisi2
 1131 009e BA69     		ldr	r2, [r7, #24]
 1132 00a0 386A     		ldr	r0, [r7, #32]
 1133 00a2 FFF7FEFF 		bl	ASPEP_TXframeProcess
 1134 00a6 0346     		mov	r3, r0
 1135 00a8 87F82730 		strb	r3, [r7, #39]
 1136 00ac 02E0     		b	.L28
 1137              	.L24:
 453:Src/aspep.c   ****       }
 454:Src/aspep.c   ****     }
 455:Src/aspep.c   ****     else
 456:Src/aspep.c   ****     {
 457:Src/aspep.c   ****       result = ASPEP_NOT_CONNECTED;
 1138              		.loc 1 457 14
 1139 00ae 0223     		movs	r3, #2
 1140 00b0 87F82730 		strb	r3, [r7, #39]
 1141              	.L28:
 458:Src/aspep.c   ****     }
 459:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 460:Src/aspep.c   ****   }
 461:Src/aspep.c   **** #endif
 462:Src/aspep.c   ****   return (result);
 1142              		.loc 1 462 10
 1143 00b4 97F82730 		ldrb	r3, [r7, #39]	@ zero_extendqisi2
 463:Src/aspep.c   **** }
 1144              		.loc 1 463 1
 1145 00b8 1846     		mov	r0, r3
 1146 00ba 2837     		adds	r7, r7, #40
 1147              	.LCFI47:
 1148              		.cfi_def_cfa_offset 8
 1149 00bc BD46     		mov	sp, r7
 1150              	.LCFI48:
ARM GAS  /tmp/cc0OBPYV.s 			page 30


 1151              		.cfi_def_cfa_register 13
 1152              		@ sp needed
 1153 00be 80BD     		pop	{r7, pc}
 1154              		.cfi_endproc
 1155              	.LFE1445:
 1157              		.section	.text.ASPEP_TXframeProcess,"ax",%progbits
 1158              		.align	1
 1159              		.syntax unified
 1160              		.thumb
 1161              		.thumb_func
 1162              		.fpu fpv4-sp-d16
 1164              	ASPEP_TXframeProcess:
 1165              	.LFB1446:
 464:Src/aspep.c   **** 
 465:Src/aspep.c   **** /**
 466:Src/aspep.c   ****   * @brief  Checks if HW resource is busy before sending packet. Otherwise saves packet for next op
 467:Src/aspep.c   ****   *
 468:Src/aspep.c   ****   * This function contains a critical section.
 469:Src/aspep.c   ****   * It can be accessed concurently under High frequency task (by MCPA_datalog)
 470:Src/aspep.c   ****   * and under Medium frequency task (MC_Scheduler -> ASPEP_RxFrameProcess ).
 471:Src/aspep.c   ****   *
 472:Src/aspep.c   ****   * @param  *pHandle Handler of the current instance of the ASPEP component
 473:Src/aspep.c   ****   * @param  dataType Nature of the communication : synchronous, asynchronous or a CTL packet
 474:Src/aspep.c   ****   * @param  *txBuffer CRC Header to be computed in sent packet
 475:Src/aspep.c   ****   * @param  bufferLength Size of the packet to be sent : Header + Data
 476:Src/aspep.c   ****   *
 477:Src/aspep.c   ****   * @return Returns an ASPEP response defined in aspep.h
 478:Src/aspep.c   ****   */
 479:Src/aspep.c   **** uint8_t ASPEP_TXframeProcess(ASPEP_Handle_t *pHandle, uint8_t dataType, void *txBuffer, uint16_t bu
 480:Src/aspep.c   **** {
 1166              		.loc 1 480 1
 1167              		.cfi_startproc
 1168              		@ args = 0, pretend = 0, frame = 24
 1169              		@ frame_needed = 1, uses_anonymous_args = 0
 1170 0000 80B5     		push	{r7, lr}
 1171              	.LCFI49:
 1172              		.cfi_def_cfa_offset 8
 1173              		.cfi_offset 7, -8
 1174              		.cfi_offset 14, -4
 1175 0002 86B0     		sub	sp, sp, #24
 1176              	.LCFI50:
 1177              		.cfi_def_cfa_offset 32
 1178 0004 00AF     		add	r7, sp, #0
 1179              	.LCFI51:
 1180              		.cfi_def_cfa_register 7
 1181 0006 F860     		str	r0, [r7, #12]
 1182 0008 7A60     		str	r2, [r7, #4]
 1183 000a 1A46     		mov	r2, r3
 1184 000c 0B46     		mov	r3, r1
 1185 000e FB72     		strb	r3, [r7, #11]
 1186 0010 1346     		mov	r3, r2	@ movhi
 1187 0012 3B81     		strh	r3, [r7, #8]	@ movhi
 481:Src/aspep.c   ****   uint8_t result = ASPEP_OK;
 1188              		.loc 1 481 11
 1189 0014 0023     		movs	r3, #0
 1190 0016 FB75     		strb	r3, [r7, #23]
 482:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
ARM GAS  /tmp/cc0OBPYV.s 			page 31


 483:Src/aspep.c   ****   if (MC_NULL == txBuffer)
 484:Src/aspep.c   ****   {
 485:Src/aspep.c   ****     result = ASPEP_BUFFER_ERROR;
 486:Src/aspep.c   ****   }
 487:Src/aspep.c   ****   else
 488:Src/aspep.c   ****   {
 489:Src/aspep.c   **** #endif
 490:Src/aspep.c   ****     /* Insert CRC header in the packet to send */
 491:Src/aspep.c   ****     ASPEP_ComputeHeaderCRC((uint32_t *)txBuffer); //cstat !MISRAC2012-Rule-11.5
 1191              		.loc 1 491 5
 1192 0018 7868     		ldr	r0, [r7, #4]
 1193 001a FFF7FEFF 		bl	ASPEP_ComputeHeaderCRC
 1194              	.LBB14:
 1195              	.LBB15:
 1196              		.file 2 "Drivers/CMSIS/Include/cmsis_gcc.h"
   1:Drivers/CMSIS/Include/cmsis_gcc.h **** /**************************************************************************//**
   2:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @version  V5.2.0
   5:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @date     08. May 2019
   6:Drivers/CMSIS/Include/cmsis_gcc.h ****  ******************************************************************************/
   7:Drivers/CMSIS/Include/cmsis_gcc.h **** /*
   8:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Copyright (c) 2009-2019 Arm Limited. All rights reserved.
   9:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  10:Drivers/CMSIS/Include/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  12:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:Drivers/CMSIS/Include/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:Drivers/CMSIS/Include/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  16:Drivers/CMSIS/Include/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  18:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:Drivers/CMSIS/Include/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:Drivers/CMSIS/Include/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:Drivers/CMSIS/Include/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:Drivers/CMSIS/Include/cmsis_gcc.h ****  * limitations under the License.
  23:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  24:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  25:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  28:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  34:Drivers/CMSIS/Include/cmsis_gcc.h **** /* Fallback for __has_builtin */
  35:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __has_builtin
  36:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  38:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  39:Drivers/CMSIS/Include/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ASM
  41:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __ASM                                  __asm
  42:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
ARM GAS  /tmp/cc0OBPYV.s 			page 32


  43:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __INLINE
  44:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __INLINE                               inline
  45:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  46:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
  48:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  49:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_FORCEINLINE                 
  50:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_FORCEINLINE                   __attribute__((always_inline)) static inline
  51:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif                                           
  52:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __NO_RETURN
  53:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((__noreturn__))
  54:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  55:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __USED
  56:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
  57:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  58:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __WEAK
  59:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  60:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  61:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED
  62:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  63:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  64:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  65:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
  66:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  67:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_UNION
  68:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
  69:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  70:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  71:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  72:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  73:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  74:Drivers/CMSIS/Include/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  75:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  76:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  77:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  78:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  79:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  80:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  81:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  82:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  83:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  84:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  85:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  86:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
  87:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  88:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  89:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  90:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  91:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  92:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  93:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  94:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
  95:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  96:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  97:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  98:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  99:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
ARM GAS  /tmp/cc0OBPYV.s 			page 33


 100:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
 101:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 102:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
 103:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
 104:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
 105:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 106:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 107:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 108:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 109:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 110:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ALIGNED
 111:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 112:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 113:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __RESTRICT
 114:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 115:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 116:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __COMPILER_BARRIER
 117:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __COMPILER_BARRIER()                   __ASM volatile("":::"memory")
 118:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 119:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 120:Drivers/CMSIS/Include/cmsis_gcc.h **** /* #########################  Startup and Lowlevel Init  ######################## */
 121:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 122:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __PROGRAM_START
 123:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 124:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 125:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Initializes data and bss sections
 126:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details This default implementations initialized all data and additional bss
 127:Drivers/CMSIS/Include/cmsis_gcc.h ****            sections relying on .copy.table and .zero.table specified properly
 128:Drivers/CMSIS/Include/cmsis_gcc.h ****            in the used linker script.
 129:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 130:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 131:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE __NO_RETURN void __cmsis_start(void)
 132:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 133:Drivers/CMSIS/Include/cmsis_gcc.h ****   extern void _start(void) __NO_RETURN;
 134:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 135:Drivers/CMSIS/Include/cmsis_gcc.h ****   typedef struct {
 136:Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t const* src;
 137:Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t* dest;
 138:Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t  wlen;
 139:Drivers/CMSIS/Include/cmsis_gcc.h ****   } __copy_table_t;
 140:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 141:Drivers/CMSIS/Include/cmsis_gcc.h ****   typedef struct {
 142:Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t* dest;
 143:Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t  wlen;
 144:Drivers/CMSIS/Include/cmsis_gcc.h ****   } __zero_table_t;
 145:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 146:Drivers/CMSIS/Include/cmsis_gcc.h ****   extern const __copy_table_t __copy_table_start__;
 147:Drivers/CMSIS/Include/cmsis_gcc.h ****   extern const __copy_table_t __copy_table_end__;
 148:Drivers/CMSIS/Include/cmsis_gcc.h ****   extern const __zero_table_t __zero_table_start__;
 149:Drivers/CMSIS/Include/cmsis_gcc.h ****   extern const __zero_table_t __zero_table_end__;
 150:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 151:Drivers/CMSIS/Include/cmsis_gcc.h ****   for (__copy_table_t const* pTable = &__copy_table_start__; pTable < &__copy_table_end__; ++pTable
 152:Drivers/CMSIS/Include/cmsis_gcc.h ****     for(uint32_t i=0u; i<pTable->wlen; ++i) {
 153:Drivers/CMSIS/Include/cmsis_gcc.h ****       pTable->dest[i] = pTable->src[i];
 154:Drivers/CMSIS/Include/cmsis_gcc.h ****     }
 155:Drivers/CMSIS/Include/cmsis_gcc.h ****   }
 156:Drivers/CMSIS/Include/cmsis_gcc.h ****  
ARM GAS  /tmp/cc0OBPYV.s 			page 34


 157:Drivers/CMSIS/Include/cmsis_gcc.h ****   for (__zero_table_t const* pTable = &__zero_table_start__; pTable < &__zero_table_end__; ++pTable
 158:Drivers/CMSIS/Include/cmsis_gcc.h ****     for(uint32_t i=0u; i<pTable->wlen; ++i) {
 159:Drivers/CMSIS/Include/cmsis_gcc.h ****       pTable->dest[i] = 0u;
 160:Drivers/CMSIS/Include/cmsis_gcc.h ****     }
 161:Drivers/CMSIS/Include/cmsis_gcc.h ****   }
 162:Drivers/CMSIS/Include/cmsis_gcc.h ****  
 163:Drivers/CMSIS/Include/cmsis_gcc.h ****   _start();
 164:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 165:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 166:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __PROGRAM_START           __cmsis_start
 167:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 168:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 169:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __INITIAL_SP
 170:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __INITIAL_SP              __StackTop
 171:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 172:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 173:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __STACK_LIMIT
 174:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __STACK_LIMIT             __StackLimit
 175:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 176:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 177:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __VECTOR_TABLE
 178:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __VECTOR_TABLE            __Vectors
 179:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 180:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 181:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __VECTOR_TABLE_ATTRIBUTE
 182:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __VECTOR_TABLE_ATTRIBUTE  __attribute((used, section(".vectors")))
 183:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 184:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 185:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
 186:Drivers/CMSIS/Include/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 187:Drivers/CMSIS/Include/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 188:Drivers/CMSIS/Include/cmsis_gcc.h ****   @{
 189:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 190:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 191:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 192:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
 193:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
 194:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 195:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 196:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_irq(void)
 197:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 198:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 199:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 200:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 201:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 202:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 203:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 204:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
 205:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 206:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 207:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_irq(void)
 208:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 209:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 1197              		.loc 2 209 3
 1198              		.syntax unified
 1199              	@ 209 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 1200 001e 72B6     		cpsid i
ARM GAS  /tmp/cc0OBPYV.s 			page 35


 1201              	@ 0 "" 2
 210:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 1202              		.loc 2 210 1
 1203              		.thumb
 1204              		.syntax unified
 1205 0020 00BF     		nop
 1206              	.LBE15:
 1207              	.LBE14:
 492:Src/aspep.c   ****     __disable_irq(); /*TODO: Disable High frequency task is enough */
 493:Src/aspep.c   ****     if (NULL == pHandle->lockBuffer) /* Communication Ip free to send data*/
 1208              		.loc 1 493 24
 1209 0022 FB68     		ldr	r3, [r7, #12]
 1210 0024 9B6C     		ldr	r3, [r3, #72]
 1211              		.loc 1 493 8
 1212 0026 002B     		cmp	r3, #0
 1213 0028 2BD1     		bne	.L31
 494:Src/aspep.c   ****     {
 495:Src/aspep.c   ****       if (MCTL_ASYNC == dataType)
 1214              		.loc 1 495 10
 1215 002a FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 1216 002c 092B     		cmp	r3, #9
 1217 002e 08D1     		bne	.L32
 496:Src/aspep.c   ****       {
 497:Src/aspep.c   ****         /* In ASYNC, two flipflop buffers are used, the txBuffer points always to lastRequestedAsyn
 498:Src/aspep.c   ****         pHandle->lastRequestedAsyncBuff->state = readLock;
 1218              		.loc 1 498 16
 1219 0030 FB68     		ldr	r3, [r7, #12]
 1220 0032 1B6C     		ldr	r3, [r3, #64]
 1221              		.loc 1 498 48
 1222 0034 0322     		movs	r2, #3
 1223 0036 9A71     		strb	r2, [r3, #6]
 499:Src/aspep.c   ****         pHandle->lockBuffer = (void *)pHandle->lastRequestedAsyncBuff;
 1224              		.loc 1 499 46
 1225 0038 FB68     		ldr	r3, [r7, #12]
 1226 003a 1A6C     		ldr	r2, [r3, #64]
 1227              		.loc 1 499 29
 1228 003c FB68     		ldr	r3, [r7, #12]
 1229 003e 9A64     		str	r2, [r3, #72]
 1230 0040 15E0     		b	.L33
 1231              	.L32:
 500:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 501:Src/aspep.c   ****         pHandle->lastRequestedAsyncBuff->SentNumber++;
 502:Src/aspep.c   **** #endif
 503:Src/aspep.c   ****       }
 504:Src/aspep.c   ****       else if (MCTL_SYNC == dataType)
 1232              		.loc 1 504 15
 1233 0042 FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 1234 0044 0A2B     		cmp	r3, #10
 1235 0046 09D1     		bne	.L34
 505:Src/aspep.c   ****       {
 506:Src/aspep.c   ****         pHandle->syncBuffer.state = readLock;
 1236              		.loc 1 506 35
 1237 0048 FB68     		ldr	r3, [r7, #12]
 1238 004a 0322     		movs	r2, #3
 1239 004c 83F82E20 		strb	r2, [r3, #46]
 507:Src/aspep.c   ****         pHandle->lockBuffer = (void *)&pHandle->syncBuffer;
 1240              		.loc 1 507 39
ARM GAS  /tmp/cc0OBPYV.s 			page 36


 1241 0050 FB68     		ldr	r3, [r7, #12]
 1242 0052 03F12802 		add	r2, r3, #40
 1243              		.loc 1 507 29
 1244 0056 FB68     		ldr	r3, [r7, #12]
 1245 0058 9A64     		str	r2, [r3, #72]
 1246 005a 08E0     		b	.L33
 1247              	.L34:
 508:Src/aspep.c   ****       }
 509:Src/aspep.c   ****       else
 510:Src/aspep.c   ****       {
 511:Src/aspep.c   ****         pHandle->ctrlBuffer.state = readLock;
 1248              		.loc 1 511 35
 1249 005c FB68     		ldr	r3, [r7, #12]
 1250 005e 0322     		movs	r2, #3
 1251 0060 83F82420 		strb	r2, [r3, #36]
 512:Src/aspep.c   ****         pHandle->lockBuffer = (void *)&pHandle->ctrlBuffer;
 1252              		.loc 1 512 39
 1253 0064 FB68     		ldr	r3, [r7, #12]
 1254 0066 03F12002 		add	r2, r3, #32
 1255              		.loc 1 512 29
 1256 006a FB68     		ldr	r3, [r7, #12]
 1257 006c 9A64     		str	r2, [r3, #72]
 1258              	.L33:
 1259              	.LBB16:
 1260              	.LBB17:
 198:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 1261              		.loc 2 198 3
 1262              		.syntax unified
 1263              	@ 198 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 1264 006e 62B6     		cpsie i
 1265              	@ 0 "" 2
 199:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 1266              		.loc 2 199 1
 1267              		.thumb
 1268              		.syntax unified
 1269 0070 00BF     		nop
 1270              	.LBE17:
 1271              	.LBE16:
 513:Src/aspep.c   ****       }
 514:Src/aspep.c   ****       /* Enable HF task It */
 515:Src/aspep.c   ****       __enable_irq(); /*TODO: Enable High frequency task is enough */
 516:Src/aspep.c   ****       pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, txBuffer, bufferLength);
 1272              		.loc 1 516 14
 1273 0072 FB68     		ldr	r3, [r7, #12]
 1274 0074 9B6D     		ldr	r3, [r3, #88]
 1275              		.loc 1 516 7
 1276 0076 FA68     		ldr	r2, [r7, #12]
 1277 0078 5069     		ldr	r0, [r2, #20]
 1278 007a 3A89     		ldrh	r2, [r7, #8]
 1279 007c 7968     		ldr	r1, [r7, #4]
 1280 007e 9847     		blx	r3
 1281              	.LVL2:
 1282 0080 3FE0     		b	.L35
 1283              	.L31:
 1284              	.LBB18:
 1285              	.LBB19:
 198:Drivers/CMSIS/Include/cmsis_gcc.h **** }
ARM GAS  /tmp/cc0OBPYV.s 			page 37


 1286              		.loc 2 198 3
 1287              		.syntax unified
 1288              	@ 198 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 1289 0082 62B6     		cpsie i
 1290              	@ 0 "" 2
 199:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 1291              		.loc 2 199 1
 1292              		.thumb
 1293              		.syntax unified
 1294 0084 00BF     		nop
 1295              	.LBE19:
 1296              	.LBE18:
 517:Src/aspep.c   ****     }
 518:Src/aspep.c   ****     else /* HW resource busy, saving packet to sent it once resource will be freed*/
 519:Src/aspep.c   ****     {
 520:Src/aspep.c   ****       __enable_irq(); /*TODO: Enable High frequency task is enough */
 521:Src/aspep.c   ****       /* Lock buffer can be freed here */
 522:Src/aspep.c   ****       if (MCTL_ASYNC == dataType)
 1297              		.loc 1 522 10
 1298 0086 FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 1299 0088 092B     		cmp	r3, #9
 1300 008a 18D1     		bne	.L36
 523:Src/aspep.c   ****       {
 524:Src/aspep.c   ****         /* Check that the buffer received is the one expected - probably useless */
 525:Src/aspep.c   ****         if (txBuffer != (uint8_t *)pHandle->lastRequestedAsyncBuff->buffer)
 1301              		.loc 1 525 43
 1302 008c FB68     		ldr	r3, [r7, #12]
 1303 008e 1B6C     		ldr	r3, [r3, #64]
 1304              		.loc 1 525 67
 1305 0090 1B68     		ldr	r3, [r3]
 1306              		.loc 1 525 12
 1307 0092 7A68     		ldr	r2, [r7, #4]
 1308 0094 9A42     		cmp	r2, r3
 1309 0096 01D0     		beq	.L37
 526:Src/aspep.c   ****         {
 527:Src/aspep.c   ****           result = ASPEP_BUFFER_ERROR;
 1310              		.loc 1 527 18
 1311 0098 0323     		movs	r3, #3
 1312 009a FB75     		strb	r3, [r7, #23]
 1313              	.L37:
 528:Src/aspep.c   ****         }
 529:Src/aspep.c   ****         else
 530:Src/aspep.c   ****         {
 531:Src/aspep.c   ****           /* Nothing to do */
 532:Src/aspep.c   ****         }
 533:Src/aspep.c   ****         if (NULL == pHandle->asyncNextBuffer)
 1314              		.loc 1 533 28
 1315 009c FB68     		ldr	r3, [r7, #12]
 1316 009e 5B6C     		ldr	r3, [r3, #68]
 1317              		.loc 1 533 12
 1318 00a0 002B     		cmp	r3, #0
 1319 00a2 03D1     		bne	.L38
 534:Src/aspep.c   ****         {
 535:Src/aspep.c   ****           /* Required to keep the right sending order */
 536:Src/aspep.c   ****           pHandle->asyncNextBuffer = pHandle->lastRequestedAsyncBuff;
 1320              		.loc 1 536 45
 1321 00a4 FB68     		ldr	r3, [r7, #12]
ARM GAS  /tmp/cc0OBPYV.s 			page 38


 1322 00a6 1A6C     		ldr	r2, [r3, #64]
 1323              		.loc 1 536 36
 1324 00a8 FB68     		ldr	r3, [r7, #12]
 1325 00aa 5A64     		str	r2, [r3, #68]
 1326              	.L38:
 537:Src/aspep.c   ****         }
 538:Src/aspep.c   ****         else
 539:Src/aspep.c   ****         {
 540:Src/aspep.c   ****           /* Nothing to do */
 541:Src/aspep.c   ****         }
 542:Src/aspep.c   ****         pHandle->lastRequestedAsyncBuff->state = pending;
 1327              		.loc 1 542 16
 1328 00ac FB68     		ldr	r3, [r7, #12]
 1329 00ae 1B6C     		ldr	r3, [r3, #64]
 1330              		.loc 1 542 48
 1331 00b0 0222     		movs	r2, #2
 1332 00b2 9A71     		strb	r2, [r3, #6]
 543:Src/aspep.c   ****         pHandle->lastRequestedAsyncBuff->length = bufferLength;
 1333              		.loc 1 543 16
 1334 00b4 FB68     		ldr	r3, [r7, #12]
 1335 00b6 1B6C     		ldr	r3, [r3, #64]
 1336              		.loc 1 543 49
 1337 00b8 3A89     		ldrh	r2, [r7, #8]	@ movhi
 1338 00ba 9A80     		strh	r2, [r3, #4]	@ movhi
 1339 00bc 21E0     		b	.L35
 1340              	.L36:
 544:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 545:Src/aspep.c   ****         pHandle->lastRequestedAsyncBuff->PendingNumber++;
 546:Src/aspep.c   **** #endif
 547:Src/aspep.c   ****       }
 548:Src/aspep.c   ****       else if (MCTL_SYNC == dataType)
 1341              		.loc 1 548 15
 1342 00be FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 1343 00c0 0A2B     		cmp	r3, #10
 1344 00c2 0FD1     		bne	.L39
 549:Src/aspep.c   ****       {
 550:Src/aspep.c   ****         if (pHandle -> syncBuffer.state != writeLock)
 1345              		.loc 1 550 34
 1346 00c4 FB68     		ldr	r3, [r7, #12]
 1347 00c6 93F82E30 		ldrb	r3, [r3, #46]	@ zero_extendqisi2
 1348              		.loc 1 550 12
 1349 00ca 012B     		cmp	r3, #1
 1350 00cc 02D0     		beq	.L40
 551:Src/aspep.c   ****         {
 552:Src/aspep.c   ****           result = ASPEP_BUFFER_ERROR;
 1351              		.loc 1 552 18
 1352 00ce 0323     		movs	r3, #3
 1353 00d0 FB75     		strb	r3, [r7, #23]
 1354 00d2 16E0     		b	.L35
 1355              	.L40:
 553:Src/aspep.c   ****         }
 554:Src/aspep.c   ****         else
 555:Src/aspep.c   ****         {
 556:Src/aspep.c   ****           pHandle->syncBuffer.state = pending;
 1356              		.loc 1 556 37
 1357 00d4 FB68     		ldr	r3, [r7, #12]
 1358 00d6 0222     		movs	r2, #2
ARM GAS  /tmp/cc0OBPYV.s 			page 39


 1359 00d8 83F82E20 		strb	r2, [r3, #46]
 557:Src/aspep.c   ****           pHandle->syncBuffer.length = bufferLength;
 1360              		.loc 1 557 38
 1361 00dc FB68     		ldr	r3, [r7, #12]
 1362 00de 3A89     		ldrh	r2, [r7, #8]	@ movhi
 1363 00e0 9A85     		strh	r2, [r3, #44]	@ movhi
 1364 00e2 0EE0     		b	.L35
 1365              	.L39:
 558:Src/aspep.c   ****         }
 559:Src/aspep.c   ****       }
 560:Src/aspep.c   ****       else if(ASPEP_CTRL == dataType)
 1366              		.loc 1 560 14
 1367 00e4 FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 1368 00e6 002B     		cmp	r3, #0
 1369 00e8 0BD1     		bne	.L35
 561:Src/aspep.c   ****       {
 562:Src/aspep.c   ****         if (pHandle->ctrlBuffer.state != available)
 1370              		.loc 1 562 32
 1371 00ea FB68     		ldr	r3, [r7, #12]
 1372 00ec 93F82430 		ldrb	r3, [r3, #36]	@ zero_extendqisi2
 1373              		.loc 1 562 12
 1374 00f0 002B     		cmp	r3, #0
 1375 00f2 02D0     		beq	.L41
 563:Src/aspep.c   ****         {
 564:Src/aspep.c   ****           result = ASPEP_BUFFER_ERROR;
 1376              		.loc 1 564 18
 1377 00f4 0323     		movs	r3, #3
 1378 00f6 FB75     		strb	r3, [r7, #23]
 1379 00f8 03E0     		b	.L35
 1380              	.L41:
 565:Src/aspep.c   ****         }
 566:Src/aspep.c   ****         else
 567:Src/aspep.c   ****         {
 568:Src/aspep.c   ****           pHandle->ctrlBuffer.state = pending;
 1381              		.loc 1 568 37
 1382 00fa FB68     		ldr	r3, [r7, #12]
 1383 00fc 0222     		movs	r2, #2
 1384 00fe 83F82420 		strb	r2, [r3, #36]
 1385              	.L35:
 569:Src/aspep.c   ****         }
 570:Src/aspep.c   ****       }
 571:Src/aspep.c   ****       else
 572:Src/aspep.c   ****       {
 573:Src/aspep.c   ****         /* Nothing to do */
 574:Src/aspep.c   ****       }
 575:Src/aspep.c   ****     }
 576:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 577:Src/aspep.c   ****   }
 578:Src/aspep.c   **** #endif
 579:Src/aspep.c   ****   return (result);
 1386              		.loc 1 579 10
 1387 0102 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 580:Src/aspep.c   **** }
 1388              		.loc 1 580 1
 1389 0104 1846     		mov	r0, r3
 1390 0106 1837     		adds	r7, r7, #24
 1391              	.LCFI52:
ARM GAS  /tmp/cc0OBPYV.s 			page 40


 1392              		.cfi_def_cfa_offset 8
 1393 0108 BD46     		mov	sp, r7
 1394              	.LCFI53:
 1395              		.cfi_def_cfa_register 13
 1396              		@ sp needed
 1397 010a 80BD     		pop	{r7, pc}
 1398              		.cfi_endproc
 1399              	.LFE1446:
 1401              		.section	.text.ASPEP_HWDataTransmittedIT,"ax",%progbits
 1402              		.align	1
 1403              		.global	ASPEP_HWDataTransmittedIT
 1404              		.syntax unified
 1405              		.thumb
 1406              		.thumb_func
 1407              		.fpu fpv4-sp-d16
 1409              	ASPEP_HWDataTransmittedIT:
 1410              	.LFB1447:
 581:Src/aspep.c   **** 
 582:Src/aspep.c   **** /**
 583:Src/aspep.c   ****   * @brief  Frees previously locked buffer and/or locks the next pending buffer. Once locked, sends
 584:Src/aspep.c   ****   *
 585:Src/aspep.c   ****   * Called as soon as previous packet transfer is completed, pHandle->lockBuffer is set before pack
 586:Src/aspep.c   ****   * Therefore, there is no need to protect this ISR against another higher priority ISR (HF Task).
 587:Src/aspep.c   ****   *
 588:Src/aspep.c   ****   * @param  *pHandle Handler of the current instance of the ASPEP component
 589:Src/aspep.c   ****   */
 590:Src/aspep.c   **** void ASPEP_HWDataTransmittedIT(ASPEP_Handle_t *pHandle)
 591:Src/aspep.c   **** {
 1411              		.loc 1 591 1
 1412              		.cfi_startproc
 1413              		@ args = 0, pretend = 0, frame = 16
 1414              		@ frame_needed = 1, uses_anonymous_args = 0
 1415 0000 80B5     		push	{r7, lr}
 1416              	.LCFI54:
 1417              		.cfi_def_cfa_offset 8
 1418              		.cfi_offset 7, -8
 1419              		.cfi_offset 14, -4
 1420 0002 84B0     		sub	sp, sp, #16
 1421              	.LCFI55:
 1422              		.cfi_def_cfa_offset 24
 1423 0004 00AF     		add	r7, sp, #0
 1424              	.LCFI56:
 1425              		.cfi_def_cfa_register 7
 1426 0006 7860     		str	r0, [r7, #4]
 592:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 593:Src/aspep.c   ****   if (NULL == pHandle)
 594:Src/aspep.c   ****   {
 595:Src/aspep.c   ****     /* Nothing to do */
 596:Src/aspep.c   ****   }
 597:Src/aspep.c   ****   else
 598:Src/aspep.c   ****   {
 599:Src/aspep.c   **** #endif
 600:Src/aspep.c   ****     /* First free previous readLock buffer */
 601:Src/aspep.c   ****     if (pHandle->ctrlBuffer.state == readLock)
 1427              		.loc 1 601 28
 1428 0008 7B68     		ldr	r3, [r7, #4]
 1429 000a 93F82430 		ldrb	r3, [r3, #36]	@ zero_extendqisi2
ARM GAS  /tmp/cc0OBPYV.s 			page 41


 1430              		.loc 1 601 8
 1431 000e 032B     		cmp	r3, #3
 1432 0010 04D1     		bne	.L44
 602:Src/aspep.c   ****     {
 603:Src/aspep.c   ****       pHandle->ctrlBuffer.state = available;
 1433              		.loc 1 603 33
 1434 0012 7B68     		ldr	r3, [r7, #4]
 1435 0014 0022     		movs	r2, #0
 1436 0016 83F82420 		strb	r2, [r3, #36]
 1437 001a 05E0     		b	.L45
 1438              	.L44:
 1439              	.LBB20:
 604:Src/aspep.c   ****     }
 605:Src/aspep.c   ****     else /* if previous buffer was not ASPEP_CTRL, then the buffer locked is a MCTL_Buff_t */
 606:Src/aspep.c   ****     {
 607:Src/aspep.c   ****       MCTL_Buff_t *tempBuff = (MCTL_Buff_t *)pHandle->lockBuffer; //cstat !MISRAC2012-Rule-11.5
 1440              		.loc 1 607 20
 1441 001c 7B68     		ldr	r3, [r7, #4]
 1442 001e 9B6C     		ldr	r3, [r3, #72]
 1443 0020 FB60     		str	r3, [r7, #12]
 608:Src/aspep.c   ****       tempBuff->state = available;
 1444              		.loc 1 608 23
 1445 0022 FB68     		ldr	r3, [r7, #12]
 1446 0024 0022     		movs	r2, #0
 1447 0026 9A71     		strb	r2, [r3, #6]
 1448              	.L45:
 1449              	.LBE20:
 609:Src/aspep.c   ****     }
 610:Src/aspep.c   ****     if (pHandle->syncBuffer.state == pending)
 1450              		.loc 1 610 28
 1451 0028 7B68     		ldr	r3, [r7, #4]
 1452 002a 93F82E30 		ldrb	r3, [r3, #46]	@ zero_extendqisi2
 1453              		.loc 1 610 8
 1454 002e 022B     		cmp	r3, #2
 1455 0030 12D1     		bne	.L46
 611:Src/aspep.c   ****     {
 612:Src/aspep.c   ****       pHandle->lockBuffer = (void *)&pHandle->syncBuffer;
 1456              		.loc 1 612 37
 1457 0032 7B68     		ldr	r3, [r7, #4]
 1458 0034 03F12802 		add	r2, r3, #40
 1459              		.loc 1 612 27
 1460 0038 7B68     		ldr	r3, [r7, #4]
 1461 003a 9A64     		str	r2, [r3, #72]
 613:Src/aspep.c   ****       pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, pHandle->syncBuffer.buffer, pHandle->syncBuffer.l
 1462              		.loc 1 613 14
 1463 003c 7B68     		ldr	r3, [r7, #4]
 1464 003e 9B6D     		ldr	r3, [r3, #88]
 1465              		.loc 1 613 7
 1466 0040 7A68     		ldr	r2, [r7, #4]
 1467 0042 5069     		ldr	r0, [r2, #20]
 1468              		.loc 1 613 70
 1469 0044 7A68     		ldr	r2, [r7, #4]
 1470 0046 916A     		ldr	r1, [r2, #40]
 1471              		.loc 1 613 7
 1472 0048 7A68     		ldr	r2, [r7, #4]
 1473 004a 928D     		ldrh	r2, [r2, #44]
 1474 004c 9847     		blx	r3
ARM GAS  /tmp/cc0OBPYV.s 			page 42


 1475              	.LVL3:
 614:Src/aspep.c   ****       pHandle->syncBuffer.state = readLock;
 1476              		.loc 1 614 33
 1477 004e 7B68     		ldr	r3, [r7, #4]
 1478 0050 0322     		movs	r2, #3
 1479 0052 83F82E20 		strb	r2, [r3, #46]
 615:Src/aspep.c   ****     }
 616:Src/aspep.c   ****     /* Second prepare transfer of pending buffer */
 617:Src/aspep.c   ****     else if (pHandle->ctrlBuffer.state == pending)
 618:Src/aspep.c   ****     {
 619:Src/aspep.c   ****       pHandle->lockBuffer = (void *)(&pHandle ->ctrlBuffer);
 620:Src/aspep.c   ****       pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, pHandle->ctrlBuffer.buffer, ASPEP_CTRL_SIZE);
 621:Src/aspep.c   ****       pHandle->ctrlBuffer.state = readLock;
 622:Src/aspep.c   ****     }
 623:Src/aspep.c   ****     else
 624:Src/aspep.c   ****     {
 625:Src/aspep.c   ****       __disable_irq();
 626:Src/aspep.c   ****       if (pHandle->asyncNextBuffer != NULL)
 627:Src/aspep.c   ****       {
 628:Src/aspep.c   ****         pHandle->lockBuffer = (void *)pHandle->asyncNextBuffer;
 629:Src/aspep.c   ****         pHandle->asyncNextBuffer->state = readLock;
 630:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 631:Src/aspep.c   ****         pHandle->asyncNextBuffer->SentNumber++;
 632:Src/aspep.c   **** #endif
 633:Src/aspep.c   ****         pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, pHandle->asyncNextBuffer->buffer, pHandle->asyn
 634:Src/aspep.c   ****         /* If one Async buffer is still pending, assign it to the asyncNextBuffer pointer*/
 635:Src/aspep.c   ****         if ((pHandle->asyncBufferA.state == pending) || (pHandle->asyncBufferB.state == pending))
 636:Src/aspep.c   ****         {
 637:Src/aspep.c   ****           //cstat !MISRAC2012-Rule-11.4
 638:Src/aspep.c   ****           uint32_t temp = (uint32_t)&pHandle->asyncBufferA + (uint32_t)&pHandle->asyncBufferB
 639:Src/aspep.c   ****                           - (uint32_t) pHandle->asyncNextBuffer; //cstat !MISRAC2012-Rule-11.4
 640:Src/aspep.c   ****           pHandle->asyncNextBuffer = (MCTL_Buff_t *) temp; //cstat !MISRAC2012-Rule-11.4
 641:Src/aspep.c   ****         }
 642:Src/aspep.c   ****         else
 643:Src/aspep.c   ****         {
 644:Src/aspep.c   ****           pHandle->asyncNextBuffer = NULL;
 645:Src/aspep.c   ****         }
 646:Src/aspep.c   ****       }
 647:Src/aspep.c   ****       else /* No TX packet are pending, HW resource is free*/
 648:Src/aspep.c   ****       {
 649:Src/aspep.c   ****         pHandle->lockBuffer = NULL;
 650:Src/aspep.c   ****       }
 651:Src/aspep.c   ****       __enable_irq();
 652:Src/aspep.c   ****     }
 653:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 654:Src/aspep.c   ****   }
 655:Src/aspep.c   **** #endif
 656:Src/aspep.c   **** }
 1480              		.loc 1 656 1
 1481 0056 51E0     		b	.L54
 1482              	.L46:
 617:Src/aspep.c   ****     {
 1483              		.loc 1 617 33
 1484 0058 7B68     		ldr	r3, [r7, #4]
 1485 005a 93F82430 		ldrb	r3, [r3, #36]	@ zero_extendqisi2
 617:Src/aspep.c   ****     {
 1486              		.loc 1 617 13
ARM GAS  /tmp/cc0OBPYV.s 			page 43


 1487 005e 022B     		cmp	r3, #2
 1488 0060 12D1     		bne	.L48
 619:Src/aspep.c   ****       pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, pHandle->ctrlBuffer.buffer, ASPEP_CTRL_SIZE);
 1489              		.loc 1 619 38
 1490 0062 7B68     		ldr	r3, [r7, #4]
 1491 0064 03F12002 		add	r2, r3, #32
 619:Src/aspep.c   ****       pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, pHandle->ctrlBuffer.buffer, ASPEP_CTRL_SIZE);
 1492              		.loc 1 619 27
 1493 0068 7B68     		ldr	r3, [r7, #4]
 1494 006a 9A64     		str	r2, [r3, #72]
 620:Src/aspep.c   ****       pHandle->ctrlBuffer.state = readLock;
 1495              		.loc 1 620 14
 1496 006c 7B68     		ldr	r3, [r7, #4]
 1497 006e 9B6D     		ldr	r3, [r3, #88]
 620:Src/aspep.c   ****       pHandle->ctrlBuffer.state = readLock;
 1498              		.loc 1 620 7
 1499 0070 7A68     		ldr	r2, [r7, #4]
 1500 0072 5069     		ldr	r0, [r2, #20]
 620:Src/aspep.c   ****       pHandle->ctrlBuffer.state = readLock;
 1501              		.loc 1 620 70
 1502 0074 7A68     		ldr	r2, [r7, #4]
 1503 0076 02F12001 		add	r1, r2, #32
 620:Src/aspep.c   ****       pHandle->ctrlBuffer.state = readLock;
 1504              		.loc 1 620 7
 1505 007a 0422     		movs	r2, #4
 1506 007c 9847     		blx	r3
 1507              	.LVL4:
 621:Src/aspep.c   ****     }
 1508              		.loc 1 621 33
 1509 007e 7B68     		ldr	r3, [r7, #4]
 1510 0080 0322     		movs	r2, #3
 1511 0082 83F82420 		strb	r2, [r3, #36]
 1512              		.loc 1 656 1
 1513 0086 39E0     		b	.L54
 1514              	.L48:
 1515              	.LBB21:
 1516              	.LBB22:
 209:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 1517              		.loc 2 209 3
 1518              		.syntax unified
 1519              	@ 209 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 1520 0088 72B6     		cpsid i
 1521              	@ 0 "" 2
 1522              		.loc 2 210 1
 1523              		.thumb
 1524              		.syntax unified
 1525 008a 00BF     		nop
 1526              	.LBE22:
 1527              	.LBE21:
 626:Src/aspep.c   ****       {
 1528              		.loc 1 626 18
 1529 008c 7B68     		ldr	r3, [r7, #4]
 1530 008e 5B6C     		ldr	r3, [r3, #68]
 626:Src/aspep.c   ****       {
 1531              		.loc 1 626 10
 1532 0090 002B     		cmp	r3, #0
 1533 0092 2ED0     		beq	.L49
ARM GAS  /tmp/cc0OBPYV.s 			page 44


 628:Src/aspep.c   ****         pHandle->asyncNextBuffer->state = readLock;
 1534              		.loc 1 628 46
 1535 0094 7B68     		ldr	r3, [r7, #4]
 1536 0096 5A6C     		ldr	r2, [r3, #68]
 628:Src/aspep.c   ****         pHandle->asyncNextBuffer->state = readLock;
 1537              		.loc 1 628 29
 1538 0098 7B68     		ldr	r3, [r7, #4]
 1539 009a 9A64     		str	r2, [r3, #72]
 629:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 1540              		.loc 1 629 16
 1541 009c 7B68     		ldr	r3, [r7, #4]
 1542 009e 5B6C     		ldr	r3, [r3, #68]
 629:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 1543              		.loc 1 629 41
 1544 00a0 0322     		movs	r2, #3
 1545 00a2 9A71     		strb	r2, [r3, #6]
 633:Src/aspep.c   ****         /* If one Async buffer is still pending, assign it to the asyncNextBuffer pointer*/
 1546              		.loc 1 633 16
 1547 00a4 7B68     		ldr	r3, [r7, #4]
 1548 00a6 9B6D     		ldr	r3, [r3, #88]
 633:Src/aspep.c   ****         /* If one Async buffer is still pending, assign it to the asyncNextBuffer pointer*/
 1549              		.loc 1 633 9
 1550 00a8 7A68     		ldr	r2, [r7, #4]
 1551 00aa 5069     		ldr	r0, [r2, #20]
 633:Src/aspep.c   ****         /* If one Async buffer is still pending, assign it to the asyncNextBuffer pointer*/
 1552              		.loc 1 633 60
 1553 00ac 7A68     		ldr	r2, [r7, #4]
 1554 00ae 526C     		ldr	r2, [r2, #68]
 633:Src/aspep.c   ****         /* If one Async buffer is still pending, assign it to the asyncNextBuffer pointer*/
 1555              		.loc 1 633 77
 1556 00b0 1168     		ldr	r1, [r2]
 633:Src/aspep.c   ****         /* If one Async buffer is still pending, assign it to the asyncNextBuffer pointer*/
 1557              		.loc 1 633 94
 1558 00b2 7A68     		ldr	r2, [r7, #4]
 1559 00b4 526C     		ldr	r2, [r2, #68]
 633:Src/aspep.c   ****         /* If one Async buffer is still pending, assign it to the asyncNextBuffer pointer*/
 1560              		.loc 1 633 9
 1561 00b6 9288     		ldrh	r2, [r2, #4]
 1562 00b8 9847     		blx	r3
 1563              	.LVL5:
 635:Src/aspep.c   ****         {
 1564              		.loc 1 635 35
 1565 00ba 7B68     		ldr	r3, [r7, #4]
 1566 00bc 93F83630 		ldrb	r3, [r3, #54]	@ zero_extendqisi2
 635:Src/aspep.c   ****         {
 1567              		.loc 1 635 12
 1568 00c0 022B     		cmp	r3, #2
 1569 00c2 04D0     		beq	.L50
 635:Src/aspep.c   ****         {
 1570              		.loc 1 635 79 discriminator 1
 1571 00c4 7B68     		ldr	r3, [r7, #4]
 1572 00c6 93F83E30 		ldrb	r3, [r3, #62]	@ zero_extendqisi2
 635:Src/aspep.c   ****         {
 1573              		.loc 1 635 54 discriminator 1
 1574 00ca 022B     		cmp	r3, #2
 1575 00cc 0DD1     		bne	.L51
 1576              	.L50:
ARM GAS  /tmp/cc0OBPYV.s 			page 45


 1577              	.LBB23:
 638:Src/aspep.c   ****                           - (uint32_t) pHandle->asyncNextBuffer; //cstat !MISRAC2012-Rule-11.4
 1578              		.loc 1 638 37
 1579 00ce 7B68     		ldr	r3, [r7, #4]
 1580 00d0 3033     		adds	r3, r3, #48
 638:Src/aspep.c   ****                           - (uint32_t) pHandle->asyncNextBuffer; //cstat !MISRAC2012-Rule-11.4
 1581              		.loc 1 638 27
 1582 00d2 1A46     		mov	r2, r3
 638:Src/aspep.c   ****                           - (uint32_t) pHandle->asyncNextBuffer; //cstat !MISRAC2012-Rule-11.4
 1583              		.loc 1 638 72
 1584 00d4 7B68     		ldr	r3, [r7, #4]
 1585 00d6 3833     		adds	r3, r3, #56
 638:Src/aspep.c   ****                           - (uint32_t) pHandle->asyncNextBuffer; //cstat !MISRAC2012-Rule-11.4
 1586              		.loc 1 638 60
 1587 00d8 1344     		add	r3, r3, r2
 639:Src/aspep.c   ****           pHandle->asyncNextBuffer = (MCTL_Buff_t *) temp; //cstat !MISRAC2012-Rule-11.4
 1588              		.loc 1 639 47
 1589 00da 7A68     		ldr	r2, [r7, #4]
 1590 00dc 526C     		ldr	r2, [r2, #68]
 638:Src/aspep.c   ****                           - (uint32_t) pHandle->asyncNextBuffer; //cstat !MISRAC2012-Rule-11.4
 1591              		.loc 1 638 20
 1592 00de 9B1A     		subs	r3, r3, r2
 1593 00e0 BB60     		str	r3, [r7, #8]
 640:Src/aspep.c   ****         }
 1594              		.loc 1 640 38
 1595 00e2 BA68     		ldr	r2, [r7, #8]
 640:Src/aspep.c   ****         }
 1596              		.loc 1 640 36
 1597 00e4 7B68     		ldr	r3, [r7, #4]
 1598 00e6 5A64     		str	r2, [r3, #68]
 1599              	.LBE23:
 636:Src/aspep.c   ****           //cstat !MISRAC2012-Rule-11.4
 1600              		.loc 1 636 9
 1601 00e8 06E0     		b	.L53
 1602              	.L51:
 644:Src/aspep.c   ****         }
 1603              		.loc 1 644 36
 1604 00ea 7B68     		ldr	r3, [r7, #4]
 1605 00ec 0022     		movs	r2, #0
 1606 00ee 5A64     		str	r2, [r3, #68]
 1607 00f0 02E0     		b	.L53
 1608              	.L49:
 649:Src/aspep.c   ****       }
 1609              		.loc 1 649 29
 1610 00f2 7B68     		ldr	r3, [r7, #4]
 1611 00f4 0022     		movs	r2, #0
 1612 00f6 9A64     		str	r2, [r3, #72]
 1613              	.L53:
 1614              	.LBB24:
 1615              	.LBB25:
 198:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 1616              		.loc 2 198 3
 1617              		.syntax unified
 1618              	@ 198 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 1619 00f8 62B6     		cpsie i
 1620              	@ 0 "" 2
 199:Drivers/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/cc0OBPYV.s 			page 46


 1621              		.loc 2 199 1
 1622              		.thumb
 1623              		.syntax unified
 1624 00fa 00BF     		nop
 1625              	.L54:
 1626              	.LBE25:
 1627              	.LBE24:
 1628              		.loc 1 656 1
 1629 00fc 00BF     		nop
 1630 00fe 1037     		adds	r7, r7, #16
 1631              	.LCFI57:
 1632              		.cfi_def_cfa_offset 8
 1633 0100 BD46     		mov	sp, r7
 1634              	.LCFI58:
 1635              		.cfi_def_cfa_register 13
 1636              		@ sp needed
 1637 0102 80BD     		pop	{r7, pc}
 1638              		.cfi_endproc
 1639              	.LFE1447:
 1641              		.section	.text.ASPEP_RXframeProcess,"ax",%progbits
 1642              		.align	1
 1643              		.global	ASPEP_RXframeProcess
 1644              		.syntax unified
 1645              		.thumb
 1646              		.thumb_func
 1647              		.fpu fpv4-sp-d16
 1649              	ASPEP_RXframeProcess:
 1650              	.LFB1448:
 657:Src/aspep.c   **** 
 658:Src/aspep.c   **** /**
 659:Src/aspep.c   ****   * @brief  Updates ASPEP state depending on received packet from Controller and sends a response a
 660:Src/aspep.c   ****   *
 661:Src/aspep.c   ****   * ASPEP protocol defined in section 4.4.1 Connection Procedure of Motor Control Protocol Suite of
 662:Src/aspep.c   ****   *
 663:Src/aspep.c   ****   * @param  *pSupHandle Handler of the current instance of the MCTL component
 664:Src/aspep.c   ****   * @param  *packetLength Length of the packet to be processed
 665:Src/aspep.c   ****   *
 666:Src/aspep.c   ****   * @return Returns the buffer of data transmitted by the MCP controller device
 667:Src/aspep.c   ****   */
 668:Src/aspep.c   **** uint8_t *ASPEP_RXframeProcess(MCTL_Handle_t *pSupHandle, uint16_t *packetLength)
 669:Src/aspep.c   **** {
 1651              		.loc 1 669 1
 1652              		.cfi_startproc
 1653              		@ args = 0, pretend = 0, frame = 24
 1654              		@ frame_needed = 1, uses_anonymous_args = 0
 1655 0000 80B5     		push	{r7, lr}
 1656              	.LCFI59:
 1657              		.cfi_def_cfa_offset 8
 1658              		.cfi_offset 7, -8
 1659              		.cfi_offset 14, -4
 1660 0002 86B0     		sub	sp, sp, #24
 1661              	.LCFI60:
 1662              		.cfi_def_cfa_offset 32
 1663 0004 00AF     		add	r7, sp, #0
 1664              	.LCFI61:
 1665              		.cfi_def_cfa_register 7
 1666 0006 7860     		str	r0, [r7, #4]
ARM GAS  /tmp/cc0OBPYV.s 			page 47


 1667 0008 3960     		str	r1, [r7]
 670:Src/aspep.c   ****   uint8_t *result = NULL; //cstat !MISRAC2012-Rule-8.13
 1668              		.loc 1 670 12
 1669 000a 0023     		movs	r3, #0
 1670 000c 7B61     		str	r3, [r7, #20]
 671:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 672:Src/aspep.c   ****   if ((NULL == pSupHandle) || (NULL == packetLength))
 673:Src/aspep.c   ****   {
 674:Src/aspep.c   ****     /* Nothing to do */
 675:Src/aspep.c   ****   }
 676:Src/aspep.c   ****   else
 677:Src/aspep.c   ****   {
 678:Src/aspep.c   **** #endif
 679:Src/aspep.c   ****     ASPEP_Handle_t *pHandle = (ASPEP_Handle_t *)pSupHandle; //cstat !MISRAC2012-Rule-11.3
 1671              		.loc 1 679 21
 1672 000e 7B68     		ldr	r3, [r7, #4]
 1673 0010 3B61     		str	r3, [r7, #16]
 680:Src/aspep.c   ****     uint32_t packetHeader = *((uint32_t *)pHandle->rxHeader); //cstat !MISRAC2012-Rule-11.3
 1674              		.loc 1 680 43
 1675 0012 3B69     		ldr	r3, [r7, #16]
 1676 0014 1C33     		adds	r3, r3, #28
 1677              		.loc 1 680 14
 1678 0016 1B68     		ldr	r3, [r3]
 1679 0018 FB60     		str	r3, [r7, #12]
 681:Src/aspep.c   ****     uint16_t packetNumber;
 682:Src/aspep.c   **** #if VALID_CRC_DATA
 683:Src/aspep.c   ****     bool validCRCData = true;
 684:Src/aspep.c   **** #endif
 685:Src/aspep.c   ****     *packetLength = 0;
 1680              		.loc 1 685 19
 1681 001a 3B68     		ldr	r3, [r7]
 1682 001c 0022     		movs	r2, #0
 1683 001e 1A80     		strh	r2, [r3]	@ movhi
 686:Src/aspep.c   ****     if (pHandle->NewPacketAvailable)
 1684              		.loc 1 686 16
 1685 0020 3B69     		ldr	r3, [r7, #16]
 1686 0022 93F86130 		ldrb	r3, [r3, #97]	@ zero_extendqisi2
 1687              		.loc 1 686 8
 1688 0026 002B     		cmp	r3, #0
 1689 0028 00F0CD80 		beq	.L56
 687:Src/aspep.c   ****     {
 688:Src/aspep.c   ****       pHandle->NewPacketAvailable = false; /* Consumes new packet*/
 1690              		.loc 1 688 35
 1691 002c 3B69     		ldr	r3, [r7, #16]
 1692 002e 0022     		movs	r2, #0
 1693 0030 83F86120 		strb	r2, [r3, #97]
 689:Src/aspep.c   ****       switch (pHandle->ASPEP_State)
 1694              		.loc 1 689 22
 1695 0034 3B69     		ldr	r3, [r7, #16]
 1696 0036 93F86430 		ldrb	r3, [r3, #100]	@ zero_extendqisi2
 1697              		.loc 1 689 7
 1698 003a 022B     		cmp	r3, #2
 1699 003c 6FD0     		beq	.L57
 1700 003e 022B     		cmp	r3, #2
 1701 0040 00F3B080 		bgt	.L75
 1702 0044 002B     		cmp	r3, #0
 1703 0046 02D0     		beq	.L59
ARM GAS  /tmp/cc0OBPYV.s 			page 48


 1704 0048 012B     		cmp	r3, #1
 1705 004a 3ED0     		beq	.L60
 690:Src/aspep.c   ****       {
 691:Src/aspep.c   ****         case ASPEP_IDLE:
 692:Src/aspep.c   ****         {
 693:Src/aspep.c   ****           if (BEACON == pHandle->rxPacketType)
 694:Src/aspep.c   ****           {
 695:Src/aspep.c   ****             if (ASPEP_CheckBeacon(pHandle) == true)
 696:Src/aspep.c   ****             {
 697:Src/aspep.c   ****               /* Controller capabilities match performer capabilities.*/
 698:Src/aspep.c   ****               pSupHandle->txSyncMaxPayload = (pHandle->Capabilities.TXS_maxSize + (uint16_t)1U) * (
 699:Src/aspep.c   ****               pSupHandle->txAsyncMaxPayload = (pHandle->Capabilities.TXA_maxSize) * (uint16_t)64U;
 700:Src/aspep.c   ****               pHandle->maxRXPayload = (pHandle->Capabilities.RX_maxSize + (uint16_t)1U) * (uint16_t
 701:Src/aspep.c   ****               pHandle->ASPEP_State = ASPEP_CONFIGURED;
 702:Src/aspep.c   ****             }
 703:Src/aspep.c   ****             else
 704:Src/aspep.c   ****             {
 705:Src/aspep.c   ****               /* Nothing to do, controller has to send back new beacon with matching capabilities *
 706:Src/aspep.c   ****             }
 707:Src/aspep.c   ****             /* Beacon Packet must be answered*/
 708:Src/aspep.c   ****             ASPEP_sendBeacon(pHandle, &pHandle->Capabilities);
 709:Src/aspep.c   ****           }
 710:Src/aspep.c   ****           else if (PING == pHandle->rxPacketType)
 711:Src/aspep.c   ****           {
 712:Src/aspep.c   ****             /* In Listening for controller performer, */
 713:Src/aspep.c   ****             packetNumber = (uint16_t)((packetHeader & 0x0FFFF000U) >> (uint16_t)12U);
 714:Src/aspep.c   ****             ASPEP_sendPing(pHandle, ASPEP_PING_RESET, packetNumber);
 715:Src/aspep.c   ****           }
 716:Src/aspep.c   ****           else
 717:Src/aspep.c   ****           {
 718:Src/aspep.c   ****             /* Nothing to do */
 719:Src/aspep.c   ****           }
 720:Src/aspep.c   ****           break;
 721:Src/aspep.c   ****         }
 722:Src/aspep.c   **** 
 723:Src/aspep.c   ****         case ASPEP_CONFIGURED:
 724:Src/aspep.c   ****         {
 725:Src/aspep.c   ****           if (BEACON == pHandle->rxPacketType)
 726:Src/aspep.c   ****           {
 727:Src/aspep.c   ****             if (ASPEP_CheckBeacon(pHandle) == false)
 728:Src/aspep.c   ****             {
 729:Src/aspep.c   ****               pHandle->ASPEP_State = ASPEP_IDLE;
 730:Src/aspep.c   ****             }
 731:Src/aspep.c   ****             else
 732:Src/aspep.c   ****             {
 733:Src/aspep.c   ****               /* Nothing to do */
 734:Src/aspep.c   ****             }
 735:Src/aspep.c   **** 
 736:Src/aspep.c   ****             ASPEP_sendBeacon (pHandle, &pHandle->Capabilities);
 737:Src/aspep.c   ****           }
 738:Src/aspep.c   ****           else if (PING == pHandle->rxPacketType)
 739:Src/aspep.c   ****           {
 740:Src/aspep.c   ****             /* In Listening for controller performer, */
 741:Src/aspep.c   ****             packetNumber = (uint16_t)((packetHeader & 0x0FFFF000U) >> (uint16_t)12U);
 742:Src/aspep.c   ****             ASPEP_sendPing(pHandle, ASPEP_PING_CFG, packetNumber);
 743:Src/aspep.c   ****             pHandle->ASPEP_State = ASPEP_CONNECTED;
 744:Src/aspep.c   ****           }
ARM GAS  /tmp/cc0OBPYV.s 			page 49


 745:Src/aspep.c   ****           else
 746:Src/aspep.c   ****           {
 747:Src/aspep.c   ****             /* Nothing to do */
 748:Src/aspep.c   ****           }
 749:Src/aspep.c   ****           break;
 750:Src/aspep.c   ****         }
 751:Src/aspep.c   **** 
 752:Src/aspep.c   ****         case ASPEP_CONNECTED:
 753:Src/aspep.c   ****         {
 754:Src/aspep.c   ****           if (BEACON == pHandle->rxPacketType)
 755:Src/aspep.c   ****           {
 756:Src/aspep.c   ****             if (ASPEP_CheckBeacon(pHandle) == false)
 757:Src/aspep.c   ****             {
 758:Src/aspep.c   ****               pHandle->ASPEP_State = ASPEP_IDLE;
 759:Src/aspep.c   ****             }
 760:Src/aspep.c   ****             else
 761:Src/aspep.c   ****             {
 762:Src/aspep.c   ****               pHandle->ASPEP_State = ASPEP_CONFIGURED;
 763:Src/aspep.c   ****             }
 764:Src/aspep.c   ****             ASPEP_sendBeacon(pHandle, &pHandle->Capabilities);
 765:Src/aspep.c   ****           }
 766:Src/aspep.c   ****           else if (PING == pHandle->rxPacketType)
 767:Src/aspep.c   ****           {
 768:Src/aspep.c   ****             packetNumber = (uint16_t)((packetHeader & 0x0FFFF000U) >> (uint16_t)12U);
 769:Src/aspep.c   ****             ASPEP_sendPing(pHandle, ASPEP_PING_CFG, packetNumber);
 770:Src/aspep.c   ****           }
 771:Src/aspep.c   ****           else if (DATA_PACKET == pHandle->rxPacketType)
 772:Src/aspep.c   ****           {
 773:Src/aspep.c   **** #if VALID_CRC_DATA
 774:Src/aspep.c   ****             if (validCRCData)
 775:Src/aspep.c   ****             {
 776:Src/aspep.c   **** #endif
 777:Src/aspep.c   ****               pHandle->syncPacketCount++; /* this counter is incremented at each valid data packet 
 778:Src/aspep.c   ****               pSupHandle->MCP_PacketAvailable = true; /* Will be consumed in ASPEP_sendPacket */
 779:Src/aspep.c   ****               *packetLength = pHandle->rxLengthASPEP;
 780:Src/aspep.c   ****               result = pHandle->rxBuffer;
 781:Src/aspep.c   **** #if VALID_CRC_DATA
 782:Src/aspep.c   ****             }
 783:Src/aspep.c   ****             else
 784:Src/aspep.c   ****             {
 785:Src/aspep.c   ****               ASPEP_sendNack (pHandle, ASPEP_BAD_CRC_DATA);
 786:Src/aspep.c   ****             }
 787:Src/aspep.c   **** #endif
 788:Src/aspep.c   ****           }
 789:Src/aspep.c   ****           else
 790:Src/aspep.c   ****           {
 791:Src/aspep.c   ****             /* This condition is not reachable because already filtred by NewPacketAvailable */
 792:Src/aspep.c   ****             /* ASPEP_sendNack (pHandle, ASPEP_BAD_PACKET_TYPE) */
 793:Src/aspep.c   ****           }
 794:Src/aspep.c   ****           break;
 795:Src/aspep.c   ****         }
 796:Src/aspep.c   **** 
 797:Src/aspep.c   ****         default:
 798:Src/aspep.c   ****           break;
 1706              		.loc 1 798 11
 1707 004c AAE0     		b	.L75
 1708              	.L59:
ARM GAS  /tmp/cc0OBPYV.s 			page 50


 693:Src/aspep.c   ****           {
 1709              		.loc 1 693 32
 1710 004e 3B69     		ldr	r3, [r7, #16]
 1711 0050 9B6E     		ldr	r3, [r3, #104]
 693:Src/aspep.c   ****           {
 1712              		.loc 1 693 14
 1713 0052 052B     		cmp	r3, #5
 1714 0054 2BD1     		bne	.L61
 695:Src/aspep.c   ****             {
 1715              		.loc 1 695 17
 1716 0056 3869     		ldr	r0, [r7, #16]
 1717 0058 FFF7FEFF 		bl	ASPEP_CheckBeacon
 1718 005c 0346     		mov	r3, r0
 695:Src/aspep.c   ****             {
 1719              		.loc 1 695 16
 1720 005e 002B     		cmp	r3, #0
 1721 0060 1ED0     		beq	.L62
 698:Src/aspep.c   ****               pSupHandle->txAsyncMaxPayload = (pHandle->Capabilities.TXA_maxSize) * (uint16_t)64U;
 1722              		.loc 1 698 68
 1723 0062 3B69     		ldr	r3, [r7, #16]
 1724 0064 93F86E30 		ldrb	r3, [r3, #110]	@ zero_extendqisi2
 698:Src/aspep.c   ****               pSupHandle->txAsyncMaxPayload = (pHandle->Capabilities.TXA_maxSize) * (uint16_t)64U;
 1725              		.loc 1 698 81
 1726 0068 0133     		adds	r3, r3, #1
 698:Src/aspep.c   ****               pSupHandle->txAsyncMaxPayload = (pHandle->Capabilities.TXA_maxSize) * (uint16_t)64U;
 1727              		.loc 1 698 44
 1728 006a 9BB2     		uxth	r3, r3
 1729 006c 5B01     		lsls	r3, r3, #5
 1730 006e 9AB2     		uxth	r2, r3
 1731 0070 7B68     		ldr	r3, [r7, #4]
 1732 0072 9A81     		strh	r2, [r3, #12]	@ movhi
 699:Src/aspep.c   ****               pHandle->maxRXPayload = (pHandle->Capabilities.RX_maxSize + (uint16_t)1U) * (uint16_t
 1733              		.loc 1 699 69
 1734 0074 3B69     		ldr	r3, [r7, #16]
 1735 0076 93F86F30 		ldrb	r3, [r3, #111]	@ zero_extendqisi2
 699:Src/aspep.c   ****               pHandle->maxRXPayload = (pHandle->Capabilities.RX_maxSize + (uint16_t)1U) * (uint16_t
 1736              		.loc 1 699 45
 1737 007a 9BB2     		uxth	r3, r3
 1738 007c 9B01     		lsls	r3, r3, #6
 1739 007e 9AB2     		uxth	r2, r3
 1740 0080 7B68     		ldr	r3, [r7, #4]
 1741 0082 DA81     		strh	r2, [r3, #14]	@ movhi
 700:Src/aspep.c   ****               pHandle->ASPEP_State = ASPEP_CONFIGURED;
 1742              		.loc 1 700 61
 1743 0084 3B69     		ldr	r3, [r7, #16]
 1744 0086 93F86D30 		ldrb	r3, [r3, #109]	@ zero_extendqisi2
 700:Src/aspep.c   ****               pHandle->ASPEP_State = ASPEP_CONFIGURED;
 1745              		.loc 1 700 73
 1746 008a 0133     		adds	r3, r3, #1
 700:Src/aspep.c   ****               pHandle->ASPEP_State = ASPEP_CONFIGURED;
 1747              		.loc 1 700 37
 1748 008c 9BB2     		uxth	r3, r3
 1749 008e 5B01     		lsls	r3, r3, #5
 1750 0090 9AB2     		uxth	r2, r3
 1751 0092 3B69     		ldr	r3, [r7, #16]
 1752 0094 A3F85E20 		strh	r2, [r3, #94]	@ movhi
 701:Src/aspep.c   ****             }
ARM GAS  /tmp/cc0OBPYV.s 			page 51


 1753              		.loc 1 701 36
 1754 0098 3B69     		ldr	r3, [r7, #16]
 1755 009a 0122     		movs	r2, #1
 1756 009c 83F86420 		strb	r2, [r3, #100]
 1757              	.L62:
 708:Src/aspep.c   ****           }
 1758              		.loc 1 708 13
 1759 00a0 3B69     		ldr	r3, [r7, #16]
 1760 00a2 6C33     		adds	r3, r3, #108
 1761 00a4 1946     		mov	r1, r3
 1762 00a6 3869     		ldr	r0, [r7, #16]
 1763 00a8 FFF7FEFF 		bl	ASPEP_sendBeacon
 720:Src/aspep.c   ****         }
 1764              		.loc 1 720 11
 1765 00ac 7CE0     		b	.L76
 1766              	.L61:
 710:Src/aspep.c   ****           {
 1767              		.loc 1 710 35
 1768 00ae 3B69     		ldr	r3, [r7, #16]
 1769 00b0 9B6E     		ldr	r3, [r3, #104]
 710:Src/aspep.c   ****           {
 1770              		.loc 1 710 19
 1771 00b2 062B     		cmp	r3, #6
 1772 00b4 78D1     		bne	.L76
 713:Src/aspep.c   ****             ASPEP_sendPing(pHandle, ASPEP_PING_RESET, packetNumber);
 1773              		.loc 1 713 68
 1774 00b6 FB68     		ldr	r3, [r7, #12]
 1775 00b8 1B0B     		lsrs	r3, r3, #12
 713:Src/aspep.c   ****             ASPEP_sendPing(pHandle, ASPEP_PING_RESET, packetNumber);
 1776              		.loc 1 713 26
 1777 00ba 7B81     		strh	r3, [r7, #10]	@ movhi
 714:Src/aspep.c   ****           }
 1778              		.loc 1 714 13
 1779 00bc 7B89     		ldrh	r3, [r7, #10]
 1780 00be 1A46     		mov	r2, r3
 1781 00c0 0021     		movs	r1, #0
 1782 00c2 3869     		ldr	r0, [r7, #16]
 1783 00c4 FFF7FEFF 		bl	ASPEP_sendPing
 720:Src/aspep.c   ****         }
 1784              		.loc 1 720 11
 1785 00c8 6EE0     		b	.L76
 1786              	.L60:
 725:Src/aspep.c   ****           {
 1787              		.loc 1 725 32
 1788 00ca 3B69     		ldr	r3, [r7, #16]
 1789 00cc 9B6E     		ldr	r3, [r3, #104]
 725:Src/aspep.c   ****           {
 1790              		.loc 1 725 14
 1791 00ce 052B     		cmp	r3, #5
 1792 00d0 13D1     		bne	.L65
 727:Src/aspep.c   ****             {
 1793              		.loc 1 727 17
 1794 00d2 3869     		ldr	r0, [r7, #16]
 1795 00d4 FFF7FEFF 		bl	ASPEP_CheckBeacon
 1796 00d8 0346     		mov	r3, r0
 727:Src/aspep.c   ****             {
 1797              		.loc 1 727 44
ARM GAS  /tmp/cc0OBPYV.s 			page 52


 1798 00da 83F00103 		eor	r3, r3, #1
 1799 00de DBB2     		uxtb	r3, r3
 727:Src/aspep.c   ****             {
 1800              		.loc 1 727 16
 1801 00e0 002B     		cmp	r3, #0
 1802 00e2 03D0     		beq	.L66
 729:Src/aspep.c   ****             }
 1803              		.loc 1 729 36
 1804 00e4 3B69     		ldr	r3, [r7, #16]
 1805 00e6 0022     		movs	r2, #0
 1806 00e8 83F86420 		strb	r2, [r3, #100]
 1807              	.L66:
 736:Src/aspep.c   ****           }
 1808              		.loc 1 736 13
 1809 00ec 3B69     		ldr	r3, [r7, #16]
 1810 00ee 6C33     		adds	r3, r3, #108
 1811 00f0 1946     		mov	r1, r3
 1812 00f2 3869     		ldr	r0, [r7, #16]
 1813 00f4 FFF7FEFF 		bl	ASPEP_sendBeacon
 749:Src/aspep.c   ****         }
 1814              		.loc 1 749 11
 1815 00f8 58E0     		b	.L77
 1816              	.L65:
 738:Src/aspep.c   ****           {
 1817              		.loc 1 738 35
 1818 00fa 3B69     		ldr	r3, [r7, #16]
 1819 00fc 9B6E     		ldr	r3, [r3, #104]
 738:Src/aspep.c   ****           {
 1820              		.loc 1 738 19
 1821 00fe 062B     		cmp	r3, #6
 1822 0100 54D1     		bne	.L77
 741:Src/aspep.c   ****             ASPEP_sendPing(pHandle, ASPEP_PING_CFG, packetNumber);
 1823              		.loc 1 741 68
 1824 0102 FB68     		ldr	r3, [r7, #12]
 1825 0104 1B0B     		lsrs	r3, r3, #12
 741:Src/aspep.c   ****             ASPEP_sendPing(pHandle, ASPEP_PING_CFG, packetNumber);
 1826              		.loc 1 741 26
 1827 0106 7B81     		strh	r3, [r7, #10]	@ movhi
 742:Src/aspep.c   ****             pHandle->ASPEP_State = ASPEP_CONNECTED;
 1828              		.loc 1 742 13
 1829 0108 7B89     		ldrh	r3, [r7, #10]
 1830 010a 1A46     		mov	r2, r3
 1831 010c 0121     		movs	r1, #1
 1832 010e 3869     		ldr	r0, [r7, #16]
 1833 0110 FFF7FEFF 		bl	ASPEP_sendPing
 743:Src/aspep.c   ****           }
 1834              		.loc 1 743 34
 1835 0114 3B69     		ldr	r3, [r7, #16]
 1836 0116 0222     		movs	r2, #2
 1837 0118 83F86420 		strb	r2, [r3, #100]
 749:Src/aspep.c   ****         }
 1838              		.loc 1 749 11
 1839 011c 46E0     		b	.L77
 1840              	.L57:
 754:Src/aspep.c   ****           {
 1841              		.loc 1 754 32
 1842 011e 3B69     		ldr	r3, [r7, #16]
ARM GAS  /tmp/cc0OBPYV.s 			page 53


 1843 0120 9B6E     		ldr	r3, [r3, #104]
 754:Src/aspep.c   ****           {
 1844              		.loc 1 754 14
 1845 0122 052B     		cmp	r3, #5
 1846 0124 18D1     		bne	.L68
 756:Src/aspep.c   ****             {
 1847              		.loc 1 756 17
 1848 0126 3869     		ldr	r0, [r7, #16]
 1849 0128 FFF7FEFF 		bl	ASPEP_CheckBeacon
 1850 012c 0346     		mov	r3, r0
 756:Src/aspep.c   ****             {
 1851              		.loc 1 756 44
 1852 012e 83F00103 		eor	r3, r3, #1
 1853 0132 DBB2     		uxtb	r3, r3
 756:Src/aspep.c   ****             {
 1854              		.loc 1 756 16
 1855 0134 002B     		cmp	r3, #0
 1856 0136 04D0     		beq	.L69
 758:Src/aspep.c   ****             }
 1857              		.loc 1 758 36
 1858 0138 3B69     		ldr	r3, [r7, #16]
 1859 013a 0022     		movs	r2, #0
 1860 013c 83F86420 		strb	r2, [r3, #100]
 1861 0140 03E0     		b	.L70
 1862              	.L69:
 762:Src/aspep.c   ****             }
 1863              		.loc 1 762 36
 1864 0142 3B69     		ldr	r3, [r7, #16]
 1865 0144 0122     		movs	r2, #1
 1866 0146 83F86420 		strb	r2, [r3, #100]
 1867              	.L70:
 764:Src/aspep.c   ****           }
 1868              		.loc 1 764 13
 1869 014a 3B69     		ldr	r3, [r7, #16]
 1870 014c 6C33     		adds	r3, r3, #108
 1871 014e 1946     		mov	r1, r3
 1872 0150 3869     		ldr	r0, [r7, #16]
 1873 0152 FFF7FEFF 		bl	ASPEP_sendBeacon
 794:Src/aspep.c   ****         }
 1874              		.loc 1 794 11
 1875 0156 2BE0     		b	.L78
 1876              	.L68:
 766:Src/aspep.c   ****           {
 1877              		.loc 1 766 35
 1878 0158 3B69     		ldr	r3, [r7, #16]
 1879 015a 9B6E     		ldr	r3, [r3, #104]
 766:Src/aspep.c   ****           {
 1880              		.loc 1 766 19
 1881 015c 062B     		cmp	r3, #6
 1882 015e 09D1     		bne	.L72
 768:Src/aspep.c   ****             ASPEP_sendPing(pHandle, ASPEP_PING_CFG, packetNumber);
 1883              		.loc 1 768 68
 1884 0160 FB68     		ldr	r3, [r7, #12]
 1885 0162 1B0B     		lsrs	r3, r3, #12
 768:Src/aspep.c   ****             ASPEP_sendPing(pHandle, ASPEP_PING_CFG, packetNumber);
 1886              		.loc 1 768 26
 1887 0164 7B81     		strh	r3, [r7, #10]	@ movhi
ARM GAS  /tmp/cc0OBPYV.s 			page 54


 769:Src/aspep.c   ****           }
 1888              		.loc 1 769 13
 1889 0166 7B89     		ldrh	r3, [r7, #10]
 1890 0168 1A46     		mov	r2, r3
 1891 016a 0121     		movs	r1, #1
 1892 016c 3869     		ldr	r0, [r7, #16]
 1893 016e FFF7FEFF 		bl	ASPEP_sendPing
 794:Src/aspep.c   ****         }
 1894              		.loc 1 794 11
 1895 0172 1DE0     		b	.L78
 1896              	.L72:
 771:Src/aspep.c   ****           {
 1897              		.loc 1 771 42
 1898 0174 3B69     		ldr	r3, [r7, #16]
 1899 0176 9B6E     		ldr	r3, [r3, #104]
 771:Src/aspep.c   ****           {
 1900              		.loc 1 771 19
 1901 0178 092B     		cmp	r3, #9
 1902 017a 19D1     		bne	.L78
 777:Src/aspep.c   ****               pSupHandle->MCP_PacketAvailable = true; /* Will be consumed in ASPEP_sendPacket */
 1903              		.loc 1 777 22
 1904 017c 3B69     		ldr	r3, [r7, #16]
 1905 017e 93F86030 		ldrb	r3, [r3, #96]	@ zero_extendqisi2
 777:Src/aspep.c   ****               pSupHandle->MCP_PacketAvailable = true; /* Will be consumed in ASPEP_sendPacket */
 1906              		.loc 1 777 39
 1907 0182 0133     		adds	r3, r3, #1
 1908 0184 DAB2     		uxtb	r2, r3
 1909 0186 3B69     		ldr	r3, [r7, #16]
 1910 0188 83F86020 		strb	r2, [r3, #96]
 778:Src/aspep.c   ****               *packetLength = pHandle->rxLengthASPEP;
 1911              		.loc 1 778 47
 1912 018c 7B68     		ldr	r3, [r7, #4]
 1913 018e 0122     		movs	r2, #1
 1914 0190 1A74     		strb	r2, [r3, #16]
 779:Src/aspep.c   ****               result = pHandle->rxBuffer;
 1915              		.loc 1 779 38
 1916 0192 3B69     		ldr	r3, [r7, #16]
 1917 0194 B3F85C20 		ldrh	r2, [r3, #92]
 779:Src/aspep.c   ****               result = pHandle->rxBuffer;
 1918              		.loc 1 779 29
 1919 0198 3B68     		ldr	r3, [r7]
 1920 019a 1A80     		strh	r2, [r3]	@ movhi
 780:Src/aspep.c   **** #if VALID_CRC_DATA
 1921              		.loc 1 780 22
 1922 019c 3B69     		ldr	r3, [r7, #16]
 1923 019e 9B69     		ldr	r3, [r3, #24]
 1924 01a0 7B61     		str	r3, [r7, #20]
 794:Src/aspep.c   ****         }
 1925              		.loc 1 794 11
 1926 01a2 05E0     		b	.L78
 1927              	.L75:
 1928              		.loc 1 798 11
 1929 01a4 00BF     		nop
 1930 01a6 04E0     		b	.L64
 1931              	.L76:
 720:Src/aspep.c   ****         }
 1932              		.loc 1 720 11
ARM GAS  /tmp/cc0OBPYV.s 			page 55


 1933 01a8 00BF     		nop
 1934 01aa 02E0     		b	.L64
 1935              	.L77:
 749:Src/aspep.c   ****         }
 1936              		.loc 1 749 11
 1937 01ac 00BF     		nop
 1938 01ae 00E0     		b	.L64
 1939              	.L78:
 794:Src/aspep.c   ****         }
 1940              		.loc 1 794 11
 1941 01b0 00BF     		nop
 1942              	.L64:
 799:Src/aspep.c   ****       }
 800:Src/aspep.c   ****       /* The valid received packet is now safely consumes, we are ready to receive a new packet */
 801:Src/aspep.c   ****       pHandle->fASPEP_cfg_recept(pHandle->ASPEPIp, pHandle->rxHeader, ASPEP_HEADER_SIZE);
 1943              		.loc 1 801 14
 1944 01b2 3B69     		ldr	r3, [r7, #16]
 1945 01b4 5B6D     		ldr	r3, [r3, #84]
 1946              		.loc 1 801 7
 1947 01b6 3A69     		ldr	r2, [r7, #16]
 1948 01b8 5069     		ldr	r0, [r2, #20]
 1949              		.loc 1 801 59
 1950 01ba 3A69     		ldr	r2, [r7, #16]
 1951 01bc 02F11C01 		add	r1, r2, #28
 1952              		.loc 1 801 7
 1953 01c0 0422     		movs	r2, #4
 1954 01c2 9847     		blx	r3
 1955              	.LVL6:
 1956 01c4 15E0     		b	.L73
 1957              	.L56:
 802:Src/aspep.c   ****     }
 803:Src/aspep.c   ****     else if (pHandle->badPacketFlag > ASPEP_OK)
 1958              		.loc 1 803 21
 1959 01c6 3B69     		ldr	r3, [r7, #16]
 1960 01c8 93F86230 		ldrb	r3, [r3, #98]	@ zero_extendqisi2
 1961              		.loc 1 803 13
 1962 01cc 002B     		cmp	r3, #0
 1963 01ce 10D0     		beq	.L73
 804:Src/aspep.c   ****     {
 805:Src/aspep.c   ****       ASPEP_sendNack(pHandle, pHandle->badPacketFlag);
 1964              		.loc 1 805 7
 1965 01d0 3B69     		ldr	r3, [r7, #16]
 1966 01d2 93F86230 		ldrb	r3, [r3, #98]	@ zero_extendqisi2
 1967 01d6 1946     		mov	r1, r3
 1968 01d8 3869     		ldr	r0, [r7, #16]
 1969 01da FFF7FEFF 		bl	ASPEP_sendNack
 806:Src/aspep.c   ****       /* ASPEP_RXframeProcess can be called before reception of another packet */
 807:Src/aspep.c   ****       pHandle->badPacketFlag = ASPEP_OK;
 1970              		.loc 1 807 30
 1971 01de 3B69     		ldr	r3, [r7, #16]
 1972 01e0 0022     		movs	r2, #0
 1973 01e2 83F86220 		strb	r2, [r3, #98]
 808:Src/aspep.c   ****       /* As we received a packet with a bad header, we need to be sure that the HW IP is well Synch
 809:Src/aspep.c   ****         * DMA will be configured to receive next packet as soon as HW IP RX line is free to receive
 810:Src/aspep.c   ****         * It is important to note that we will detect only the NEXT free line transition, it means 
 811:Src/aspep.c   ****         * be lost but the end of this lost packet will generate the IDLE interrupt
 812:Src/aspep.c   ****         * the IDLE interrupt will call ASPEP_HWReset (in charge of the IP_aspep driver to call it a
ARM GAS  /tmp/cc0OBPYV.s 			page 56


 813:Src/aspep.c   ****         * time)*/
 814:Src/aspep.c   ****       pHandle->fASPEP_HWSync(pHandle->ASPEPIp);
 1974              		.loc 1 814 14
 1975 01e6 3B69     		ldr	r3, [r7, #16]
 1976 01e8 1B6D     		ldr	r3, [r3, #80]
 1977              		.loc 1 814 7
 1978 01ea 3A69     		ldr	r2, [r7, #16]
 1979 01ec 5269     		ldr	r2, [r2, #20]
 1980 01ee 1046     		mov	r0, r2
 1981 01f0 9847     		blx	r3
 1982              	.LVL7:
 1983              	.L73:
 815:Src/aspep.c   ****     }
 816:Src/aspep.c   ****     else
 817:Src/aspep.c   ****     {
 818:Src/aspep.c   ****       /* Nothing to do, no response is due to the controller */
 819:Src/aspep.c   ****     }
 820:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 821:Src/aspep.c   ****   }
 822:Src/aspep.c   **** #endif
 823:Src/aspep.c   ****   return (result);
 1984              		.loc 1 823 10
 1985 01f2 7B69     		ldr	r3, [r7, #20]
 824:Src/aspep.c   **** }
 1986              		.loc 1 824 1
 1987 01f4 1846     		mov	r0, r3
 1988 01f6 1837     		adds	r7, r7, #24
 1989              	.LCFI62:
 1990              		.cfi_def_cfa_offset 8
 1991 01f8 BD46     		mov	sp, r7
 1992              	.LCFI63:
 1993              		.cfi_def_cfa_register 13
 1994              		@ sp needed
 1995 01fa 80BD     		pop	{r7, pc}
 1996              		.cfi_endproc
 1997              	.LFE1448:
 1999              		.section	.text.ASPEP_HWDataReceivedIT,"ax",%progbits
 2000              		.align	1
 2001              		.global	ASPEP_HWDataReceivedIT
 2002              		.syntax unified
 2003              		.thumb
 2004              		.thumb_func
 2005              		.fpu fpv4-sp-d16
 2007              	ASPEP_HWDataReceivedIT:
 2008              	.LFB1449:
 825:Src/aspep.c   **** 
 826:Src/aspep.c   **** /**
 827:Src/aspep.c   ****   * @brief  Processes the received data packet.
 828:Src/aspep.c   ****   *
 829:Src/aspep.c   ****   * This function is called once DMA has transfered the configure number of byte.
 830:Src/aspep.c   ****   * Upon reception of a new packet the DMA will be re-configured only once the answer has been sent
 831:Src/aspep.c   ****   * This is mandatory to avoid a race condition in case of a new packet is received while executing
 832:Src/aspep.c   ****   * If the packet received contains an error in the header, the HW IP will be re-synchronised first
 833:Src/aspep.c   ****   *
 834:Src/aspep.c   ****   * @param  *pHandle Handler of the current instance of the ASPEP component
 835:Src/aspep.c   ****   */
 836:Src/aspep.c   **** void ASPEP_HWDataReceivedIT(ASPEP_Handle_t *pHandle)
ARM GAS  /tmp/cc0OBPYV.s 			page 57


 837:Src/aspep.c   **** {
 2009              		.loc 1 837 1
 2010              		.cfi_startproc
 2011              		@ args = 0, pretend = 0, frame = 8
 2012              		@ frame_needed = 1, uses_anonymous_args = 0
 2013 0000 90B5     		push	{r4, r7, lr}
 2014              	.LCFI64:
 2015              		.cfi_def_cfa_offset 12
 2016              		.cfi_offset 4, -12
 2017              		.cfi_offset 7, -8
 2018              		.cfi_offset 14, -4
 2019 0002 83B0     		sub	sp, sp, #12
 2020              	.LCFI65:
 2021              		.cfi_def_cfa_offset 24
 2022 0004 00AF     		add	r7, sp, #0
 2023              	.LCFI66:
 2024              		.cfi_def_cfa_register 7
 2025 0006 7860     		str	r0, [r7, #4]
 838:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 839:Src/aspep.c   ****   if (MC_NULL == pHandle)
 840:Src/aspep.c   ****   {
 841:Src/aspep.c   ****     /* Nothing to do */
 842:Src/aspep.c   ****   }
 843:Src/aspep.c   ****   else
 844:Src/aspep.c   ****   {
 845:Src/aspep.c   **** #endif
 846:Src/aspep.c   ****     switch (pHandle->ASPEP_TL_State)
 2026              		.loc 1 846 20
 2027 0008 7B68     		ldr	r3, [r7, #4]
 2028 000a 93F86530 		ldrb	r3, [r3, #101]	@ zero_extendqisi2
 2029              		.loc 1 846 5
 2030 000e 002B     		cmp	r3, #0
 2031 0010 02D0     		beq	.L80
 2032 0012 012B     		cmp	r3, #1
 2033 0014 5FD0     		beq	.L81
 847:Src/aspep.c   ****     {
 848:Src/aspep.c   ****       case WAITING_PACKET:
 849:Src/aspep.c   ****       {
 850:Src/aspep.c   ****         if (ASPEP_CheckHeaderCRC(*(uint32_t *)pHandle->rxHeader) == true) //cstat !MISRAC2012-Rule-
 851:Src/aspep.c   ****         {
 852:Src/aspep.c   ****           pHandle->rxPacketType = (ASPEP_packetType)(((uint32_t)pHandle->rxHeader[0]) & ID_MASK);
 853:Src/aspep.c   ****           switch (pHandle->rxPacketType)
 854:Src/aspep.c   ****           {
 855:Src/aspep.c   ****             case DATA_PACKET:
 856:Src/aspep.c   ****             {
 857:Src/aspep.c   ****               //cstat !MISRAC2012-Rule-11.3
 858:Src/aspep.c   ****               pHandle->rxLengthASPEP = (uint16_t)((*((uint16_t *)pHandle->rxHeader) & 0x1FFF0U) >> 
 859:Src/aspep.c   ****               if (0U == pHandle->rxLengthASPEP) /* data packet with length 0 is a valid packet */
 860:Src/aspep.c   ****               {
 861:Src/aspep.c   ****                 pHandle->NewPacketAvailable = true;
 862:Src/aspep.c   ****                 /* The receiver is not reconfigure right now on purpose to avoid race condition whe
 863:Src/aspep.c   ****                   *  processed in ASPEP_RXframeProcess */
 864:Src/aspep.c   ****               }
 865:Src/aspep.c   ****               else if (pHandle->rxLengthASPEP <= pHandle->maxRXPayload)
 866:Src/aspep.c   ****               {
 867:Src/aspep.c   ****                 pHandle->fASPEP_cfg_recept(pHandle->ASPEPIp, pHandle->rxBuffer,  /* need to read + 
 868:Src/aspep.c   ****                                         (pHandle->rxLengthASPEP + ((uint16_t)ASPEP_DATACRC_SIZE * (
ARM GAS  /tmp/cc0OBPYV.s 			page 58


 869:Src/aspep.c   ****                 pHandle->ASPEP_TL_State = WAITING_PAYLOAD;
 870:Src/aspep.c   ****               }
 871:Src/aspep.c   ****               else
 872:Src/aspep.c   ****               {
 873:Src/aspep.c   ****                 pHandle->badPacketFlag = ASPEP_BAD_PACKET_SIZE;
 874:Src/aspep.c   ****               }
 875:Src/aspep.c   ****               break;
 876:Src/aspep.c   ****             }
 877:Src/aspep.c   **** 
 878:Src/aspep.c   ****             case BEACON:
 879:Src/aspep.c   ****             case PING:
 880:Src/aspep.c   ****             {
 881:Src/aspep.c   ****               pHandle->NewPacketAvailable = true;
 882:Src/aspep.c   ****               /* The receiver is not reconfigure right now on purpose to avoid race condition when 
 883:Src/aspep.c   ****                 * processed in ASPEP_RXframeProcess */
 884:Src/aspep.c   ****               break;
 885:Src/aspep.c   ****             }
 886:Src/aspep.c   **** 
 887:Src/aspep.c   ****             default:
 888:Src/aspep.c   ****             {
 889:Src/aspep.c   ****               pHandle->badPacketFlag = ASPEP_BAD_PACKET_TYPE;
 890:Src/aspep.c   ****               break;
 891:Src/aspep.c   ****             }
 892:Src/aspep.c   ****           }
 893:Src/aspep.c   ****         }
 894:Src/aspep.c   ****         else
 895:Src/aspep.c   ****         {
 896:Src/aspep.c   ****           pHandle->badPacketFlag = ASPEP_BAD_CRC_HEADER;
 897:Src/aspep.c   ****         }
 898:Src/aspep.c   ****         break;
 899:Src/aspep.c   ****       }
 900:Src/aspep.c   **** 
 901:Src/aspep.c   ****       case WAITING_PAYLOAD:
 902:Src/aspep.c   ****       {
 903:Src/aspep.c   ****         pHandle->ASPEP_TL_State = WAITING_PACKET;
 904:Src/aspep.c   ****         /* Payload received, */
 905:Src/aspep.c   ****         pHandle->NewPacketAvailable = true;
 906:Src/aspep.c   ****         /* The receiver is not reconfigure right now on purpose to avoid race condition when the pa
 907:Src/aspep.c   ****           * processed in ASPEP_RXframeProcess */
 908:Src/aspep.c   ****         break;
 909:Src/aspep.c   ****       }
 910:Src/aspep.c   **** 
 911:Src/aspep.c   ****       default:
 912:Src/aspep.c   ****         break;
 2034              		.loc 1 912 9
 2035 0016 67E0     		b	.L92
 2036              	.L80:
 850:Src/aspep.c   ****         {
 2037              		.loc 1 850 47
 2038 0018 7B68     		ldr	r3, [r7, #4]
 2039 001a 1C33     		adds	r3, r3, #28
 850:Src/aspep.c   ****         {
 2040              		.loc 1 850 13
 2041 001c 1B68     		ldr	r3, [r3]
 2042 001e 1846     		mov	r0, r3
 2043 0020 FFF7FEFF 		bl	ASPEP_CheckHeaderCRC
 2044 0024 0346     		mov	r3, r0
ARM GAS  /tmp/cc0OBPYV.s 			page 59


 850:Src/aspep.c   ****         {
 2045              		.loc 1 850 12
 2046 0026 002B     		cmp	r3, #0
 2047 0028 4FD0     		beq	.L83
 852:Src/aspep.c   ****           switch (pHandle->rxPacketType)
 2048              		.loc 1 852 82
 2049 002a 7B68     		ldr	r3, [r7, #4]
 2050 002c 1B7F     		ldrb	r3, [r3, #28]	@ zero_extendqisi2
 852:Src/aspep.c   ****           switch (pHandle->rxPacketType)
 2051              		.loc 1 852 35
 2052 002e 03F00F02 		and	r2, r3, #15
 852:Src/aspep.c   ****           switch (pHandle->rxPacketType)
 2053              		.loc 1 852 33
 2054 0032 7B68     		ldr	r3, [r7, #4]
 2055 0034 9A66     		str	r2, [r3, #104]
 853:Src/aspep.c   ****           {
 2056              		.loc 1 853 26
 2057 0036 7B68     		ldr	r3, [r7, #4]
 2058 0038 9B6E     		ldr	r3, [r3, #104]
 2059 003a 062B     		cmp	r3, #6
 2060 003c 02D8     		bhi	.L84
 2061 003e 052B     		cmp	r3, #5
 2062 0040 39D2     		bcs	.L85
 2063 0042 3DE0     		b	.L86
 2064              	.L84:
 2065 0044 092B     		cmp	r3, #9
 2066 0046 3BD1     		bne	.L86
 858:Src/aspep.c   ****               if (0U == pHandle->rxLengthASPEP) /* data packet with length 0 is a valid packet */
 2067              		.loc 1 858 66
 2068 0048 7B68     		ldr	r3, [r7, #4]
 2069 004a 1C33     		adds	r3, r3, #28
 858:Src/aspep.c   ****               if (0U == pHandle->rxLengthASPEP) /* data packet with length 0 is a valid packet */
 2070              		.loc 1 858 52
 2071 004c 1B88     		ldrh	r3, [r3]
 858:Src/aspep.c   ****               if (0U == pHandle->rxLengthASPEP) /* data packet with length 0 is a valid packet */
 2072              		.loc 1 858 97
 2073 004e 1B09     		lsrs	r3, r3, #4
 2074 0050 9AB2     		uxth	r2, r3
 858:Src/aspep.c   ****               if (0U == pHandle->rxLengthASPEP) /* data packet with length 0 is a valid packet */
 2075              		.loc 1 858 38
 2076 0052 7B68     		ldr	r3, [r7, #4]
 2077 0054 A3F85C20 		strh	r2, [r3, #92]	@ movhi
 859:Src/aspep.c   ****               {
 2078              		.loc 1 859 32
 2079 0058 7B68     		ldr	r3, [r7, #4]
 2080 005a B3F85C30 		ldrh	r3, [r3, #92]
 859:Src/aspep.c   ****               {
 2081              		.loc 1 859 18
 2082 005e 002B     		cmp	r3, #0
 2083 0060 04D1     		bne	.L87
 861:Src/aspep.c   ****                 /* The receiver is not reconfigure right now on purpose to avoid race condition whe
 2084              		.loc 1 861 45
 2085 0062 7B68     		ldr	r3, [r7, #4]
 2086 0064 0122     		movs	r2, #1
 2087 0066 83F86120 		strb	r2, [r3, #97]
 875:Src/aspep.c   ****             }
 2088              		.loc 1 875 15
ARM GAS  /tmp/cc0OBPYV.s 			page 60


 2089 006a 33E0     		b	.L91
 2090              	.L87:
 865:Src/aspep.c   ****               {
 2091              		.loc 1 865 31
 2092 006c 7B68     		ldr	r3, [r7, #4]
 2093 006e B3F85C20 		ldrh	r2, [r3, #92]
 865:Src/aspep.c   ****               {
 2094              		.loc 1 865 57
 2095 0072 7B68     		ldr	r3, [r7, #4]
 2096 0074 B3F85E30 		ldrh	r3, [r3, #94]
 865:Src/aspep.c   ****               {
 2097              		.loc 1 865 23
 2098 0078 9A42     		cmp	r2, r3
 2099 007a 17D8     		bhi	.L89
 867:Src/aspep.c   ****                                         (pHandle->rxLengthASPEP + ((uint16_t)ASPEP_DATACRC_SIZE * (
 2100              		.loc 1 867 24
 2101 007c 7B68     		ldr	r3, [r7, #4]
 2102 007e 5B6D     		ldr	r3, [r3, #84]
 867:Src/aspep.c   ****                                         (pHandle->rxLengthASPEP + ((uint16_t)ASPEP_DATACRC_SIZE * (
 2103              		.loc 1 867 17
 2104 0080 7A68     		ldr	r2, [r7, #4]
 2105 0082 5069     		ldr	r0, [r2, #20]
 867:Src/aspep.c   ****                                         (pHandle->rxLengthASPEP + ((uint16_t)ASPEP_DATACRC_SIZE * (
 2106              		.loc 1 867 69
 2107 0084 7A68     		ldr	r2, [r7, #4]
 2108 0086 9469     		ldr	r4, [r2, #24]
 868:Src/aspep.c   ****                 pHandle->ASPEP_TL_State = WAITING_PAYLOAD;
 2109              		.loc 1 868 49
 2110 0088 7A68     		ldr	r2, [r7, #4]
 2111 008a B2F85C10 		ldrh	r1, [r2, #92]
 868:Src/aspep.c   ****                 pHandle->ASPEP_TL_State = WAITING_PAYLOAD;
 2112              		.loc 1 868 130
 2113 008e 7A68     		ldr	r2, [r7, #4]
 2114 0090 92F86C20 		ldrb	r2, [r2, #108]	@ zero_extendqisi2
 867:Src/aspep.c   ****                                         (pHandle->rxLengthASPEP + ((uint16_t)ASPEP_DATACRC_SIZE * (
 2115              		.loc 1 867 17
 2116 0094 92B2     		uxth	r2, r2
 2117 0096 5200     		lsls	r2, r2, #1
 2118 0098 92B2     		uxth	r2, r2
 2119 009a 0A44     		add	r2, r2, r1
 2120 009c 92B2     		uxth	r2, r2
 2121 009e 2146     		mov	r1, r4
 2122 00a0 9847     		blx	r3
 2123              	.LVL8:
 869:Src/aspep.c   ****               }
 2124              		.loc 1 869 41
 2125 00a2 7B68     		ldr	r3, [r7, #4]
 2126 00a4 0122     		movs	r2, #1
 2127 00a6 83F86520 		strb	r2, [r3, #101]
 875:Src/aspep.c   ****             }
 2128              		.loc 1 875 15
 2129 00aa 13E0     		b	.L91
 2130              	.L89:
 873:Src/aspep.c   ****               }
 2131              		.loc 1 873 40
 2132 00ac 7B68     		ldr	r3, [r7, #4]
 2133 00ae 0222     		movs	r2, #2
ARM GAS  /tmp/cc0OBPYV.s 			page 61


 2134 00b0 83F86220 		strb	r2, [r3, #98]
 875:Src/aspep.c   ****             }
 2135              		.loc 1 875 15
 2136 00b4 0EE0     		b	.L91
 2137              	.L85:
 881:Src/aspep.c   ****               /* The receiver is not reconfigure right now on purpose to avoid race condition when 
 2138              		.loc 1 881 43
 2139 00b6 7B68     		ldr	r3, [r7, #4]
 2140 00b8 0122     		movs	r2, #1
 2141 00ba 83F86120 		strb	r2, [r3, #97]
 884:Src/aspep.c   ****             }
 2142              		.loc 1 884 15
 2143 00be 09E0     		b	.L91
 2144              	.L86:
 889:Src/aspep.c   ****               break;
 2145              		.loc 1 889 38
 2146 00c0 7B68     		ldr	r3, [r7, #4]
 2147 00c2 0122     		movs	r2, #1
 2148 00c4 83F86220 		strb	r2, [r3, #98]
 890:Src/aspep.c   ****             }
 2149              		.loc 1 890 15
 2150 00c8 04E0     		b	.L91
 2151              	.L83:
 896:Src/aspep.c   ****         }
 2152              		.loc 1 896 34
 2153 00ca 7B68     		ldr	r3, [r7, #4]
 2154 00cc 0422     		movs	r2, #4
 2155 00ce 83F86220 		strb	r2, [r3, #98]
 898:Src/aspep.c   ****       }
 2156              		.loc 1 898 9
 2157 00d2 09E0     		b	.L92
 2158              	.L91:
 2159 00d4 08E0     		b	.L92
 2160              	.L81:
 903:Src/aspep.c   ****         /* Payload received, */
 2161              		.loc 1 903 33
 2162 00d6 7B68     		ldr	r3, [r7, #4]
 2163 00d8 0022     		movs	r2, #0
 2164 00da 83F86520 		strb	r2, [r3, #101]
 905:Src/aspep.c   ****         /* The receiver is not reconfigure right now on purpose to avoid race condition when the pa
 2165              		.loc 1 905 37
 2166 00de 7B68     		ldr	r3, [r7, #4]
 2167 00e0 0122     		movs	r2, #1
 2168 00e2 83F86120 		strb	r2, [r3, #97]
 908:Src/aspep.c   ****       }
 2169              		.loc 1 908 9
 2170 00e6 00BF     		nop
 2171              	.L92:
 913:Src/aspep.c   ****     }
 914:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 915:Src/aspep.c   ****   }
 916:Src/aspep.c   **** #endif
 917:Src/aspep.c   **** }
 2172              		.loc 1 917 1
 2173 00e8 00BF     		nop
 2174 00ea 0C37     		adds	r7, r7, #12
 2175              	.LCFI67:
ARM GAS  /tmp/cc0OBPYV.s 			page 62


 2176              		.cfi_def_cfa_offset 12
 2177 00ec BD46     		mov	sp, r7
 2178              	.LCFI68:
 2179              		.cfi_def_cfa_register 13
 2180              		@ sp needed
 2181 00ee 90BD     		pop	{r4, r7, pc}
 2182              		.cfi_endproc
 2183              	.LFE1449:
 2185              		.section	.text.ASPEP_HWReset,"ax",%progbits
 2186              		.align	1
 2187              		.global	ASPEP_HWReset
 2188              		.syntax unified
 2189              		.thumb
 2190              		.thumb_func
 2191              		.fpu fpv4-sp-d16
 2193              	ASPEP_HWReset:
 2194              	.LFB1450:
 918:Src/aspep.c   **** 
 919:Src/aspep.c   **** /**
 920:Src/aspep.c   ****   * @brief  Resets DMA after debugger has stopped the MCU.
 921:Src/aspep.c   ****   *
 922:Src/aspep.c   ****   * @param  *pHandle Handler of the current instance of the ASPEP component
 923:Src/aspep.c   ****   */
 924:Src/aspep.c   **** void ASPEP_HWReset(ASPEP_Handle_t *pHandle)
 925:Src/aspep.c   **** {
 2195              		.loc 1 925 1
 2196              		.cfi_startproc
 2197              		@ args = 0, pretend = 0, frame = 8
 2198              		@ frame_needed = 1, uses_anonymous_args = 0
 2199 0000 80B5     		push	{r7, lr}
 2200              	.LCFI69:
 2201              		.cfi_def_cfa_offset 8
 2202              		.cfi_offset 7, -8
 2203              		.cfi_offset 14, -4
 2204 0002 82B0     		sub	sp, sp, #8
 2205              	.LCFI70:
 2206              		.cfi_def_cfa_offset 16
 2207 0004 00AF     		add	r7, sp, #0
 2208              	.LCFI71:
 2209              		.cfi_def_cfa_register 7
 2210 0006 7860     		str	r0, [r7, #4]
 926:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 927:Src/aspep.c   ****   if (NULL == pHandle)
 928:Src/aspep.c   ****   {
 929:Src/aspep.c   ****     /* Nothing to do */
 930:Src/aspep.c   ****   }
 931:Src/aspep.c   ****   else
 932:Src/aspep.c   ****   {
 933:Src/aspep.c   **** #endif
 934:Src/aspep.c   ****     /* We must reset the RX state machine to be sure to not be in Waiting packet state */
 935:Src/aspep.c   ****     /* Otherwise the arrival of a new packet will trigger a NewPacketAvailable despite */
 936:Src/aspep.c   ****     /* the fact that bytes have been lost because of overrun (debugger paused for instance) */
 937:Src/aspep.c   ****     pHandle->ASPEP_TL_State = WAITING_PACKET;
 2211              		.loc 1 937 29
 2212 0008 7B68     		ldr	r3, [r7, #4]
 2213 000a 0022     		movs	r2, #0
 2214 000c 83F86520 		strb	r2, [r3, #101]
ARM GAS  /tmp/cc0OBPYV.s 			page 63


 938:Src/aspep.c   ****     pHandle->fASPEP_cfg_recept(pHandle->ASPEPIp, pHandle->rxHeader, ASPEP_HEADER_SIZE);
 2215              		.loc 1 938 12
 2216 0010 7B68     		ldr	r3, [r7, #4]
 2217 0012 5B6D     		ldr	r3, [r3, #84]
 2218              		.loc 1 938 5
 2219 0014 7A68     		ldr	r2, [r7, #4]
 2220 0016 5069     		ldr	r0, [r2, #20]
 2221              		.loc 1 938 57
 2222 0018 7A68     		ldr	r2, [r7, #4]
 2223 001a 02F11C01 		add	r1, r2, #28
 2224              		.loc 1 938 5
 2225 001e 0422     		movs	r2, #4
 2226 0020 9847     		blx	r3
 2227              	.LVL9:
 939:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 940:Src/aspep.c   ****   }
 941:Src/aspep.c   **** #endif
 942:Src/aspep.c   **** }
 2228              		.loc 1 942 1
 2229 0022 00BF     		nop
 2230 0024 0837     		adds	r7, r7, #8
 2231              	.LCFI72:
 2232              		.cfi_def_cfa_offset 8
 2233 0026 BD46     		mov	sp, r7
 2234              	.LCFI73:
 2235              		.cfi_def_cfa_register 13
 2236              		@ sp needed
 2237 0028 80BD     		pop	{r7, pc}
 2238              		.cfi_endproc
 2239              	.LFE1450:
 2241              		.text
 2242              	.Letext0:
 2243              		.file 3 "/usr/share/gcc-arm-none-eabi-10-2020-q4-major/arm-none-eabi/include/machine/_default_type
 2244              		.file 4 "/usr/share/gcc-arm-none-eabi-10-2020-q4-major/arm-none-eabi/include/sys/_stdint.h"
 2245              		.file 5 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_tim.h"
 2246              		.file 6 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_usart.h"
 2247              		.file 7 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_dma.h"
 2248              		.file 8 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/mcptl.h"
 2249              		.file 9 "Inc/aspep.h"
ARM GAS  /tmp/cc0OBPYV.s 			page 64


DEFINED SYMBOLS
                            *ABS*:0000000000000000 aspep.c
     /tmp/cc0OBPYV.s:18     .rodata.OFFSET_TAB_CCMRx:0000000000000000 $d
     /tmp/cc0OBPYV.s:21     .rodata.OFFSET_TAB_CCMRx:0000000000000000 OFFSET_TAB_CCMRx
     /tmp/cc0OBPYV.s:24     .rodata.SHIFT_TAB_OCxx:0000000000000000 $d
     /tmp/cc0OBPYV.s:27     .rodata.SHIFT_TAB_OCxx:0000000000000000 SHIFT_TAB_OCxx
     /tmp/cc0OBPYV.s:30     .rodata.SHIFT_TAB_ICxx:0000000000000000 $d
     /tmp/cc0OBPYV.s:33     .rodata.SHIFT_TAB_ICxx:0000000000000000 SHIFT_TAB_ICxx
     /tmp/cc0OBPYV.s:36     .rodata.SHIFT_TAB_CCxP:0000000000000000 $d
     /tmp/cc0OBPYV.s:39     .rodata.SHIFT_TAB_CCxP:0000000000000000 SHIFT_TAB_CCxP
     /tmp/cc0OBPYV.s:42     .rodata.SHIFT_TAB_OISx:0000000000000000 $d
     /tmp/cc0OBPYV.s:45     .rodata.SHIFT_TAB_OISx:0000000000000000 SHIFT_TAB_OISx
     /tmp/cc0OBPYV.s:48     .rodata.USART_PRESCALER_TAB:0000000000000000 $d
     /tmp/cc0OBPYV.s:51     .rodata.USART_PRESCALER_TAB:0000000000000000 USART_PRESCALER_TAB
     /tmp/cc0OBPYV.s:65     .rodata.CHANNEL_OFFSET_TAB:0000000000000000 $d
     /tmp/cc0OBPYV.s:68     .rodata.CHANNEL_OFFSET_TAB:0000000000000000 CHANNEL_OFFSET_TAB
     /tmp/cc0OBPYV.s:71     .rodata.CRC4_Lookup8:0000000000000000 $d
     /tmp/cc0OBPYV.s:74     .rodata.CRC4_Lookup8:0000000000000000 CRC4_Lookup8
     /tmp/cc0OBPYV.s:96     .rodata.CRC4_Lookup4:0000000000000000 $d
     /tmp/cc0OBPYV.s:99     .rodata.CRC4_Lookup4:0000000000000000 CRC4_Lookup4
     /tmp/cc0OBPYV.s:103    .text.ASPEP_ComputeHeaderCRC:0000000000000000 $t
     /tmp/cc0OBPYV.s:110    .text.ASPEP_ComputeHeaderCRC:0000000000000000 ASPEP_ComputeHeaderCRC
     /tmp/cc0OBPYV.s:222    .text.ASPEP_ComputeHeaderCRC:0000000000000084 $d
     /tmp/cc0OBPYV.s:228    .text.ASPEP_CheckHeaderCRC:0000000000000000 $t
     /tmp/cc0OBPYV.s:234    .text.ASPEP_CheckHeaderCRC:0000000000000000 ASPEP_CheckHeaderCRC
     /tmp/cc0OBPYV.s:333    .text.ASPEP_CheckHeaderCRC:0000000000000074 $d
     /tmp/cc0OBPYV.s:338    .text.ASPEP_start:0000000000000000 $t
     /tmp/cc0OBPYV.s:345    .text.ASPEP_start:0000000000000000 ASPEP_start
     /tmp/cc0OBPYV.s:411    .text.ASPEP_sendBeacon:0000000000000000 $t
     /tmp/cc0OBPYV.s:418    .text.ASPEP_sendBeacon:0000000000000000 ASPEP_sendBeacon
     /tmp/cc0OBPYV.s:1164   .text.ASPEP_TXframeProcess:0000000000000000 ASPEP_TXframeProcess
     /tmp/cc0OBPYV.s:500    .text.ASPEP_sendNack:0000000000000000 $t
     /tmp/cc0OBPYV.s:506    .text.ASPEP_sendNack:0000000000000000 ASPEP_sendNack
     /tmp/cc0OBPYV.s:566    .text.ASPEP_sendPing:0000000000000000 $t
     /tmp/cc0OBPYV.s:573    .text.ASPEP_sendPing:0000000000000000 ASPEP_sendPing
     /tmp/cc0OBPYV.s:671    .text.ASPEP_getBuffer:0000000000000000 $t
     /tmp/cc0OBPYV.s:678    .text.ASPEP_getBuffer:0000000000000000 ASPEP_getBuffer
     /tmp/cc0OBPYV.s:822    .text.ASPEP_CheckBeacon:0000000000000000 $t
     /tmp/cc0OBPYV.s:828    .text.ASPEP_CheckBeacon:0000000000000000 ASPEP_CheckBeacon
     /tmp/cc0OBPYV.s:1006   .text.ASPEP_sendPacket:0000000000000000 $t
     /tmp/cc0OBPYV.s:1013   .text.ASPEP_sendPacket:0000000000000000 ASPEP_sendPacket
     /tmp/cc0OBPYV.s:1158   .text.ASPEP_TXframeProcess:0000000000000000 $t
     /tmp/cc0OBPYV.s:1402   .text.ASPEP_HWDataTransmittedIT:0000000000000000 $t
     /tmp/cc0OBPYV.s:1409   .text.ASPEP_HWDataTransmittedIT:0000000000000000 ASPEP_HWDataTransmittedIT
     /tmp/cc0OBPYV.s:1642   .text.ASPEP_RXframeProcess:0000000000000000 $t
     /tmp/cc0OBPYV.s:1649   .text.ASPEP_RXframeProcess:0000000000000000 ASPEP_RXframeProcess
     /tmp/cc0OBPYV.s:2000   .text.ASPEP_HWDataReceivedIT:0000000000000000 $t
     /tmp/cc0OBPYV.s:2007   .text.ASPEP_HWDataReceivedIT:0000000000000000 ASPEP_HWDataReceivedIT
     /tmp/cc0OBPYV.s:2186   .text.ASPEP_HWReset:0000000000000000 $t
     /tmp/cc0OBPYV.s:2193   .text.ASPEP_HWReset:0000000000000000 ASPEP_HWReset

NO UNDEFINED SYMBOLS
