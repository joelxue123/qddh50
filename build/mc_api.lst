ARM GAS  /tmp/ccw08S9Z.s 			page 1


   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 2
  13              		.file	"mc_api.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.rodata.OFFSET_TAB_CCMRx,"a"
  18              		.align	2
  21              	OFFSET_TAB_CCMRx:
  22 0000 00000000 		.ascii	"\000\000\000\000\004\004\004\00488"
  22      04040404 
  22      3838
  23              		.section	.rodata.SHIFT_TAB_OCxx,"a"
  24              		.align	2
  27              	SHIFT_TAB_OCxx:
  28 0000 00000800 		.ascii	"\000\000\010\000\000\000\010\000\000\010"
  28      00000800 
  28      0008
  29              		.section	.rodata.SHIFT_TAB_ICxx,"a"
  30              		.align	2
  33              	SHIFT_TAB_ICxx:
  34 0000 00000800 		.ascii	"\000\000\010\000\000\000\010\000\000\000"
  34      00000800 
  34      0000
  35              		.section	.rodata.SHIFT_TAB_CCxP,"a"
  36              		.align	2
  39              	SHIFT_TAB_CCxP:
  40 0000 00020406 		.ascii	"\000\002\004\006\010\012\014\016\020\024"
  40      080A0C0E 
  40      1014
  41              		.section	.rodata.SHIFT_TAB_OISx,"a"
  42              		.align	2
  45              	SHIFT_TAB_OISx:
  46 0000 00010203 		.ascii	"\000\001\002\003\004\005\006\007\010\012"
  46      04050607 
  46      080A
  47              		.section	.rodata.USART_PRESCALER_TAB,"a"
  48              		.align	2
  51              	USART_PRESCALER_TAB:
  52 0000 01000000 		.word	1
  53 0004 02000000 		.word	2
  54 0008 04000000 		.word	4
  55 000c 06000000 		.word	6
  56 0010 08000000 		.word	8
  57 0014 0A000000 		.word	10
  58 0018 0C000000 		.word	12
  59 001c 10000000 		.word	16
ARM GAS  /tmp/ccw08S9Z.s 			page 2


  60 0020 20000000 		.word	32
  61 0024 40000000 		.word	64
  62 0028 80000000 		.word	128
  63 002c 00010000 		.word	256
  64              		.section	.rodata.CHANNEL_OFFSET_TAB,"a"
  65              		.align	2
  68              	CHANNEL_OFFSET_TAB:
  69 0000 081C3044 		.ascii	"\010\0340DXl"
  69      586C
  70              		.section	.text.MC_StartMotor1,"ax",%progbits
  71              		.align	1
  72              		.weak	MC_StartMotor1
  73              		.arch armv7e-m
  74              		.syntax unified
  75              		.thumb
  76              		.thumb_func
  77              		.fpu fpv4-sp-d16
  79              	MC_StartMotor1:
  80              	.LFB1713:
  81              		.file 1 "Src/mc_api.c"
   1:Src/mc_api.c  **** 
   2:Src/mc_api.c  **** /**
   3:Src/mc_api.c  ****   ******************************************************************************
   4:Src/mc_api.c  ****   * @file    mc_api.c
   5:Src/mc_api.c  ****   * @author  Motor Control SDK Team, ST Microelectronics
   6:Src/mc_api.c  ****   * @brief   This file implements the high level interface of the Motor Control SDK.
   7:Src/mc_api.c  ****   ******************************************************************************
   8:Src/mc_api.c  ****   * @attention
   9:Src/mc_api.c  ****   *
  10:Src/mc_api.c  ****   * <h2><center>&copy; Copyright (c) 2024 STMicroelectronics.
  11:Src/mc_api.c  ****   * All rights reserved.</center></h2>
  12:Src/mc_api.c  ****   *
  13:Src/mc_api.c  ****   * This software component is licensed by ST under Ultimate Liberty license
  14:Src/mc_api.c  ****   * SLA0044, the "License"; You may not use this file except in compliance with
  15:Src/mc_api.c  ****   * the License. You may obtain a copy of the License at:
  16:Src/mc_api.c  ****   *                             www.st.com/SLA0044
  17:Src/mc_api.c  ****   *
  18:Src/mc_api.c  ****   ******************************************************************************
  19:Src/mc_api.c  ****   * @ingroup MCIAPI
  20:Src/mc_api.c  ****   */
  21:Src/mc_api.c  **** 
  22:Src/mc_api.c  **** #include "mc_interface.h"
  23:Src/mc_api.c  **** #include "mc_api.h"
  24:Src/mc_api.c  **** #include "mc_config.h"
  25:Src/mc_api.c  **** #include "mcp.h"
  26:Src/mc_api.c  **** 
  27:Src/mc_api.c  **** /** @addtogroup MCSDK
  28:Src/mc_api.c  ****   * @{
  29:Src/mc_api.c  ****   */
  30:Src/mc_api.c  **** 
  31:Src/mc_api.c  **** /**
  32:Src/mc_api.c  ****   * @defgroup CAI Application Programming Interface
  33:Src/mc_api.c  ****   * @brief Interface for Motor Control applications using the classic SDK
  34:Src/mc_api.c  ****   *
  35:Src/mc_api.c  ****   * @{
  36:Src/mc_api.c  ****   */
  37:Src/mc_api.c  **** 
ARM GAS  /tmp/ccw08S9Z.s 			page 3


  38:Src/mc_api.c  **** /** @defgroup MCIAPI Motor Control API
  39:Src/mc_api.c  ****   *
  40:Src/mc_api.c  ****   * @brief High level Programming Interface of the Motor Control SDK
  41:Src/mc_api.c  ****   *
  42:Src/mc_api.c  ****   *  This interface allows for performing basic operations on the motor(s) driven by an
  43:Src/mc_api.c  ****   * Motor Control SDK based application. With it, motors can be started and stopped, speed or
  44:Src/mc_api.c  ****   * torque ramps can be programmed and executed and information on the state of the motors can
  45:Src/mc_api.c  ****   * be retrieved, among others.
  46:Src/mc_api.c  ****   *
  47:Src/mc_api.c  ****   *  This interface consists in functions that target a specific motor, indicated in their name.
  48:Src/mc_api.c  ****   * These functions aims at being the main interface used by an Application to control motors.
  49:Src/mc_api.c  ****   *
  50:Src/mc_api.c  ****   *  The current Motor Control API can cope with up to 2 motors.
  51:Src/mc_api.c  ****   * @{
  52:Src/mc_api.c  ****   */
  53:Src/mc_api.c  **** 
  54:Src/mc_api.c  **** /**
  55:Src/mc_api.c  ****   * @brief  Initiates the start-up procedure for Motor 1
  56:Src/mc_api.c  ****   *
  57:Src/mc_api.c  ****   *  If the state machine of Motor 1 is in #IDLE state, the command is immediately
  58:Src/mc_api.c  ****   * executed. Otherwise the command is discarded. The Application can check the
  59:Src/mc_api.c  ****   * return value to know whether the command was executed or discarded.
  60:Src/mc_api.c  ****   *
  61:Src/mc_api.c  ****   *  One of the following commands must be executed before calling MC_StartMotor1()
  62:Src/mc_api.c  ****   * in order to set a torque or a speed reference:
  63:Src/mc_api.c  ****   *
  64:Src/mc_api.c  ****   * - MC_ProgramSpeedRampMotor1()
  65:Src/mc_api.c  ****   * - MC_ProgramTorqueRampMotor1()
  66:Src/mc_api.c  ****   * - MC_SetCurrentReferenceMotor1()
  67:Src/mc_api.c  ****   *
  68:Src/mc_api.c  ****   * Failing to do so results in an unpredictable behaviour.
  69:Src/mc_api.c  ****   *
  70:Src/mc_api.c  ****   * If the offsets of the current measurement circuitry offsets are not known yet,
  71:Src/mc_api.c  ****   * an offset calibration procedure is executed to measure them prior to acutally
  72:Src/mc_api.c  ****   * starting up the motor.
  73:Src/mc_api.c  ****   *
  74:Src/mc_api.c  ****   * @note The MCI_StartMotor1 command only triggers the execution of the start-up
  75:Src/mc_api.c  ****   * procedure (or eventually the offset calibration procedure) and returns
  76:Src/mc_api.c  ****   * immediately after. It is not blocking the execution of the application until
  77:Src/mc_api.c  ****   * the motor is indeed running in steady state. If the application needs to wait
  78:Src/mc_api.c  ****   * for the motor to be running in steady state, the application has to check the
  79:Src/mc_api.c  ****   * state machine of the motor and verify that the #RUN state has been reached.
  80:Src/mc_api.c  ****   * Note also that if the startup sequence fails the #RUN state may never be reached.
  81:Src/mc_api.c  ****   *
  82:Src/mc_api.c  ****   * @retval returns true if the command is successfully executed, false otherwise.
  83:Src/mc_api.c  ****   */
  84:Src/mc_api.c  **** __weak bool MC_StartMotor1(void)
  85:Src/mc_api.c  **** {
  82              		.loc 1 85 1
  83              		.cfi_startproc
  84              		@ args = 0, pretend = 0, frame = 0
  85              		@ frame_needed = 1, uses_anonymous_args = 0
  86 0000 80B5     		push	{r7, lr}
  87              	.LCFI0:
  88              		.cfi_def_cfa_offset 8
  89              		.cfi_offset 7, -8
  90              		.cfi_offset 14, -4
ARM GAS  /tmp/ccw08S9Z.s 			page 4


  91 0002 00AF     		add	r7, sp, #0
  92              	.LCFI1:
  93              		.cfi_def_cfa_register 7
  86:Src/mc_api.c  ****   return (MCI_StartMotor(pMCI[M1]));
  94              		.loc 1 86 11
  95 0004 034B     		ldr	r3, .L3
  96 0006 1B68     		ldr	r3, [r3]
  97 0008 1846     		mov	r0, r3
  98 000a FFF7FEFF 		bl	MCI_StartMotor
  99 000e 0346     		mov	r3, r0
  87:Src/mc_api.c  **** }
 100              		.loc 1 87 1
 101 0010 1846     		mov	r0, r3
 102 0012 80BD     		pop	{r7, pc}
 103              	.L4:
 104              		.align	2
 105              	.L3:
 106 0014 00000000 		.word	pMCI
 107              		.cfi_endproc
 108              	.LFE1713:
 110              		.section	.text.MC_StopMotor1,"ax",%progbits
 111              		.align	1
 112              		.weak	MC_StopMotor1
 113              		.syntax unified
 114              		.thumb
 115              		.thumb_func
 116              		.fpu fpv4-sp-d16
 118              	MC_StopMotor1:
 119              	.LFB1714:
  88:Src/mc_api.c  **** 
  89:Src/mc_api.c  **** /**
  90:Src/mc_api.c  ****   * @brief  Initiates the stop procedure for Motor 1.
  91:Src/mc_api.c  ****   *
  92:Src/mc_api.c  ****   *  If the state machine is in any state but the #ICLWAIT, #IDLE, FAULT_NOW and
  93:Src/mc_api.c  ****   * #FAULT_OVER states, the command is immediately executed. Otherwise, it is
  94:Src/mc_api.c  ****   * discarded. The Application can check the return value to know whether the
  95:Src/mc_api.c  ****   * command was executed or discarded.
  96:Src/mc_api.c  ****   *
  97:Src/mc_api.c  ****   * @note The MC_StopMotor1() command only triggers the stop motor procedure
  98:Src/mc_api.c  ****   * and then returns. It is not blocking the application until the motor is indeed
  99:Src/mc_api.c  ****   * stopped. To know if it has stopped, the application can query the motor's state
 100:Src/mc_api.c  ****   * machine and check if the #IDLE state has been reached.
 101:Src/mc_api.c  ****   *
 102:Src/mc_api.c  ****   * @retval returns true if the command is successfully executed, false otherwise.
 103:Src/mc_api.c  ****   */
 104:Src/mc_api.c  **** __weak bool MC_StopMotor1(void)
 105:Src/mc_api.c  **** {
 120              		.loc 1 105 1
 121              		.cfi_startproc
 122              		@ args = 0, pretend = 0, frame = 0
 123              		@ frame_needed = 1, uses_anonymous_args = 0
 124 0000 80B5     		push	{r7, lr}
 125              	.LCFI2:
 126              		.cfi_def_cfa_offset 8
 127              		.cfi_offset 7, -8
 128              		.cfi_offset 14, -4
 129 0002 00AF     		add	r7, sp, #0
ARM GAS  /tmp/ccw08S9Z.s 			page 5


 130              	.LCFI3:
 131              		.cfi_def_cfa_register 7
 106:Src/mc_api.c  ****   return (MCI_StopMotor(pMCI[M1]));
 132              		.loc 1 106 11
 133 0004 034B     		ldr	r3, .L7
 134 0006 1B68     		ldr	r3, [r3]
 135 0008 1846     		mov	r0, r3
 136 000a FFF7FEFF 		bl	MCI_StopMotor
 137 000e 0346     		mov	r3, r0
 107:Src/mc_api.c  **** }
 138              		.loc 1 107 1
 139 0010 1846     		mov	r0, r3
 140 0012 80BD     		pop	{r7, pc}
 141              	.L8:
 142              		.align	2
 143              	.L7:
 144 0014 00000000 		.word	pMCI
 145              		.cfi_endproc
 146              	.LFE1714:
 148              		.section	.text.MC_ProgramSpeedRampMotor1,"ax",%progbits
 149              		.align	1
 150              		.weak	MC_ProgramSpeedRampMotor1
 151              		.syntax unified
 152              		.thumb
 153              		.thumb_func
 154              		.fpu fpv4-sp-d16
 156              	MC_ProgramSpeedRampMotor1:
 157              	.LFB1715:
 108:Src/mc_api.c  **** 
 109:Src/mc_api.c  **** /**
 110:Src/mc_api.c  ****   * @brief Programs a speed ramp for Motor 1 for later or immediate execution.
 111:Src/mc_api.c  ****   *
 112:Src/mc_api.c  ****   *  A speed ramp is a linear change from the current speed reference to the @p hFinalSpeed
 113:Src/mc_api.c  ****   * target speed in the given @p hDurationms time.
 114:Src/mc_api.c  ****   *
 115:Src/mc_api.c  ****   *  Invoking the MC_ProgramSpeedRampMotor1() function programs a new speed ramp
 116:Src/mc_api.c  ****   * with the provided parameters. The programmed ramp is executed immediately if
 117:Src/mc_api.c  ****   * Motor 1's state machine is in the #RUN states. Otherwise, the ramp is buffered
 118:Src/mc_api.c  ****   * and will be executed when the state machine reaches any of the aforementioned state.
 119:Src/mc_api.c  ****   *
 120:Src/mc_api.c  ****   *  The Application can check the status of the command with the MC_GetCommandStateMotor1()
 121:Src/mc_api.c  ****   * to know whether the last command was executed immediately or not.
 122:Src/mc_api.c  ****   *
 123:Src/mc_api.c  ****   * Only one command can be buffered at any given time. If another ramp - whether a
 124:Src/mc_api.c  ****   * speed or a torque one - or if another buffered command is programmed before the
 125:Src/mc_api.c  ****   * current one has completed, the latter replaces the former.
 126:Src/mc_api.c  ****   *
 127:Src/mc_api.c  ****   * @note A ramp cannot reverse the rotation direction if the Application is using
 128:Src/mc_api.c  ****   * sensorless motor control techniques. If the sign of the hFinalSpeed parameter
 129:Src/mc_api.c  ****   * differs from that of the current speed, the ramp will not complete and a Speed
 130:Src/mc_api.c  ****   * Feedback error (#MC_SPEED_FDBK) will occur when the rotation speed is about to
 131:Src/mc_api.c  ****   * reach 0 rpm.
 132:Src/mc_api.c  ****   *
 133:Src/mc_api.c  ****   * @param  hFinalSpeed Mechanical rotor speed reference at the end of the ramp.
 134:Src/mc_api.c  ****   *                     Expressed in the unit defined by #SPEED_UNIT.
 135:Src/mc_api.c  ****   * @param  hDurationms Duration of the ramp expressed in milliseconds. It
 136:Src/mc_api.c  ****   *         is possible to set 0 to perform an instantaneous change in the speed
ARM GAS  /tmp/ccw08S9Z.s 			page 6


 137:Src/mc_api.c  ****   *         value.
 138:Src/mc_api.c  ****   */
 139:Src/mc_api.c  **** __weak void MC_ProgramSpeedRampMotor1(int16_t hFinalSpeed, uint16_t hDurationms)
 140:Src/mc_api.c  **** {
 158              		.loc 1 140 1
 159              		.cfi_startproc
 160              		@ args = 0, pretend = 0, frame = 8
 161              		@ frame_needed = 1, uses_anonymous_args = 0
 162 0000 80B5     		push	{r7, lr}
 163              	.LCFI4:
 164              		.cfi_def_cfa_offset 8
 165              		.cfi_offset 7, -8
 166              		.cfi_offset 14, -4
 167 0002 82B0     		sub	sp, sp, #8
 168              	.LCFI5:
 169              		.cfi_def_cfa_offset 16
 170 0004 00AF     		add	r7, sp, #0
 171              	.LCFI6:
 172              		.cfi_def_cfa_register 7
 173 0006 0346     		mov	r3, r0
 174 0008 0A46     		mov	r2, r1
 175 000a FB80     		strh	r3, [r7, #6]	@ movhi
 176 000c 1346     		mov	r3, r2	@ movhi
 177 000e BB80     		strh	r3, [r7, #4]	@ movhi
 141:Src/mc_api.c  ****   MCI_ExecSpeedRamp(pMCI[M1], hFinalSpeed, hDurationms);
 178              		.loc 1 141 3
 179 0010 054B     		ldr	r3, .L10
 180 0012 1B68     		ldr	r3, [r3]
 181 0014 BA88     		ldrh	r2, [r7, #4]
 182 0016 B7F90610 		ldrsh	r1, [r7, #6]
 183 001a 1846     		mov	r0, r3
 184 001c FFF7FEFF 		bl	MCI_ExecSpeedRamp
 142:Src/mc_api.c  **** }
 185              		.loc 1 142 1
 186 0020 00BF     		nop
 187 0022 0837     		adds	r7, r7, #8
 188              	.LCFI7:
 189              		.cfi_def_cfa_offset 8
 190 0024 BD46     		mov	sp, r7
 191              	.LCFI8:
 192              		.cfi_def_cfa_register 13
 193              		@ sp needed
 194 0026 80BD     		pop	{r7, pc}
 195              	.L11:
 196              		.align	2
 197              	.L10:
 198 0028 00000000 		.word	pMCI
 199              		.cfi_endproc
 200              	.LFE1715:
 202              		.section	.text.MC_ProgramSpeedRampMotor1_F,"ax",%progbits
 203              		.align	1
 204              		.weak	MC_ProgramSpeedRampMotor1_F
 205              		.syntax unified
 206              		.thumb
 207              		.thumb_func
 208              		.fpu fpv4-sp-d16
 210              	MC_ProgramSpeedRampMotor1_F:
ARM GAS  /tmp/ccw08S9Z.s 			page 7


 211              	.LFB1716:
 143:Src/mc_api.c  **** 
 144:Src/mc_api.c  **** /**
 145:Src/mc_api.c  ****   * @brief Programs a speed ramp for Motor 1 for later or immediate execution.
 146:Src/mc_api.c  ****   *
 147:Src/mc_api.c  ****   *  A speed ramp is a linear change from the current speed reference to the @p FinalSpeed
 148:Src/mc_api.c  ****   * target speed in the given @p hDurationms time.
 149:Src/mc_api.c  ****   *
 150:Src/mc_api.c  ****   *  Invoking the MC_ProgramSpeedRampMotor1() function programs a new speed ramp
 151:Src/mc_api.c  ****   * with the provided parameters. The programmed ramp is executed immediately if
 152:Src/mc_api.c  ****   * Motor 1's state machine is in the #RUN states. Otherwise, the ramp is buffered
 153:Src/mc_api.c  ****   * and will be executed when the state machine reaches any of the aforementioned state.
 154:Src/mc_api.c  ****   *
 155:Src/mc_api.c  ****   *  The Application can check the status of the command with the MC_GetCommandStateMotor1()
 156:Src/mc_api.c  ****   * to know whether the last command was executed immediately or not.
 157:Src/mc_api.c  ****   *
 158:Src/mc_api.c  ****   * Only one command can be buffered at any given time. If another ramp - whether a
 159:Src/mc_api.c  ****   * speed or a torque one - or if another buffered command is programmed before the
 160:Src/mc_api.c  ****   * current one has completed, the latter replaces the former.
 161:Src/mc_api.c  ****   *
 162:Src/mc_api.c  ****   * @note A ramp cannot reverse the rotation direction if the Application is using
 163:Src/mc_api.c  ****   * sensorless motor control techniques. If the sign of the hFinalSpeed parameter
 164:Src/mc_api.c  ****   * differs from that of the current speed, the ramp will not complete and a Speed
 165:Src/mc_api.c  ****   * Feedback error (#MC_SPEED_FDBK) will occur when the rotation speed is about to
 166:Src/mc_api.c  ****   * reach 0 rpm.
 167:Src/mc_api.c  ****   *
 168:Src/mc_api.c  ****   * @param  FinalSpeed Mechanical rotor speed reference at the end of the ramp.
 169:Src/mc_api.c  ****   *         Expressed in rpm.
 170:Src/mc_api.c  ****   * @param  hDurationms Duration of the ramp expressed in milliseconds. It
 171:Src/mc_api.c  ****   *         is possible to set 0 to perform an instantaneous change in the speed
 172:Src/mc_api.c  ****   *         value.
 173:Src/mc_api.c  ****   */
 174:Src/mc_api.c  **** __weak void MC_ProgramSpeedRampMotor1_F(float_t FinalSpeed, uint16_t hDurationms)
 175:Src/mc_api.c  **** {
 212              		.loc 1 175 1
 213              		.cfi_startproc
 214              		@ args = 0, pretend = 0, frame = 8
 215              		@ frame_needed = 1, uses_anonymous_args = 0
 216 0000 80B5     		push	{r7, lr}
 217              	.LCFI9:
 218              		.cfi_def_cfa_offset 8
 219              		.cfi_offset 7, -8
 220              		.cfi_offset 14, -4
 221 0002 82B0     		sub	sp, sp, #8
 222              	.LCFI10:
 223              		.cfi_def_cfa_offset 16
 224 0004 00AF     		add	r7, sp, #0
 225              	.LCFI11:
 226              		.cfi_def_cfa_register 7
 227 0006 87ED010A 		vstr.32	s0, [r7, #4]
 228 000a 0346     		mov	r3, r0
 229 000c 7B80     		strh	r3, [r7, #2]	@ movhi
 176:Src/mc_api.c  ****   MCI_ExecSpeedRamp_F(pMCI[M1], FinalSpeed, hDurationms);
 230              		.loc 1 176 3
 231 000e 064B     		ldr	r3, .L13
 232 0010 1B68     		ldr	r3, [r3]
 233 0012 7A88     		ldrh	r2, [r7, #2]
ARM GAS  /tmp/ccw08S9Z.s 			page 8


 234 0014 1146     		mov	r1, r2
 235 0016 97ED010A 		vldr.32	s0, [r7, #4]
 236 001a 1846     		mov	r0, r3
 237 001c FFF7FEFF 		bl	MCI_ExecSpeedRamp_F
 177:Src/mc_api.c  **** }
 238              		.loc 1 177 1
 239 0020 00BF     		nop
 240 0022 0837     		adds	r7, r7, #8
 241              	.LCFI12:
 242              		.cfi_def_cfa_offset 8
 243 0024 BD46     		mov	sp, r7
 244              	.LCFI13:
 245              		.cfi_def_cfa_register 13
 246              		@ sp needed
 247 0026 80BD     		pop	{r7, pc}
 248              	.L14:
 249              		.align	2
 250              	.L13:
 251 0028 00000000 		.word	pMCI
 252              		.cfi_endproc
 253              	.LFE1716:
 255              		.section	.text.MC_ProgramTorqueRampMotor1,"ax",%progbits
 256              		.align	1
 257              		.weak	MC_ProgramTorqueRampMotor1
 258              		.syntax unified
 259              		.thumb
 260              		.thumb_func
 261              		.fpu fpv4-sp-d16
 263              	MC_ProgramTorqueRampMotor1:
 264              	.LFB1717:
 178:Src/mc_api.c  **** 
 179:Src/mc_api.c  **** /**
 180:Src/mc_api.c  ****   * @brief Programs a torque ramp for Motor 1 for later or immediate execution.
 181:Src/mc_api.c  ****   *
 182:Src/mc_api.c  ****   *  A torque ramp is a linear change from the current torque reference to the @p hFinalTorque
 183:Src/mc_api.c  ****   * target torque reference in the given @p hDurationms time.
 184:Src/mc_api.c  ****   *
 185:Src/mc_api.c  ****   *  Invoking the MC_ProgramTorqueRampMotor1() function programs a new torque ramp
 186:Src/mc_api.c  ****   * with the provided parameters. The programmed ramp is executed immediately if
 187:Src/mc_api.c  ****   * Motor 1's state machine is in the #RUN states. Otherwise, the ramp is buffered
 188:Src/mc_api.c  ****   * and will be executed when the state machine reaches any of the aforementioned state.
 189:Src/mc_api.c  ****   *
 190:Src/mc_api.c  ****   *  The Application can check the status of the command with the MC_GetCommandStateMotor1()
 191:Src/mc_api.c  ****   * to know whether the last command was executed immediately or not.
 192:Src/mc_api.c  ****   *
 193:Src/mc_api.c  ****   * Only one command can be buffered at any given time. If another ramp - whether a
 194:Src/mc_api.c  ****   * torque or a speed one - or if another buffered command is programmed before the
 195:Src/mc_api.c  ****   * current one has completed, the latter replaces the former.
 196:Src/mc_api.c  ****   *
 197:Src/mc_api.c  ****   * @note A ramp cannot reverse the rotation direction if the Application is using
 198:Src/mc_api.c  ****   * sensorless motor control techniques. If the sign of the hFinalTorque parameter
 199:Src/mc_api.c  ****   * differs from that of the current torque, the ramp will not complete and a Speed
 200:Src/mc_api.c  ****   * Feedback error (#MC_SPEED_FDBK) will occur when the rotation speed is about to
 201:Src/mc_api.c  ****   * reach 0 rpm.
 202:Src/mc_api.c  ****   *
 203:Src/mc_api.c  ****   * @param  hFinalTorque Mechanical motor torque reference at the end of the ramp.
 204:Src/mc_api.c  ****   *         This value represents actually the Iq current expressed in digit.
ARM GAS  /tmp/ccw08S9Z.s 			page 9


 205:Src/mc_api.c  ****   * @param  hDurationms Duration of the ramp expressed in milliseconds. It
 206:Src/mc_api.c  ****   *         is possible to set 0 to perform an instantaneous change in the torque
 207:Src/mc_api.c  ****   *         value.
 208:Src/mc_api.c  ****   */
 209:Src/mc_api.c  **** __weak void MC_ProgramTorqueRampMotor1(int16_t hFinalTorque, uint16_t hDurationms)
 210:Src/mc_api.c  **** {
 265              		.loc 1 210 1
 266              		.cfi_startproc
 267              		@ args = 0, pretend = 0, frame = 8
 268              		@ frame_needed = 1, uses_anonymous_args = 0
 269 0000 80B5     		push	{r7, lr}
 270              	.LCFI14:
 271              		.cfi_def_cfa_offset 8
 272              		.cfi_offset 7, -8
 273              		.cfi_offset 14, -4
 274 0002 82B0     		sub	sp, sp, #8
 275              	.LCFI15:
 276              		.cfi_def_cfa_offset 16
 277 0004 00AF     		add	r7, sp, #0
 278              	.LCFI16:
 279              		.cfi_def_cfa_register 7
 280 0006 0346     		mov	r3, r0
 281 0008 0A46     		mov	r2, r1
 282 000a FB80     		strh	r3, [r7, #6]	@ movhi
 283 000c 1346     		mov	r3, r2	@ movhi
 284 000e BB80     		strh	r3, [r7, #4]	@ movhi
 211:Src/mc_api.c  ****   MCI_ExecTorqueRamp(pMCI[M1], hFinalTorque, hDurationms);
 285              		.loc 1 211 3
 286 0010 054B     		ldr	r3, .L16
 287 0012 1B68     		ldr	r3, [r3]
 288 0014 BA88     		ldrh	r2, [r7, #4]
 289 0016 B7F90610 		ldrsh	r1, [r7, #6]
 290 001a 1846     		mov	r0, r3
 291 001c FFF7FEFF 		bl	MCI_ExecTorqueRamp
 212:Src/mc_api.c  **** }
 292              		.loc 1 212 1
 293 0020 00BF     		nop
 294 0022 0837     		adds	r7, r7, #8
 295              	.LCFI17:
 296              		.cfi_def_cfa_offset 8
 297 0024 BD46     		mov	sp, r7
 298              	.LCFI18:
 299              		.cfi_def_cfa_register 13
 300              		@ sp needed
 301 0026 80BD     		pop	{r7, pc}
 302              	.L17:
 303              		.align	2
 304              	.L16:
 305 0028 00000000 		.word	pMCI
 306              		.cfi_endproc
 307              	.LFE1717:
 309              		.section	.text.MC_ProgramTorqueRampMotor1_F,"ax",%progbits
 310              		.align	1
 311              		.weak	MC_ProgramTorqueRampMotor1_F
 312              		.syntax unified
 313              		.thumb
 314              		.thumb_func
ARM GAS  /tmp/ccw08S9Z.s 			page 10


 315              		.fpu fpv4-sp-d16
 317              	MC_ProgramTorqueRampMotor1_F:
 318              	.LFB1718:
 213:Src/mc_api.c  **** 
 214:Src/mc_api.c  **** /**
 215:Src/mc_api.c  ****   * @brief Programs a torque ramp for Motor 1 for later or immediate execution.
 216:Src/mc_api.c  ****   *
 217:Src/mc_api.c  ****   *  A torque ramp is a linear change from the current torque reference to the @p FinalTorque
 218:Src/mc_api.c  ****   * target torque reference in the given @p hDurationms time.
 219:Src/mc_api.c  ****   *
 220:Src/mc_api.c  ****   *  Invoking the MC_ProgramTorqueRampMotor1() function programs a new torque ramp
 221:Src/mc_api.c  ****   * with the provided parameters. The programmed ramp is executed immediately if
 222:Src/mc_api.c  ****   * Motor 1's state machine is in the #RUN states. Otherwise, the ramp is buffered
 223:Src/mc_api.c  ****   * and will be executed when the state machine reaches any of the aforementioned state.
 224:Src/mc_api.c  ****   *
 225:Src/mc_api.c  ****   *  The Application can check the status of the command with the MC_GetCommandStateMotor1()
 226:Src/mc_api.c  ****   * to know whether the last command was executed immediately or not.
 227:Src/mc_api.c  ****   *
 228:Src/mc_api.c  ****   * Only one command can be buffered at any given time. If another ramp - whether a
 229:Src/mc_api.c  ****   * torque or a speed one - or if another buffered command is programmed before the
 230:Src/mc_api.c  ****   * current one has completed, the latter replaces the former.
 231:Src/mc_api.c  ****   *
 232:Src/mc_api.c  ****   * @note A ramp cannot reverse the rotation direction if the Application is using
 233:Src/mc_api.c  ****   * sensorless motor control techniques. If the sign of the FinalTorque parameter
 234:Src/mc_api.c  ****   * differs from that of the current torque, the ramp will not complete and a Speed
 235:Src/mc_api.c  ****   * Feedback error (#MC_SPEED_FDBK) will occur when the rotation speed is about to
 236:Src/mc_api.c  ****   * reach 0 rpm.
 237:Src/mc_api.c  ****   *
 238:Src/mc_api.c  ****   * @param  FinalTorque Mechanical motor torque reference at the end of the ramp.
 239:Src/mc_api.c  ****   *         This value represents actually the Iq current expressed in Ampere.
 240:Src/mc_api.c  ****   * @param  hDurationms Duration of the ramp expressed in milliseconds. It
 241:Src/mc_api.c  ****   *         is possible to set 0 to perform an instantaneous change in the torque
 242:Src/mc_api.c  ****   *         value.
 243:Src/mc_api.c  ****   */
 244:Src/mc_api.c  **** __weak void MC_ProgramTorqueRampMotor1_F(float_t FinalTorque, uint16_t hDurationms)
 245:Src/mc_api.c  **** {
 319              		.loc 1 245 1
 320              		.cfi_startproc
 321              		@ args = 0, pretend = 0, frame = 8
 322              		@ frame_needed = 1, uses_anonymous_args = 0
 323 0000 80B5     		push	{r7, lr}
 324              	.LCFI19:
 325              		.cfi_def_cfa_offset 8
 326              		.cfi_offset 7, -8
 327              		.cfi_offset 14, -4
 328 0002 82B0     		sub	sp, sp, #8
 329              	.LCFI20:
 330              		.cfi_def_cfa_offset 16
 331 0004 00AF     		add	r7, sp, #0
 332              	.LCFI21:
 333              		.cfi_def_cfa_register 7
 334 0006 87ED010A 		vstr.32	s0, [r7, #4]
 335 000a 0346     		mov	r3, r0
 336 000c 7B80     		strh	r3, [r7, #2]	@ movhi
 246:Src/mc_api.c  ****   MCI_ExecTorqueRamp_F(pMCI[M1], FinalTorque, hDurationms);
 337              		.loc 1 246 3
 338 000e 064B     		ldr	r3, .L19
ARM GAS  /tmp/ccw08S9Z.s 			page 11


 339 0010 1B68     		ldr	r3, [r3]
 340 0012 7A88     		ldrh	r2, [r7, #2]
 341 0014 1146     		mov	r1, r2
 342 0016 97ED010A 		vldr.32	s0, [r7, #4]
 343 001a 1846     		mov	r0, r3
 344 001c FFF7FEFF 		bl	MCI_ExecTorqueRamp_F
 247:Src/mc_api.c  **** }
 345              		.loc 1 247 1
 346 0020 00BF     		nop
 347 0022 0837     		adds	r7, r7, #8
 348              	.LCFI22:
 349              		.cfi_def_cfa_offset 8
 350 0024 BD46     		mov	sp, r7
 351              	.LCFI23:
 352              		.cfi_def_cfa_register 13
 353              		@ sp needed
 354 0026 80BD     		pop	{r7, pc}
 355              	.L20:
 356              		.align	2
 357              	.L19:
 358 0028 00000000 		.word	pMCI
 359              		.cfi_endproc
 360              	.LFE1718:
 362              		.section	.text.MC_SetCurrentReferenceMotor1,"ax",%progbits
 363              		.align	1
 364              		.weak	MC_SetCurrentReferenceMotor1
 365              		.syntax unified
 366              		.thumb
 367              		.thumb_func
 368              		.fpu fpv4-sp-d16
 370              	MC_SetCurrentReferenceMotor1:
 371              	.LFB1719:
 248:Src/mc_api.c  **** 
 249:Src/mc_api.c  **** /**
 250:Src/mc_api.c  ****   * @brief Programs the current reference to Motor 1 for later or immediate execution.
 251:Src/mc_api.c  ****   *
 252:Src/mc_api.c  ****   *  The current reference to consider is made of the $I_d$ and $I_q$ current components.
 253:Src/mc_api.c  ****   *
 254:Src/mc_api.c  ****   *  Invoking the MC_SetCurrentReferenceMotor1() function programs a current reference
 255:Src/mc_api.c  ****   * with the provided parameters. The programmed reference is executed immediately if
 256:Src/mc_api.c  ****   * Motor 1's state machine is in the #RUN states. Otherwise, the command is buffered
 257:Src/mc_api.c  ****   * and will be executed when the state machine reaches any of the aforementioned state.
 258:Src/mc_api.c  ****   *
 259:Src/mc_api.c  ****   *  The Application can check the status of the command with the MC_GetCommandStateMotor1()
 260:Src/mc_api.c  ****   * to know whether the last command was executed immediately or not.
 261:Src/mc_api.c  ****   *
 262:Src/mc_api.c  ****   * Only one command can be buffered at any given time. If another buffered command is
 263:Src/mc_api.c  ****   * programmed before the current one has completed, the latter replaces the former.
 264:Src/mc_api.c  ****   *
 265:Src/mc_api.c  ****   * @param  Iqdref current reference in the Direct-Quadratic reference frame. Expressed
 266:Src/mc_api.c  ****   *         in the qd_t format.
 267:Src/mc_api.c  ****   */
 268:Src/mc_api.c  **** __weak void MC_SetCurrentReferenceMotor1(qd_t Iqdref)
 269:Src/mc_api.c  **** {
 372              		.loc 1 269 1
 373              		.cfi_startproc
 374              		@ args = 0, pretend = 0, frame = 8
ARM GAS  /tmp/ccw08S9Z.s 			page 12


 375              		@ frame_needed = 1, uses_anonymous_args = 0
 376 0000 80B5     		push	{r7, lr}
 377              	.LCFI24:
 378              		.cfi_def_cfa_offset 8
 379              		.cfi_offset 7, -8
 380              		.cfi_offset 14, -4
 381 0002 82B0     		sub	sp, sp, #8
 382              	.LCFI25:
 383              		.cfi_def_cfa_offset 16
 384 0004 00AF     		add	r7, sp, #0
 385              	.LCFI26:
 386              		.cfi_def_cfa_register 7
 387 0006 7860     		str	r0, [r7, #4]
 270:Src/mc_api.c  ****   MCI_SetCurrentReferences(pMCI[M1], Iqdref);
 388              		.loc 1 270 3
 389 0008 044B     		ldr	r3, .L22
 390 000a 1B68     		ldr	r3, [r3]
 391 000c 7968     		ldr	r1, [r7, #4]
 392 000e 1846     		mov	r0, r3
 393 0010 FFF7FEFF 		bl	MCI_SetCurrentReferences
 271:Src/mc_api.c  **** }
 394              		.loc 1 271 1
 395 0014 00BF     		nop
 396 0016 0837     		adds	r7, r7, #8
 397              	.LCFI27:
 398              		.cfi_def_cfa_offset 8
 399 0018 BD46     		mov	sp, r7
 400              	.LCFI28:
 401              		.cfi_def_cfa_register 13
 402              		@ sp needed
 403 001a 80BD     		pop	{r7, pc}
 404              	.L23:
 405              		.align	2
 406              	.L22:
 407 001c 00000000 		.word	pMCI
 408              		.cfi_endproc
 409              	.LFE1719:
 411              		.section	.text.MC_SetCurrentReferenceMotor1_F,"ax",%progbits
 412              		.align	1
 413              		.weak	MC_SetCurrentReferenceMotor1_F
 414              		.syntax unified
 415              		.thumb
 416              		.thumb_func
 417              		.fpu fpv4-sp-d16
 419              	MC_SetCurrentReferenceMotor1_F:
 420              	.LFB1720:
 272:Src/mc_api.c  **** 
 273:Src/mc_api.c  **** /**
 274:Src/mc_api.c  ****   * @brief Programs the current reference to Motor 1 for later or immediate execution.
 275:Src/mc_api.c  ****   *
 276:Src/mc_api.c  ****   *  The current reference to consider is made of the $I_d$ and $I_q$ current components.
 277:Src/mc_api.c  ****   *
 278:Src/mc_api.c  ****   *  Invoking the MC_SetCurrentReferenceMotor1_F() function programs a current reference
 279:Src/mc_api.c  ****   * with the provided parameters. The programmed reference is executed immediately if
 280:Src/mc_api.c  ****   * Motor 1's state machine is in the #RUN states. Otherwise, the command is buffered
 281:Src/mc_api.c  ****   * and will be executed when the state machine reaches any of the aforementioned state.
 282:Src/mc_api.c  ****   *
ARM GAS  /tmp/ccw08S9Z.s 			page 13


 283:Src/mc_api.c  ****   *  The Application can check the status of the command with the MC_GetCommandStateMotor1()
 284:Src/mc_api.c  ****   * to know whether the last command was executed immediately or not.
 285:Src/mc_api.c  ****   *
 286:Src/mc_api.c  ****   * Only one command can be buffered at any given time. If another buffered command is
 287:Src/mc_api.c  ****   * programmed before the current one has completed, the latter replaces the former.
 288:Src/mc_api.c  ****   *
 289:Src/mc_api.c  ****   * @param  IqdRef current reference in the Direct-Quadratic reference frame. Expressed
 290:Src/mc_api.c  ****   *         in the qd_f_t format.
 291:Src/mc_api.c  ****   */
 292:Src/mc_api.c  **** __weak void MC_SetCurrentReferenceMotor1_F(qd_f_t IqdRef)
 293:Src/mc_api.c  **** {
 421              		.loc 1 293 1
 422              		.cfi_startproc
 423              		@ args = 0, pretend = 0, frame = 8
 424              		@ frame_needed = 1, uses_anonymous_args = 0
 425 0000 80B5     		push	{r7, lr}
 426              	.LCFI29:
 427              		.cfi_def_cfa_offset 8
 428              		.cfi_offset 7, -8
 429              		.cfi_offset 14, -4
 430 0002 82B0     		sub	sp, sp, #8
 431              	.LCFI30:
 432              		.cfi_def_cfa_offset 16
 433 0004 00AF     		add	r7, sp, #0
 434              	.LCFI31:
 435              		.cfi_def_cfa_register 7
 436 0006 B0EE407A 		vmov.f32	s14, s0
 437 000a F0EE607A 		vmov.f32	s15, s1
 438 000e 87ED007A 		vstr.32	s14, [r7]
 439 0012 C7ED017A 		vstr.32	s15, [r7, #4]
 294:Src/mc_api.c  ****   MCI_SetCurrentReferences_F(pMCI[M1], IqdRef);
 440              		.loc 1 294 3
 441 0016 084B     		ldr	r3, .L25
 442 0018 1B68     		ldr	r3, [r3]
 443 001a 97ED007A 		vldr.32	s14, [r7]
 444 001e D7ED017A 		vldr.32	s15, [r7, #4]
 445 0022 B0EE470A 		vmov.f32	s0, s14
 446 0026 F0EE670A 		vmov.f32	s1, s15
 447 002a 1846     		mov	r0, r3
 448 002c FFF7FEFF 		bl	MCI_SetCurrentReferences_F
 295:Src/mc_api.c  **** }
 449              		.loc 1 295 1
 450 0030 00BF     		nop
 451 0032 0837     		adds	r7, r7, #8
 452              	.LCFI32:
 453              		.cfi_def_cfa_offset 8
 454 0034 BD46     		mov	sp, r7
 455              	.LCFI33:
 456              		.cfi_def_cfa_register 13
 457              		@ sp needed
 458 0036 80BD     		pop	{r7, pc}
 459              	.L26:
 460              		.align	2
 461              	.L25:
 462 0038 00000000 		.word	pMCI
 463              		.cfi_endproc
 464              	.LFE1720:
ARM GAS  /tmp/ccw08S9Z.s 			page 14


 466              		.section	.text.MC_GetCommandStateMotor1,"ax",%progbits
 467              		.align	1
 468              		.weak	MC_GetCommandStateMotor1
 469              		.syntax unified
 470              		.thumb
 471              		.thumb_func
 472              		.fpu fpv4-sp-d16
 474              	MC_GetCommandStateMotor1:
 475              	.LFB1721:
 296:Src/mc_api.c  **** 
 297:Src/mc_api.c  **** /**
 298:Src/mc_api.c  ****   * @brief  Returns the status of the last buffered command for Motor 1.
 299:Src/mc_api.c  ****   *
 300:Src/mc_api.c  ****   * The status can be one of the following values:
 301:Src/mc_api.c  ****   * - #MCI_BUFFER_EMPTY: no buffered command is currently programmed.
 302:Src/mc_api.c  ****   * - #MCI_COMMAND_NOT_ALREADY_EXECUTED: A command has been buffered but the conditions for its
 303:Src/mc_api.c  ****   *   execution have not occurred yet. The command is still in the buffer, pending execution.
 304:Src/mc_api.c  ****   * - #MCI_COMMAND_EXECUTED_SUCCESSFULLY: the last buffered command has been executed successfully.
 305:Src/mc_api.c  ****   *   In this case calling this function resets the command state to #MCI_BUFFER_EMPTY.
 306:Src/mc_api.c  ****   * - #MCI_COMMAND_EXECUTED_UNSUCCESSFULLY: the buffered command has been executed unsuccessfully.
 307:Src/mc_api.c  ****   *   In this case calling this function resets the command state to #MCI_BUFFER_EMPTY.
 308:Src/mc_api.c  ****   */
 309:Src/mc_api.c  **** __weak MCI_CommandState_t  MC_GetCommandStateMotor1(void)
 310:Src/mc_api.c  **** {
 476              		.loc 1 310 1
 477              		.cfi_startproc
 478              		@ args = 0, pretend = 0, frame = 0
 479              		@ frame_needed = 1, uses_anonymous_args = 0
 480 0000 80B5     		push	{r7, lr}
 481              	.LCFI34:
 482              		.cfi_def_cfa_offset 8
 483              		.cfi_offset 7, -8
 484              		.cfi_offset 14, -4
 485 0002 00AF     		add	r7, sp, #0
 486              	.LCFI35:
 487              		.cfi_def_cfa_register 7
 311:Src/mc_api.c  ****   return (MCI_IsCommandAcknowledged(pMCI[M1]));
 488              		.loc 1 311 11
 489 0004 034B     		ldr	r3, .L29
 490 0006 1B68     		ldr	r3, [r3]
 491 0008 1846     		mov	r0, r3
 492 000a FFF7FEFF 		bl	MCI_IsCommandAcknowledged
 493 000e 0346     		mov	r3, r0
 312:Src/mc_api.c  **** }
 494              		.loc 1 312 1
 495 0010 1846     		mov	r0, r3
 496 0012 80BD     		pop	{r7, pc}
 497              	.L30:
 498              		.align	2
 499              	.L29:
 500 0014 00000000 		.word	pMCI
 501              		.cfi_endproc
 502              	.LFE1721:
 504              		.section	.text.MC_StopSpeedRampMotor1,"ax",%progbits
 505              		.align	1
 506              		.weak	MC_StopSpeedRampMotor1
 507              		.syntax unified
ARM GAS  /tmp/ccw08S9Z.s 			page 15


 508              		.thumb
 509              		.thumb_func
 510              		.fpu fpv4-sp-d16
 512              	MC_StopSpeedRampMotor1:
 513              	.LFB1722:
 313:Src/mc_api.c  **** 
 314:Src/mc_api.c  **** /**
 315:Src/mc_api.c  ****  * @brief Stops the execution of the on-going speed ramp for Motor 1, if any.
 316:Src/mc_api.c  ****  *
 317:Src/mc_api.c  ****  *  If a speed ramp is currently being executed, it is immediately stopped, the rotation
 318:Src/mc_api.c  ****  * speed of Motor 1 is maintained to its current value and true is returned. If no speed
 319:Src/mc_api.c  ****  * ramp is on-going, nothing is done and false is returned.
 320:Src/mc_api.c  ****  *
 321:Src/mc_api.c  ****  * @deprecated This function is deprecated and should not be used anymore. It will be
 322:Src/mc_api.c  ****  *             removed in a future version of the MCSDK. Use MC_StopRampMotor1() instead.
 323:Src/mc_api.c  ****  */
 324:Src/mc_api.c  **** __weak bool MC_StopSpeedRampMotor1(void)
 325:Src/mc_api.c  **** {
 514              		.loc 1 325 1
 515              		.cfi_startproc
 516              		@ args = 0, pretend = 0, frame = 0
 517              		@ frame_needed = 1, uses_anonymous_args = 0
 518 0000 80B5     		push	{r7, lr}
 519              	.LCFI36:
 520              		.cfi_def_cfa_offset 8
 521              		.cfi_offset 7, -8
 522              		.cfi_offset 14, -4
 523 0002 00AF     		add	r7, sp, #0
 524              	.LCFI37:
 525              		.cfi_def_cfa_register 7
 326:Src/mc_api.c  ****   return (MCI_StopSpeedRamp(pMCI[M1]));
 526              		.loc 1 326 11
 527 0004 034B     		ldr	r3, .L33
 528 0006 1B68     		ldr	r3, [r3]
 529 0008 1846     		mov	r0, r3
 530 000a FFF7FEFF 		bl	MCI_StopSpeedRamp
 531 000e 0346     		mov	r3, r0
 327:Src/mc_api.c  **** }
 532              		.loc 1 327 1
 533 0010 1846     		mov	r0, r3
 534 0012 80BD     		pop	{r7, pc}
 535              	.L34:
 536              		.align	2
 537              	.L33:
 538 0014 00000000 		.word	pMCI
 539              		.cfi_endproc
 540              	.LFE1722:
 542              		.section	.text.MC_StopRampMotor1,"ax",%progbits
 543              		.align	1
 544              		.weak	MC_StopRampMotor1
 545              		.syntax unified
 546              		.thumb
 547              		.thumb_func
 548              		.fpu fpv4-sp-d16
 550              	MC_StopRampMotor1:
 551              	.LFB1723:
 328:Src/mc_api.c  **** 
ARM GAS  /tmp/ccw08S9Z.s 			page 16


 329:Src/mc_api.c  **** /**
 330:Src/mc_api.c  ****  * @brief Stops the execution of the on-going ramp for Motor 1, if any.
 331:Src/mc_api.c  ****  *
 332:Src/mc_api.c  ****  *  If a ramp is currently being executed, it is immediately stopped, the torque or the speed
 333:Src/mc_api.c  ****  *  of Motor 1 is maintained to its current value.
 334:Src/mc_api.c  ****  */
 335:Src/mc_api.c  **** __weak void MC_StopRampMotor1(void)
 336:Src/mc_api.c  **** {
 552              		.loc 1 336 1
 553              		.cfi_startproc
 554              		@ args = 0, pretend = 0, frame = 0
 555              		@ frame_needed = 1, uses_anonymous_args = 0
 556 0000 80B5     		push	{r7, lr}
 557              	.LCFI38:
 558              		.cfi_def_cfa_offset 8
 559              		.cfi_offset 7, -8
 560              		.cfi_offset 14, -4
 561 0002 00AF     		add	r7, sp, #0
 562              	.LCFI39:
 563              		.cfi_def_cfa_register 7
 337:Src/mc_api.c  ****   MCI_StopRamp(pMCI[M1]);
 564              		.loc 1 337 3
 565 0004 034B     		ldr	r3, .L36
 566 0006 1B68     		ldr	r3, [r3]
 567 0008 1846     		mov	r0, r3
 568 000a FFF7FEFF 		bl	MCI_StopRamp
 338:Src/mc_api.c  **** }
 569              		.loc 1 338 1
 570 000e 00BF     		nop
 571 0010 80BD     		pop	{r7, pc}
 572              	.L37:
 573 0012 00BF     		.align	2
 574              	.L36:
 575 0014 00000000 		.word	pMCI
 576              		.cfi_endproc
 577              	.LFE1723:
 579              		.section	.text.MC_HasRampCompletedMotor1,"ax",%progbits
 580              		.align	1
 581              		.weak	MC_HasRampCompletedMotor1
 582              		.syntax unified
 583              		.thumb
 584              		.thumb_func
 585              		.fpu fpv4-sp-d16
 587              	MC_HasRampCompletedMotor1:
 588              	.LFB1724:
 339:Src/mc_api.c  **** 
 340:Src/mc_api.c  **** /**
 341:Src/mc_api.c  ****  * @brief Returns true if the last ramp submited for Motor 1 has completed, false otherwise
 342:Src/mc_api.c  ****  */
 343:Src/mc_api.c  **** __weak bool MC_HasRampCompletedMotor1(void)
 344:Src/mc_api.c  **** {
 589              		.loc 1 344 1
 590              		.cfi_startproc
 591              		@ args = 0, pretend = 0, frame = 0
 592              		@ frame_needed = 1, uses_anonymous_args = 0
 593 0000 80B5     		push	{r7, lr}
 594              	.LCFI40:
ARM GAS  /tmp/ccw08S9Z.s 			page 17


 595              		.cfi_def_cfa_offset 8
 596              		.cfi_offset 7, -8
 597              		.cfi_offset 14, -4
 598 0002 00AF     		add	r7, sp, #0
 599              	.LCFI41:
 600              		.cfi_def_cfa_register 7
 345:Src/mc_api.c  ****   return (MCI_RampCompleted(pMCI[M1]));
 601              		.loc 1 345 11
 602 0004 034B     		ldr	r3, .L40
 603 0006 1B68     		ldr	r3, [r3]
 604 0008 1846     		mov	r0, r3
 605 000a FFF7FEFF 		bl	MCI_RampCompleted
 606 000e 0346     		mov	r3, r0
 346:Src/mc_api.c  **** }
 607              		.loc 1 346 1
 608 0010 1846     		mov	r0, r3
 609 0012 80BD     		pop	{r7, pc}
 610              	.L41:
 611              		.align	2
 612              	.L40:
 613 0014 00000000 		.word	pMCI
 614              		.cfi_endproc
 615              	.LFE1724:
 617              		.section	.text.MC_GetMecSpeedReferenceMotor1,"ax",%progbits
 618              		.align	1
 619              		.weak	MC_GetMecSpeedReferenceMotor1
 620              		.syntax unified
 621              		.thumb
 622              		.thumb_func
 623              		.fpu fpv4-sp-d16
 625              	MC_GetMecSpeedReferenceMotor1:
 626              	.LFB1725:
 347:Src/mc_api.c  **** 
 348:Src/mc_api.c  **** /**
 349:Src/mc_api.c  ****  *  @brief Returns the current mechanical rotor speed reference set for Motor 1, expressed in the u
 350:Src/mc_api.c  ****  */
 351:Src/mc_api.c  **** __weak int16_t MC_GetMecSpeedReferenceMotor1(void)
 352:Src/mc_api.c  **** {
 627              		.loc 1 352 1
 628              		.cfi_startproc
 629              		@ args = 0, pretend = 0, frame = 0
 630              		@ frame_needed = 1, uses_anonymous_args = 0
 631 0000 80B5     		push	{r7, lr}
 632              	.LCFI42:
 633              		.cfi_def_cfa_offset 8
 634              		.cfi_offset 7, -8
 635              		.cfi_offset 14, -4
 636 0002 00AF     		add	r7, sp, #0
 637              	.LCFI43:
 638              		.cfi_def_cfa_register 7
 353:Src/mc_api.c  ****   return (MCI_GetMecSpeedRefUnit(pMCI[M1]));
 639              		.loc 1 353 11
 640 0004 034B     		ldr	r3, .L44
 641 0006 1B68     		ldr	r3, [r3]
 642 0008 1846     		mov	r0, r3
 643 000a FFF7FEFF 		bl	MCI_GetMecSpeedRefUnit
 644 000e 0346     		mov	r3, r0
ARM GAS  /tmp/ccw08S9Z.s 			page 18


 354:Src/mc_api.c  **** }
 645              		.loc 1 354 1
 646 0010 1846     		mov	r0, r3
 647 0012 80BD     		pop	{r7, pc}
 648              	.L45:
 649              		.align	2
 650              	.L44:
 651 0014 00000000 		.word	pMCI
 652              		.cfi_endproc
 653              	.LFE1725:
 655              		.section	.text.MC_GetMecSpeedReferenceMotor1_F,"ax",%progbits
 656              		.align	1
 657              		.weak	MC_GetMecSpeedReferenceMotor1_F
 658              		.syntax unified
 659              		.thumb
 660              		.thumb_func
 661              		.fpu fpv4-sp-d16
 663              	MC_GetMecSpeedReferenceMotor1_F:
 664              	.LFB1726:
 355:Src/mc_api.c  **** 
 356:Src/mc_api.c  **** /**
 357:Src/mc_api.c  ****  *  @brief Returns the current mechanical rotor speed reference set for Motor 1, expressed in rpm.
 358:Src/mc_api.c  ****  */
 359:Src/mc_api.c  **** __weak float_t MC_GetMecSpeedReferenceMotor1_F(void)
 360:Src/mc_api.c  **** {
 665              		.loc 1 360 1
 666              		.cfi_startproc
 667              		@ args = 0, pretend = 0, frame = 0
 668              		@ frame_needed = 1, uses_anonymous_args = 0
 669 0000 80B5     		push	{r7, lr}
 670              	.LCFI44:
 671              		.cfi_def_cfa_offset 8
 672              		.cfi_offset 7, -8
 673              		.cfi_offset 14, -4
 674 0002 00AF     		add	r7, sp, #0
 675              	.LCFI45:
 676              		.cfi_def_cfa_register 7
 361:Src/mc_api.c  ****   return (MCI_GetMecSpeedRef_F(pMCI[M1]));
 677              		.loc 1 361 11
 678 0004 044B     		ldr	r3, .L48
 679 0006 1B68     		ldr	r3, [r3]
 680 0008 1846     		mov	r0, r3
 681 000a FFF7FEFF 		bl	MCI_GetMecSpeedRef_F
 682 000e F0EE407A 		vmov.f32	s15, s0
 362:Src/mc_api.c  **** }
 683              		.loc 1 362 1
 684 0012 B0EE670A 		vmov.f32	s0, s15
 685 0016 80BD     		pop	{r7, pc}
 686              	.L49:
 687              		.align	2
 688              	.L48:
 689 0018 00000000 		.word	pMCI
 690              		.cfi_endproc
 691              	.LFE1726:
 693              		.section	.text.MC_GetMecSpeedAverageMotor1,"ax",%progbits
 694              		.align	1
 695              		.weak	MC_GetMecSpeedAverageMotor1
ARM GAS  /tmp/ccw08S9Z.s 			page 19


 696              		.syntax unified
 697              		.thumb
 698              		.thumb_func
 699              		.fpu fpv4-sp-d16
 701              	MC_GetMecSpeedAverageMotor1:
 702              	.LFB1727:
 363:Src/mc_api.c  **** 
 364:Src/mc_api.c  **** /**
 365:Src/mc_api.c  ****  * @brief Returns the last computed average mechanical rotor speed for Motor 1, expressed in the un
 366:Src/mc_api.c  ****  */
 367:Src/mc_api.c  **** __weak int16_t MC_GetMecSpeedAverageMotor1(void)
 368:Src/mc_api.c  **** {
 703              		.loc 1 368 1
 704              		.cfi_startproc
 705              		@ args = 0, pretend = 0, frame = 0
 706              		@ frame_needed = 1, uses_anonymous_args = 0
 707 0000 80B5     		push	{r7, lr}
 708              	.LCFI46:
 709              		.cfi_def_cfa_offset 8
 710              		.cfi_offset 7, -8
 711              		.cfi_offset 14, -4
 712 0002 00AF     		add	r7, sp, #0
 713              	.LCFI47:
 714              		.cfi_def_cfa_register 7
 369:Src/mc_api.c  ****   return (MCI_GetAvrgMecSpeedUnit(pMCI[M1]));
 715              		.loc 1 369 11
 716 0004 034B     		ldr	r3, .L52
 717 0006 1B68     		ldr	r3, [r3]
 718 0008 1846     		mov	r0, r3
 719 000a FFF7FEFF 		bl	MCI_GetAvrgMecSpeedUnit
 720 000e 0346     		mov	r3, r0
 370:Src/mc_api.c  **** }
 721              		.loc 1 370 1
 722 0010 1846     		mov	r0, r3
 723 0012 80BD     		pop	{r7, pc}
 724              	.L53:
 725              		.align	2
 726              	.L52:
 727 0014 00000000 		.word	pMCI
 728              		.cfi_endproc
 729              	.LFE1727:
 731              		.section	.text.MC_GetAverageMecSpeedMotor1_F,"ax",%progbits
 732              		.align	1
 733              		.weak	MC_GetAverageMecSpeedMotor1_F
 734              		.syntax unified
 735              		.thumb
 736              		.thumb_func
 737              		.fpu fpv4-sp-d16
 739              	MC_GetAverageMecSpeedMotor1_F:
 740              	.LFB1728:
 371:Src/mc_api.c  **** 
 372:Src/mc_api.c  **** /**
 373:Src/mc_api.c  ****  * @brief Returns the last computed average mechanical rotor speed for Motor 1, expressed in rpm.
 374:Src/mc_api.c  ****  */
 375:Src/mc_api.c  **** __weak float_t MC_GetAverageMecSpeedMotor1_F(void)
 376:Src/mc_api.c  **** {
 741              		.loc 1 376 1
ARM GAS  /tmp/ccw08S9Z.s 			page 20


 742              		.cfi_startproc
 743              		@ args = 0, pretend = 0, frame = 0
 744              		@ frame_needed = 1, uses_anonymous_args = 0
 745 0000 80B5     		push	{r7, lr}
 746              	.LCFI48:
 747              		.cfi_def_cfa_offset 8
 748              		.cfi_offset 7, -8
 749              		.cfi_offset 14, -4
 750 0002 00AF     		add	r7, sp, #0
 751              	.LCFI49:
 752              		.cfi_def_cfa_register 7
 377:Src/mc_api.c  ****   return (MCI_GetAvrgMecSpeed_F(pMCI[M1]));
 753              		.loc 1 377 11
 754 0004 044B     		ldr	r3, .L56
 755 0006 1B68     		ldr	r3, [r3]
 756 0008 1846     		mov	r0, r3
 757 000a FFF7FEFF 		bl	MCI_GetAvrgMecSpeed_F
 758 000e F0EE407A 		vmov.f32	s15, s0
 378:Src/mc_api.c  **** }
 759              		.loc 1 378 1
 760 0012 B0EE670A 		vmov.f32	s0, s15
 761 0016 80BD     		pop	{r7, pc}
 762              	.L57:
 763              		.align	2
 764              	.L56:
 765 0018 00000000 		.word	pMCI
 766              		.cfi_endproc
 767              	.LFE1728:
 769              		.section	.text.MC_GetLastRampFinalSpeedMotor1,"ax",%progbits
 770              		.align	1
 771              		.weak	MC_GetLastRampFinalSpeedMotor1
 772              		.syntax unified
 773              		.thumb
 774              		.thumb_func
 775              		.fpu fpv4-sp-d16
 777              	MC_GetLastRampFinalSpeedMotor1:
 778              	.LFB1729:
 379:Src/mc_api.c  **** 
 380:Src/mc_api.c  **** /**
 381:Src/mc_api.c  ****  * @brief Returns the final speed of the last ramp programmed for Motor 1 if this ramp was a speed 
 382:Src/mc_api.c  ****  */
 383:Src/mc_api.c  **** __weak int16_t MC_GetLastRampFinalSpeedMotor1(void)
 384:Src/mc_api.c  **** {
 779              		.loc 1 384 1
 780              		.cfi_startproc
 781              		@ args = 0, pretend = 0, frame = 0
 782              		@ frame_needed = 1, uses_anonymous_args = 0
 783 0000 80B5     		push	{r7, lr}
 784              	.LCFI50:
 785              		.cfi_def_cfa_offset 8
 786              		.cfi_offset 7, -8
 787              		.cfi_offset 14, -4
 788 0002 00AF     		add	r7, sp, #0
 789              	.LCFI51:
 790              		.cfi_def_cfa_register 7
 385:Src/mc_api.c  ****   return (MCI_GetLastRampFinalSpeed(pMCI[M1]));
 791              		.loc 1 385 11
ARM GAS  /tmp/ccw08S9Z.s 			page 21


 792 0004 034B     		ldr	r3, .L60
 793 0006 1B68     		ldr	r3, [r3]
 794 0008 1846     		mov	r0, r3
 795 000a FFF7FEFF 		bl	MCI_GetLastRampFinalSpeed
 796 000e 0346     		mov	r3, r0
 386:Src/mc_api.c  **** }
 797              		.loc 1 386 1
 798 0010 1846     		mov	r0, r3
 799 0012 80BD     		pop	{r7, pc}
 800              	.L61:
 801              		.align	2
 802              	.L60:
 803 0014 00000000 		.word	pMCI
 804              		.cfi_endproc
 805              	.LFE1729:
 807              		.section	.text.MC_GetLastRampFinalSpeedM1_F,"ax",%progbits
 808              		.align	1
 809              		.weak	MC_GetLastRampFinalSpeedM1_F
 810              		.syntax unified
 811              		.thumb
 812              		.thumb_func
 813              		.fpu fpv4-sp-d16
 815              	MC_GetLastRampFinalSpeedM1_F:
 816              	.LFB1730:
 387:Src/mc_api.c  **** 
 388:Src/mc_api.c  **** /**
 389:Src/mc_api.c  ****  * @brief Returns the final speed of the last ramp programmed for Motor 1 if this ramp was a speed 
 390:Src/mc_api.c  ****  */
 391:Src/mc_api.c  **** __weak float_t MC_GetLastRampFinalSpeedM1_F(void)
 392:Src/mc_api.c  **** {
 817              		.loc 1 392 1
 818              		.cfi_startproc
 819              		@ args = 0, pretend = 0, frame = 0
 820              		@ frame_needed = 1, uses_anonymous_args = 0
 821 0000 80B5     		push	{r7, lr}
 822              	.LCFI52:
 823              		.cfi_def_cfa_offset 8
 824              		.cfi_offset 7, -8
 825              		.cfi_offset 14, -4
 826 0002 00AF     		add	r7, sp, #0
 827              	.LCFI53:
 828              		.cfi_def_cfa_register 7
 393:Src/mc_api.c  ****   return (MCI_GetLastRampFinalSpeed_F(pMCI[M1]));
 829              		.loc 1 393 11
 830 0004 044B     		ldr	r3, .L64
 831 0006 1B68     		ldr	r3, [r3]
 832 0008 1846     		mov	r0, r3
 833 000a FFF7FEFF 		bl	MCI_GetLastRampFinalSpeed_F
 834 000e F0EE407A 		vmov.f32	s15, s0
 394:Src/mc_api.c  **** }
 835              		.loc 1 394 1
 836 0012 B0EE670A 		vmov.f32	s0, s15
 837 0016 80BD     		pop	{r7, pc}
 838              	.L65:
 839              		.align	2
 840              	.L64:
 841 0018 00000000 		.word	pMCI
ARM GAS  /tmp/ccw08S9Z.s 			page 22


 842              		.cfi_endproc
 843              	.LFE1730:
 845              		.section	.text.MC_GetFinalTorqueReferenceMotor1_F,"ax",%progbits
 846              		.align	1
 847              		.weak	MC_GetFinalTorqueReferenceMotor1_F
 848              		.syntax unified
 849              		.thumb
 850              		.thumb_func
 851              		.fpu fpv4-sp-d16
 853              	MC_GetFinalTorqueReferenceMotor1_F:
 854              	.LFB1731:
 395:Src/mc_api.c  **** /**
 396:Src/mc_api.c  ****  * @brief Returns the final torque reference for Motor 1, expressed in Ampere.
 397:Src/mc_api.c  ****  */
 398:Src/mc_api.c  **** __weak float_t MC_GetFinalTorqueReferenceMotor1_F(void)
 399:Src/mc_api.c  **** {
 855              		.loc 1 399 1
 856              		.cfi_startproc
 857              		@ args = 0, pretend = 0, frame = 0
 858              		@ frame_needed = 1, uses_anonymous_args = 0
 859 0000 80B5     		push	{r7, lr}
 860              	.LCFI54:
 861              		.cfi_def_cfa_offset 8
 862              		.cfi_offset 7, -8
 863              		.cfi_offset 14, -4
 864 0002 00AF     		add	r7, sp, #0
 865              	.LCFI55:
 866              		.cfi_def_cfa_register 7
 400:Src/mc_api.c  ****   return (MCI_GetLastRampFinalTorque_F(pMCI[M1]));
 867              		.loc 1 400 11
 868 0004 044B     		ldr	r3, .L68
 869 0006 1B68     		ldr	r3, [r3]
 870 0008 1846     		mov	r0, r3
 871 000a FFF7FEFF 		bl	MCI_GetLastRampFinalTorque_F
 872 000e F0EE407A 		vmov.f32	s15, s0
 401:Src/mc_api.c  **** }
 873              		.loc 1 401 1
 874 0012 B0EE670A 		vmov.f32	s0, s15
 875 0016 80BD     		pop	{r7, pc}
 876              	.L69:
 877              		.align	2
 878              	.L68:
 879 0018 00000000 		.word	pMCI
 880              		.cfi_endproc
 881              	.LFE1731:
 883              		.section	.text.MC_GetFinalTorqueReferenceMotor1,"ax",%progbits
 884              		.align	1
 885              		.weak	MC_GetFinalTorqueReferenceMotor1
 886              		.syntax unified
 887              		.thumb
 888              		.thumb_func
 889              		.fpu fpv4-sp-d16
 891              	MC_GetFinalTorqueReferenceMotor1:
 892              	.LFB1732:
 402:Src/mc_api.c  **** 
 403:Src/mc_api.c  **** /**
 404:Src/mc_api.c  ****  * @brief Returns the final torque reference for Motor 1, expressed in digit.
ARM GAS  /tmp/ccw08S9Z.s 			page 23


 405:Src/mc_api.c  ****  */
 406:Src/mc_api.c  **** __weak int16_t MC_GetFinalTorqueReferenceMotor1(void)
 407:Src/mc_api.c  **** {
 893              		.loc 1 407 1
 894              		.cfi_startproc
 895              		@ args = 0, pretend = 0, frame = 0
 896              		@ frame_needed = 1, uses_anonymous_args = 0
 897 0000 80B5     		push	{r7, lr}
 898              	.LCFI56:
 899              		.cfi_def_cfa_offset 8
 900              		.cfi_offset 7, -8
 901              		.cfi_offset 14, -4
 902 0002 00AF     		add	r7, sp, #0
 903              	.LCFI57:
 904              		.cfi_def_cfa_register 7
 408:Src/mc_api.c  ****   return (MCI_GetLastRampFinalTorque(pMCI[M1]));
 905              		.loc 1 408 11
 906 0004 034B     		ldr	r3, .L72
 907 0006 1B68     		ldr	r3, [r3]
 908 0008 1846     		mov	r0, r3
 909 000a FFF7FEFF 		bl	MCI_GetLastRampFinalTorque
 910 000e 0346     		mov	r3, r0
 409:Src/mc_api.c  **** }
 911              		.loc 1 409 1
 912 0010 1846     		mov	r0, r3
 913 0012 80BD     		pop	{r7, pc}
 914              	.L73:
 915              		.align	2
 916              	.L72:
 917 0014 00000000 		.word	pMCI
 918              		.cfi_endproc
 919              	.LFE1732:
 921              		.section	.text.MC_GetControlModeMotor1,"ax",%progbits
 922              		.align	1
 923              		.weak	MC_GetControlModeMotor1
 924              		.syntax unified
 925              		.thumb
 926              		.thumb_func
 927              		.fpu fpv4-sp-d16
 929              	MC_GetControlModeMotor1:
 930              	.LFB1733:
 410:Src/mc_api.c  **** /**
 411:Src/mc_api.c  ****  * @brief Returns the Control Mode used for Motor 1 (either Speed or Torque)
 412:Src/mc_api.c  ****  */
 413:Src/mc_api.c  **** __weak MC_ControlMode_t MC_GetControlModeMotor1(void)
 414:Src/mc_api.c  **** {
 931              		.loc 1 414 1
 932              		.cfi_startproc
 933              		@ args = 0, pretend = 0, frame = 0
 934              		@ frame_needed = 1, uses_anonymous_args = 0
 935 0000 80B5     		push	{r7, lr}
 936              	.LCFI58:
 937              		.cfi_def_cfa_offset 8
 938              		.cfi_offset 7, -8
 939              		.cfi_offset 14, -4
 940 0002 00AF     		add	r7, sp, #0
 941              	.LCFI59:
ARM GAS  /tmp/ccw08S9Z.s 			page 24


 942              		.cfi_def_cfa_register 7
 415:Src/mc_api.c  ****   return (MCI_GetControlMode(pMCI[M1]));
 943              		.loc 1 415 11
 944 0004 034B     		ldr	r3, .L76
 945 0006 1B68     		ldr	r3, [r3]
 946 0008 1846     		mov	r0, r3
 947 000a FFF7FEFF 		bl	MCI_GetControlMode
 948 000e 0346     		mov	r3, r0
 416:Src/mc_api.c  **** }
 949              		.loc 1 416 1
 950 0010 1846     		mov	r0, r3
 951 0012 80BD     		pop	{r7, pc}
 952              	.L77:
 953              		.align	2
 954              	.L76:
 955 0014 00000000 		.word	pMCI
 956              		.cfi_endproc
 957              	.LFE1733:
 959              		.section	.text.MC_GetImposedDirectionMotor1,"ax",%progbits
 960              		.align	1
 961              		.weak	MC_GetImposedDirectionMotor1
 962              		.syntax unified
 963              		.thumb
 964              		.thumb_func
 965              		.fpu fpv4-sp-d16
 967              	MC_GetImposedDirectionMotor1:
 968              	.LFB1734:
 417:Src/mc_api.c  **** 
 418:Src/mc_api.c  **** /**
 419:Src/mc_api.c  ****  * @brief Returns the rotation direction imposed by the last command on Motor 1
 420:Src/mc_api.c  ****  *
 421:Src/mc_api.c  ****  * The last command is either MC_ProgramSpeedRampMotor1(), MC_ProgramTorqueRampMotor1() or
 422:Src/mc_api.c  ****  * MC_SetCurrentReferenceMotor1().
 423:Src/mc_api.c  ****  *
 424:Src/mc_api.c  ****  * The function returns -1 if the sign of the final speed, the final torque or the Iq current
 425:Src/mc_api.c  ****  * reference component of the last command is negative. Otherwise, 1 is returned.
 426:Src/mc_api.c  ****  *
 427:Src/mc_api.c  ****  * @note if no such command has ever been submitted, 1 is returned as well.
 428:Src/mc_api.c  ****  */
 429:Src/mc_api.c  **** __weak int16_t MC_GetImposedDirectionMotor1(void)
 430:Src/mc_api.c  **** {
 969              		.loc 1 430 1
 970              		.cfi_startproc
 971              		@ args = 0, pretend = 0, frame = 0
 972              		@ frame_needed = 1, uses_anonymous_args = 0
 973 0000 80B5     		push	{r7, lr}
 974              	.LCFI60:
 975              		.cfi_def_cfa_offset 8
 976              		.cfi_offset 7, -8
 977              		.cfi_offset 14, -4
 978 0002 00AF     		add	r7, sp, #0
 979              	.LCFI61:
 980              		.cfi_def_cfa_register 7
 431:Src/mc_api.c  ****   return (MCI_GetImposedMotorDirection(pMCI[M1]));
 981              		.loc 1 431 11
 982 0004 034B     		ldr	r3, .L80
 983 0006 1B68     		ldr	r3, [r3]
ARM GAS  /tmp/ccw08S9Z.s 			page 25


 984 0008 1846     		mov	r0, r3
 985 000a FFF7FEFF 		bl	MCI_GetImposedMotorDirection
 986 000e 0346     		mov	r3, r0
 432:Src/mc_api.c  **** }
 987              		.loc 1 432 1
 988 0010 1846     		mov	r0, r3
 989 0012 80BD     		pop	{r7, pc}
 990              	.L81:
 991              		.align	2
 992              	.L80:
 993 0014 00000000 		.word	pMCI
 994              		.cfi_endproc
 995              	.LFE1734:
 997              		.section	.text.MC_GetSpeedSensorReliabilityMotor1,"ax",%progbits
 998              		.align	1
 999              		.weak	MC_GetSpeedSensorReliabilityMotor1
 1000              		.syntax unified
 1001              		.thumb
 1002              		.thumb_func
 1003              		.fpu fpv4-sp-d16
 1005              	MC_GetSpeedSensorReliabilityMotor1:
 1006              	.LFB1735:
 433:Src/mc_api.c  **** 
 434:Src/mc_api.c  **** /**
 435:Src/mc_api.c  ****  * @brief Returns true if the speed sensor used for Motor 1 is reliable, false otherwise
 436:Src/mc_api.c  ****  */
 437:Src/mc_api.c  **** __weak bool MC_GetSpeedSensorReliabilityMotor1(void)
 438:Src/mc_api.c  **** {
 1007              		.loc 1 438 1
 1008              		.cfi_startproc
 1009              		@ args = 0, pretend = 0, frame = 0
 1010              		@ frame_needed = 1, uses_anonymous_args = 0
 1011 0000 80B5     		push	{r7, lr}
 1012              	.LCFI62:
 1013              		.cfi_def_cfa_offset 8
 1014              		.cfi_offset 7, -8
 1015              		.cfi_offset 14, -4
 1016 0002 00AF     		add	r7, sp, #0
 1017              	.LCFI63:
 1018              		.cfi_def_cfa_register 7
 439:Src/mc_api.c  ****   return (MCI_GetSpdSensorReliability(pMCI[M1]));
 1019              		.loc 1 439 11
 1020 0004 034B     		ldr	r3, .L84
 1021 0006 1B68     		ldr	r3, [r3]
 1022 0008 1846     		mov	r0, r3
 1023 000a FFF7FEFF 		bl	MCI_GetSpdSensorReliability
 1024 000e 0346     		mov	r3, r0
 440:Src/mc_api.c  **** }
 1025              		.loc 1 440 1
 1026 0010 1846     		mov	r0, r3
 1027 0012 80BD     		pop	{r7, pc}
 1028              	.L85:
 1029              		.align	2
 1030              	.L84:
 1031 0014 00000000 		.word	pMCI
 1032              		.cfi_endproc
 1033              	.LFE1735:
ARM GAS  /tmp/ccw08S9Z.s 			page 26


 1035              		.section	.text.MC_GetPhaseCurrentAmplitudeMotor1,"ax",%progbits
 1036              		.align	1
 1037              		.weak	MC_GetPhaseCurrentAmplitudeMotor1
 1038              		.syntax unified
 1039              		.thumb
 1040              		.thumb_func
 1041              		.fpu fpv4-sp-d16
 1043              	MC_GetPhaseCurrentAmplitudeMotor1:
 1044              	.LFB1736:
 441:Src/mc_api.c  **** 
 442:Src/mc_api.c  **** /**
 443:Src/mc_api.c  ****  * @brief returns the amplitude of the phase current injected in Motor 1
 444:Src/mc_api.c  ****  *
 445:Src/mc_api.c  ****  * The returned amplitude (0-to-peak) is expressed in s16A unit. To convert it to amperes, use the 
 446:Src/mc_api.c  ****  *
 447:Src/mc_api.c  ****  * @f[
 448:Src/mc_api.c  ****  * I_{Amps} = \frac{ I_{s16A} \times V_{dd}}{ 65536 \times R_{shunt} \times A_{op} }
 449:Src/mc_api.c  ****  * @f]
 450:Src/mc_api.c  ****  *
 451:Src/mc_api.c  ****  */
 452:Src/mc_api.c  **** __weak int16_t MC_GetPhaseCurrentAmplitudeMotor1(void)
 453:Src/mc_api.c  **** {
 1045              		.loc 1 453 1
 1046              		.cfi_startproc
 1047              		@ args = 0, pretend = 0, frame = 0
 1048              		@ frame_needed = 1, uses_anonymous_args = 0
 1049 0000 80B5     		push	{r7, lr}
 1050              	.LCFI64:
 1051              		.cfi_def_cfa_offset 8
 1052              		.cfi_offset 7, -8
 1053              		.cfi_offset 14, -4
 1054 0002 00AF     		add	r7, sp, #0
 1055              	.LCFI65:
 1056              		.cfi_def_cfa_register 7
 454:Src/mc_api.c  ****   return (MCI_GetPhaseCurrentAmplitude(pMCI[M1]));
 1057              		.loc 1 454 11
 1058 0004 034B     		ldr	r3, .L88
 1059 0006 1B68     		ldr	r3, [r3]
 1060 0008 1846     		mov	r0, r3
 1061 000a FFF7FEFF 		bl	MCI_GetPhaseCurrentAmplitude
 1062 000e 0346     		mov	r3, r0
 455:Src/mc_api.c  **** }
 1063              		.loc 1 455 1
 1064 0010 1846     		mov	r0, r3
 1065 0012 80BD     		pop	{r7, pc}
 1066              	.L89:
 1067              		.align	2
 1068              	.L88:
 1069 0014 00000000 		.word	pMCI
 1070              		.cfi_endproc
 1071              	.LFE1736:
 1073              		.section	.text.MC_GetPhaseVoltageAmplitudeMotor1,"ax",%progbits
 1074              		.align	1
 1075              		.weak	MC_GetPhaseVoltageAmplitudeMotor1
 1076              		.syntax unified
 1077              		.thumb
 1078              		.thumb_func
ARM GAS  /tmp/ccw08S9Z.s 			page 27


 1079              		.fpu fpv4-sp-d16
 1081              	MC_GetPhaseVoltageAmplitudeMotor1:
 1082              	.LFB1737:
 456:Src/mc_api.c  **** 
 457:Src/mc_api.c  **** /**
 458:Src/mc_api.c  ****  * @brief returns the amplitude of the phase voltage applied to Motor 1
 459:Src/mc_api.c  ****  *
 460:Src/mc_api.c  ****  * The returned amplitude (0-to-peak) is expressed in s16V unit. To convert it to volts, use the fo
 461:Src/mc_api.c  ****  *
 462:Src/mc_api.c  ****  * @f[
 463:Src/mc_api.c  ****  * U_{Volts} = \frac{ U_{s16V} \times V_{bus}}{ \sqrt{3} \times 32768  }
 464:Src/mc_api.c  ****  * @f]
 465:Src/mc_api.c  ****  *
 466:Src/mc_api.c  ****  */
 467:Src/mc_api.c  **** __weak int16_t MC_GetPhaseVoltageAmplitudeMotor1(void)
 468:Src/mc_api.c  **** {
 1083              		.loc 1 468 1
 1084              		.cfi_startproc
 1085              		@ args = 0, pretend = 0, frame = 0
 1086              		@ frame_needed = 1, uses_anonymous_args = 0
 1087 0000 80B5     		push	{r7, lr}
 1088              	.LCFI66:
 1089              		.cfi_def_cfa_offset 8
 1090              		.cfi_offset 7, -8
 1091              		.cfi_offset 14, -4
 1092 0002 00AF     		add	r7, sp, #0
 1093              	.LCFI67:
 1094              		.cfi_def_cfa_register 7
 469:Src/mc_api.c  ****   return (MCI_GetPhaseVoltageAmplitude(pMCI[M1]));
 1095              		.loc 1 469 11
 1096 0004 034B     		ldr	r3, .L92
 1097 0006 1B68     		ldr	r3, [r3]
 1098 0008 1846     		mov	r0, r3
 1099 000a FFF7FEFF 		bl	MCI_GetPhaseVoltageAmplitude
 1100 000e 0346     		mov	r3, r0
 470:Src/mc_api.c  **** }
 1101              		.loc 1 470 1
 1102 0010 1846     		mov	r0, r3
 1103 0012 80BD     		pop	{r7, pc}
 1104              	.L93:
 1105              		.align	2
 1106              	.L92:
 1107 0014 00000000 		.word	pMCI
 1108              		.cfi_endproc
 1109              	.LFE1737:
 1111              		.section	.text.MC_GetIabMotor1,"ax",%progbits
 1112              		.align	1
 1113              		.weak	MC_GetIabMotor1
 1114              		.syntax unified
 1115              		.thumb
 1116              		.thumb_func
 1117              		.fpu fpv4-sp-d16
 1119              	MC_GetIabMotor1:
 1120              	.LFB1738:
 471:Src/mc_api.c  **** 
 472:Src/mc_api.c  **** /**
 473:Src/mc_api.c  ****  * @brief returns Ia and Ib current values for Motor 1 in ab_t format
ARM GAS  /tmp/ccw08S9Z.s 			page 28


 474:Src/mc_api.c  ****  */
 475:Src/mc_api.c  **** __weak ab_t MC_GetIabMotor1(void)
 476:Src/mc_api.c  **** {
 1121              		.loc 1 476 1
 1122              		.cfi_startproc
 1123              		@ args = 0, pretend = 0, frame = 8
 1124              		@ frame_needed = 1, uses_anonymous_args = 0
 1125 0000 80B5     		push	{r7, lr}
 1126              	.LCFI68:
 1127              		.cfi_def_cfa_offset 8
 1128              		.cfi_offset 7, -8
 1129              		.cfi_offset 14, -4
 1130 0002 82B0     		sub	sp, sp, #8
 1131              	.LCFI69:
 1132              		.cfi_def_cfa_offset 16
 1133 0004 00AF     		add	r7, sp, #0
 1134              	.LCFI70:
 1135              		.cfi_def_cfa_register 7
 477:Src/mc_api.c  ****   return (MCI_GetIab(pMCI[M1]));
 1136              		.loc 1 477 11
 1137 0006 094B     		ldr	r3, .L96
 1138 0008 1B68     		ldr	r3, [r3]
 1139 000a 1846     		mov	r0, r3
 1140 000c FFF7FEFF 		bl	MCI_GetIab
 1141 0010 0346     		mov	r3, r0
 1142 0012 7B60     		str	r3, [r7, #4]
 1143 0014 0023     		movs	r3, #0
 1144 0016 BA88     		ldrh	r2, [r7, #4]
 1145 0018 62F30F03 		bfi	r3, r2, #0, #16
 1146 001c FA88     		ldrh	r2, [r7, #6]
 1147 001e 62F31F43 		bfi	r3, r2, #16, #16
 478:Src/mc_api.c  **** }
 1148              		.loc 1 478 1
 1149 0022 1846     		mov	r0, r3
 1150 0024 0837     		adds	r7, r7, #8
 1151              	.LCFI71:
 1152              		.cfi_def_cfa_offset 8
 1153 0026 BD46     		mov	sp, r7
 1154              	.LCFI72:
 1155              		.cfi_def_cfa_register 13
 1156              		@ sp needed
 1157 0028 80BD     		pop	{r7, pc}
 1158              	.L97:
 1159 002a 00BF     		.align	2
 1160              	.L96:
 1161 002c 00000000 		.word	pMCI
 1162              		.cfi_endproc
 1163              	.LFE1738:
 1165              		.section	.text.MC_GetIabMotor1_F,"ax",%progbits
 1166              		.align	1
 1167              		.weak	MC_GetIabMotor1_F
 1168              		.syntax unified
 1169              		.thumb
 1170              		.thumb_func
 1171              		.fpu fpv4-sp-d16
 1173              	MC_GetIabMotor1_F:
 1174              	.LFB1739:
ARM GAS  /tmp/ccw08S9Z.s 			page 29


 479:Src/mc_api.c  **** 
 480:Src/mc_api.c  **** /**
 481:Src/mc_api.c  ****  * @brief returns Ia and Ib current values for Motor 1 in ab_f_t format
 482:Src/mc_api.c  ****  */
 483:Src/mc_api.c  **** __weak ab_f_t MC_GetIabMotor1_F(void)
 484:Src/mc_api.c  **** {
 1175              		.loc 1 484 1
 1176              		.cfi_startproc
 1177              		@ args = 0, pretend = 0, frame = 16
 1178              		@ frame_needed = 1, uses_anonymous_args = 0
 1179 0000 80B5     		push	{r7, lr}
 1180              	.LCFI73:
 1181              		.cfi_def_cfa_offset 8
 1182              		.cfi_offset 7, -8
 1183              		.cfi_offset 14, -4
 1184 0002 84B0     		sub	sp, sp, #16
 1185              	.LCFI74:
 1186              		.cfi_def_cfa_offset 24
 1187 0004 00AF     		add	r7, sp, #0
 1188              	.LCFI75:
 1189              		.cfi_def_cfa_register 7
 485:Src/mc_api.c  ****   return (MCI_GetIab_F(pMCI[M1]));
 1190              		.loc 1 485 11
 1191 0006 0D4B     		ldr	r3, .L100
 1192 0008 1B68     		ldr	r3, [r3]
 1193 000a 1846     		mov	r0, r3
 1194 000c FFF7FEFF 		bl	MCI_GetIab_F
 1195 0010 B0EE407A 		vmov.f32	s14, s0
 1196 0014 F0EE607A 		vmov.f32	s15, s1
 1197 0018 87ED027A 		vstr.32	s14, [r7, #8]
 1198 001c C7ED037A 		vstr.32	s15, [r7, #12]
 1199 0020 BA68     		ldr	r2, [r7, #8]	@ float
 1200 0022 FB68     		ldr	r3, [r7, #12]	@ float
 1201 0024 07EE102A 		vmov	s14, r2
 1202 0028 07EE903A 		vmov	s15, r3
 486:Src/mc_api.c  **** }
 1203              		.loc 1 486 1
 1204 002c B0EE470A 		vmov.f32	s0, s14
 1205 0030 F0EE670A 		vmov.f32	s1, s15
 1206 0034 1037     		adds	r7, r7, #16
 1207              	.LCFI76:
 1208              		.cfi_def_cfa_offset 8
 1209 0036 BD46     		mov	sp, r7
 1210              	.LCFI77:
 1211              		.cfi_def_cfa_register 13
 1212              		@ sp needed
 1213 0038 80BD     		pop	{r7, pc}
 1214              	.L101:
 1215 003a 00BF     		.align	2
 1216              	.L100:
 1217 003c 00000000 		.word	pMCI
 1218              		.cfi_endproc
 1219              	.LFE1739:
 1221              		.section	.text.MC_GetIalphabetaMotor1,"ax",%progbits
 1222              		.align	1
 1223              		.weak	MC_GetIalphabetaMotor1
 1224              		.syntax unified
ARM GAS  /tmp/ccw08S9Z.s 			page 30


 1225              		.thumb
 1226              		.thumb_func
 1227              		.fpu fpv4-sp-d16
 1229              	MC_GetIalphabetaMotor1:
 1230              	.LFB1740:
 487:Src/mc_api.c  **** 
 488:Src/mc_api.c  **** /**
 489:Src/mc_api.c  ****  * @brief returns Ialpha and Ibeta current values for Motor 1 in alphabeta_t format
 490:Src/mc_api.c  ****  */
 491:Src/mc_api.c  **** __weak alphabeta_t MC_GetIalphabetaMotor1(void)
 492:Src/mc_api.c  **** {
 1231              		.loc 1 492 1
 1232              		.cfi_startproc
 1233              		@ args = 0, pretend = 0, frame = 8
 1234              		@ frame_needed = 1, uses_anonymous_args = 0
 1235 0000 80B5     		push	{r7, lr}
 1236              	.LCFI78:
 1237              		.cfi_def_cfa_offset 8
 1238              		.cfi_offset 7, -8
 1239              		.cfi_offset 14, -4
 1240 0002 82B0     		sub	sp, sp, #8
 1241              	.LCFI79:
 1242              		.cfi_def_cfa_offset 16
 1243 0004 00AF     		add	r7, sp, #0
 1244              	.LCFI80:
 1245              		.cfi_def_cfa_register 7
 493:Src/mc_api.c  ****   return (MCI_GetIalphabeta(pMCI[M1]));
 1246              		.loc 1 493 11
 1247 0006 094B     		ldr	r3, .L104
 1248 0008 1B68     		ldr	r3, [r3]
 1249 000a 1846     		mov	r0, r3
 1250 000c FFF7FEFF 		bl	MCI_GetIalphabeta
 1251 0010 0346     		mov	r3, r0
 1252 0012 7B60     		str	r3, [r7, #4]
 1253 0014 0023     		movs	r3, #0
 1254 0016 BA88     		ldrh	r2, [r7, #4]
 1255 0018 62F30F03 		bfi	r3, r2, #0, #16
 1256 001c FA88     		ldrh	r2, [r7, #6]
 1257 001e 62F31F43 		bfi	r3, r2, #16, #16
 494:Src/mc_api.c  **** }
 1258              		.loc 1 494 1
 1259 0022 1846     		mov	r0, r3
 1260 0024 0837     		adds	r7, r7, #8
 1261              	.LCFI81:
 1262              		.cfi_def_cfa_offset 8
 1263 0026 BD46     		mov	sp, r7
 1264              	.LCFI82:
 1265              		.cfi_def_cfa_register 13
 1266              		@ sp needed
 1267 0028 80BD     		pop	{r7, pc}
 1268              	.L105:
 1269 002a 00BF     		.align	2
 1270              	.L104:
 1271 002c 00000000 		.word	pMCI
 1272              		.cfi_endproc
 1273              	.LFE1740:
 1275              		.section	.text.MC_GetIqdMotor1,"ax",%progbits
ARM GAS  /tmp/ccw08S9Z.s 			page 31


 1276              		.align	1
 1277              		.weak	MC_GetIqdMotor1
 1278              		.syntax unified
 1279              		.thumb
 1280              		.thumb_func
 1281              		.fpu fpv4-sp-d16
 1283              	MC_GetIqdMotor1:
 1284              	.LFB1741:
 495:Src/mc_api.c  **** 
 496:Src/mc_api.c  **** /**
 497:Src/mc_api.c  ****  * @brief returns Iq and Id current values for Motor 1 in qd_t format
 498:Src/mc_api.c  ****  */
 499:Src/mc_api.c  **** __weak qd_t MC_GetIqdMotor1(void)
 500:Src/mc_api.c  **** {
 1285              		.loc 1 500 1
 1286              		.cfi_startproc
 1287              		@ args = 0, pretend = 0, frame = 8
 1288              		@ frame_needed = 1, uses_anonymous_args = 0
 1289 0000 80B5     		push	{r7, lr}
 1290              	.LCFI83:
 1291              		.cfi_def_cfa_offset 8
 1292              		.cfi_offset 7, -8
 1293              		.cfi_offset 14, -4
 1294 0002 82B0     		sub	sp, sp, #8
 1295              	.LCFI84:
 1296              		.cfi_def_cfa_offset 16
 1297 0004 00AF     		add	r7, sp, #0
 1298              	.LCFI85:
 1299              		.cfi_def_cfa_register 7
 501:Src/mc_api.c  ****   return (MCI_GetIqd(pMCI[M1]));
 1300              		.loc 1 501 11
 1301 0006 094B     		ldr	r3, .L108
 1302 0008 1B68     		ldr	r3, [r3]
 1303 000a 1846     		mov	r0, r3
 1304 000c FFF7FEFF 		bl	MCI_GetIqd
 1305 0010 0346     		mov	r3, r0
 1306 0012 7B60     		str	r3, [r7, #4]
 1307 0014 0023     		movs	r3, #0
 1308 0016 BA88     		ldrh	r2, [r7, #4]
 1309 0018 62F30F03 		bfi	r3, r2, #0, #16
 1310 001c FA88     		ldrh	r2, [r7, #6]
 1311 001e 62F31F43 		bfi	r3, r2, #16, #16
 502:Src/mc_api.c  **** }
 1312              		.loc 1 502 1
 1313 0022 1846     		mov	r0, r3
 1314 0024 0837     		adds	r7, r7, #8
 1315              	.LCFI86:
 1316              		.cfi_def_cfa_offset 8
 1317 0026 BD46     		mov	sp, r7
 1318              	.LCFI87:
 1319              		.cfi_def_cfa_register 13
 1320              		@ sp needed
 1321 0028 80BD     		pop	{r7, pc}
 1322              	.L109:
 1323 002a 00BF     		.align	2
 1324              	.L108:
 1325 002c 00000000 		.word	pMCI
ARM GAS  /tmp/ccw08S9Z.s 			page 32


 1326              		.cfi_endproc
 1327              	.LFE1741:
 1329              		.section	.text.MC_GetIqdMotor1_F,"ax",%progbits
 1330              		.align	1
 1331              		.weak	MC_GetIqdMotor1_F
 1332              		.syntax unified
 1333              		.thumb
 1334              		.thumb_func
 1335              		.fpu fpv4-sp-d16
 1337              	MC_GetIqdMotor1_F:
 1338              	.LFB1742:
 503:Src/mc_api.c  **** 
 504:Src/mc_api.c  **** /**
 505:Src/mc_api.c  ****  * @brief returns Iq and Id current values for Motor 1 in float_t type
 506:Src/mc_api.c  ****  */
 507:Src/mc_api.c  **** __weak qd_f_t MC_GetIqdMotor1_F(void)
 508:Src/mc_api.c  **** {
 1339              		.loc 1 508 1
 1340              		.cfi_startproc
 1341              		@ args = 0, pretend = 0, frame = 16
 1342              		@ frame_needed = 1, uses_anonymous_args = 0
 1343 0000 80B5     		push	{r7, lr}
 1344              	.LCFI88:
 1345              		.cfi_def_cfa_offset 8
 1346              		.cfi_offset 7, -8
 1347              		.cfi_offset 14, -4
 1348 0002 84B0     		sub	sp, sp, #16
 1349              	.LCFI89:
 1350              		.cfi_def_cfa_offset 24
 1351 0004 00AF     		add	r7, sp, #0
 1352              	.LCFI90:
 1353              		.cfi_def_cfa_register 7
 509:Src/mc_api.c  ****   return (MCI_GetIqd_F(pMCI[M1]));
 1354              		.loc 1 509 11
 1355 0006 0D4B     		ldr	r3, .L112
 1356 0008 1B68     		ldr	r3, [r3]
 1357 000a 1846     		mov	r0, r3
 1358 000c FFF7FEFF 		bl	MCI_GetIqd_F
 1359 0010 B0EE407A 		vmov.f32	s14, s0
 1360 0014 F0EE607A 		vmov.f32	s15, s1
 1361 0018 87ED027A 		vstr.32	s14, [r7, #8]
 1362 001c C7ED037A 		vstr.32	s15, [r7, #12]
 1363 0020 BA68     		ldr	r2, [r7, #8]	@ float
 1364 0022 FB68     		ldr	r3, [r7, #12]	@ float
 1365 0024 07EE102A 		vmov	s14, r2
 1366 0028 07EE903A 		vmov	s15, r3
 510:Src/mc_api.c  **** }
 1367              		.loc 1 510 1
 1368 002c B0EE470A 		vmov.f32	s0, s14
 1369 0030 F0EE670A 		vmov.f32	s1, s15
 1370 0034 1037     		adds	r7, r7, #16
 1371              	.LCFI91:
 1372              		.cfi_def_cfa_offset 8
 1373 0036 BD46     		mov	sp, r7
 1374              	.LCFI92:
 1375              		.cfi_def_cfa_register 13
 1376              		@ sp needed
ARM GAS  /tmp/ccw08S9Z.s 			page 33


 1377 0038 80BD     		pop	{r7, pc}
 1378              	.L113:
 1379 003a 00BF     		.align	2
 1380              	.L112:
 1381 003c 00000000 		.word	pMCI
 1382              		.cfi_endproc
 1383              	.LFE1742:
 1385              		.section	.text.MC_GetIqdrefMotor1,"ax",%progbits
 1386              		.align	1
 1387              		.weak	MC_GetIqdrefMotor1
 1388              		.syntax unified
 1389              		.thumb
 1390              		.thumb_func
 1391              		.fpu fpv4-sp-d16
 1393              	MC_GetIqdrefMotor1:
 1394              	.LFB1743:
 511:Src/mc_api.c  **** 
 512:Src/mc_api.c  **** /**
 513:Src/mc_api.c  ****  * @brief returns Iq and Id reference current values for Motor 1 in qd_t format
 514:Src/mc_api.c  ****  */
 515:Src/mc_api.c  **** __weak qd_t MC_GetIqdrefMotor1(void)
 516:Src/mc_api.c  **** {
 1395              		.loc 1 516 1
 1396              		.cfi_startproc
 1397              		@ args = 0, pretend = 0, frame = 8
 1398              		@ frame_needed = 1, uses_anonymous_args = 0
 1399 0000 80B5     		push	{r7, lr}
 1400              	.LCFI93:
 1401              		.cfi_def_cfa_offset 8
 1402              		.cfi_offset 7, -8
 1403              		.cfi_offset 14, -4
 1404 0002 82B0     		sub	sp, sp, #8
 1405              	.LCFI94:
 1406              		.cfi_def_cfa_offset 16
 1407 0004 00AF     		add	r7, sp, #0
 1408              	.LCFI95:
 1409              		.cfi_def_cfa_register 7
 517:Src/mc_api.c  ****   return (MCI_GetIqdref(pMCI[M1]));
 1410              		.loc 1 517 11
 1411 0006 094B     		ldr	r3, .L116
 1412 0008 1B68     		ldr	r3, [r3]
 1413 000a 1846     		mov	r0, r3
 1414 000c FFF7FEFF 		bl	MCI_GetIqdref
 1415 0010 0346     		mov	r3, r0
 1416 0012 7B60     		str	r3, [r7, #4]
 1417 0014 0023     		movs	r3, #0
 1418 0016 BA88     		ldrh	r2, [r7, #4]
 1419 0018 62F30F03 		bfi	r3, r2, #0, #16
 1420 001c FA88     		ldrh	r2, [r7, #6]
 1421 001e 62F31F43 		bfi	r3, r2, #16, #16
 518:Src/mc_api.c  **** }
 1422              		.loc 1 518 1
 1423 0022 1846     		mov	r0, r3
 1424 0024 0837     		adds	r7, r7, #8
 1425              	.LCFI96:
 1426              		.cfi_def_cfa_offset 8
 1427 0026 BD46     		mov	sp, r7
ARM GAS  /tmp/ccw08S9Z.s 			page 34


 1428              	.LCFI97:
 1429              		.cfi_def_cfa_register 13
 1430              		@ sp needed
 1431 0028 80BD     		pop	{r7, pc}
 1432              	.L117:
 1433 002a 00BF     		.align	2
 1434              	.L116:
 1435 002c 00000000 		.word	pMCI
 1436              		.cfi_endproc
 1437              	.LFE1743:
 1439              		.section	.text.MC_GetIqdrefMotor1_F,"ax",%progbits
 1440              		.align	1
 1441              		.weak	MC_GetIqdrefMotor1_F
 1442              		.syntax unified
 1443              		.thumb
 1444              		.thumb_func
 1445              		.fpu fpv4-sp-d16
 1447              	MC_GetIqdrefMotor1_F:
 1448              	.LFB1744:
 519:Src/mc_api.c  **** 
 520:Src/mc_api.c  **** /**
 521:Src/mc_api.c  ****  * @brief returns Iq and Id reference current values for Motor 1 in float_t type
 522:Src/mc_api.c  ****  */
 523:Src/mc_api.c  **** __weak qd_f_t MC_GetIqdrefMotor1_F(void)
 524:Src/mc_api.c  **** {
 1449              		.loc 1 524 1
 1450              		.cfi_startproc
 1451              		@ args = 0, pretend = 0, frame = 16
 1452              		@ frame_needed = 1, uses_anonymous_args = 0
 1453 0000 80B5     		push	{r7, lr}
 1454              	.LCFI98:
 1455              		.cfi_def_cfa_offset 8
 1456              		.cfi_offset 7, -8
 1457              		.cfi_offset 14, -4
 1458 0002 84B0     		sub	sp, sp, #16
 1459              	.LCFI99:
 1460              		.cfi_def_cfa_offset 24
 1461 0004 00AF     		add	r7, sp, #0
 1462              	.LCFI100:
 1463              		.cfi_def_cfa_register 7
 525:Src/mc_api.c  ****   return (MCI_GetIqdref_F(pMCI[M1]));
 1464              		.loc 1 525 11
 1465 0006 0D4B     		ldr	r3, .L120
 1466 0008 1B68     		ldr	r3, [r3]
 1467 000a 1846     		mov	r0, r3
 1468 000c FFF7FEFF 		bl	MCI_GetIqdref_F
 1469 0010 B0EE407A 		vmov.f32	s14, s0
 1470 0014 F0EE607A 		vmov.f32	s15, s1
 1471 0018 87ED027A 		vstr.32	s14, [r7, #8]
 1472 001c C7ED037A 		vstr.32	s15, [r7, #12]
 1473 0020 BA68     		ldr	r2, [r7, #8]	@ float
 1474 0022 FB68     		ldr	r3, [r7, #12]	@ float
 1475 0024 07EE102A 		vmov	s14, r2
 1476 0028 07EE903A 		vmov	s15, r3
 526:Src/mc_api.c  **** }
 1477              		.loc 1 526 1
 1478 002c B0EE470A 		vmov.f32	s0, s14
ARM GAS  /tmp/ccw08S9Z.s 			page 35


 1479 0030 F0EE670A 		vmov.f32	s1, s15
 1480 0034 1037     		adds	r7, r7, #16
 1481              	.LCFI101:
 1482              		.cfi_def_cfa_offset 8
 1483 0036 BD46     		mov	sp, r7
 1484              	.LCFI102:
 1485              		.cfi_def_cfa_register 13
 1486              		@ sp needed
 1487 0038 80BD     		pop	{r7, pc}
 1488              	.L121:
 1489 003a 00BF     		.align	2
 1490              	.L120:
 1491 003c 00000000 		.word	pMCI
 1492              		.cfi_endproc
 1493              	.LFE1744:
 1495              		.section	.text.MC_GetVqdMotor1,"ax",%progbits
 1496              		.align	1
 1497              		.weak	MC_GetVqdMotor1
 1498              		.syntax unified
 1499              		.thumb
 1500              		.thumb_func
 1501              		.fpu fpv4-sp-d16
 1503              	MC_GetVqdMotor1:
 1504              	.LFB1745:
 527:Src/mc_api.c  **** 
 528:Src/mc_api.c  **** /**
 529:Src/mc_api.c  ****  * @brief returns Vq and Vd voltage values for Motor 1 in qd_t format
 530:Src/mc_api.c  ****  */
 531:Src/mc_api.c  **** __weak qd_t MC_GetVqdMotor1(void)
 532:Src/mc_api.c  **** {
 1505              		.loc 1 532 1
 1506              		.cfi_startproc
 1507              		@ args = 0, pretend = 0, frame = 8
 1508              		@ frame_needed = 1, uses_anonymous_args = 0
 1509 0000 80B5     		push	{r7, lr}
 1510              	.LCFI103:
 1511              		.cfi_def_cfa_offset 8
 1512              		.cfi_offset 7, -8
 1513              		.cfi_offset 14, -4
 1514 0002 82B0     		sub	sp, sp, #8
 1515              	.LCFI104:
 1516              		.cfi_def_cfa_offset 16
 1517 0004 00AF     		add	r7, sp, #0
 1518              	.LCFI105:
 1519              		.cfi_def_cfa_register 7
 533:Src/mc_api.c  ****   return (MCI_GetVqd(pMCI[M1]));
 1520              		.loc 1 533 11
 1521 0006 094B     		ldr	r3, .L124
 1522 0008 1B68     		ldr	r3, [r3]
 1523 000a 1846     		mov	r0, r3
 1524 000c FFF7FEFF 		bl	MCI_GetVqd
 1525 0010 0346     		mov	r3, r0
 1526 0012 7B60     		str	r3, [r7, #4]
 1527 0014 0023     		movs	r3, #0
 1528 0016 BA88     		ldrh	r2, [r7, #4]
 1529 0018 62F30F03 		bfi	r3, r2, #0, #16
 1530 001c FA88     		ldrh	r2, [r7, #6]
ARM GAS  /tmp/ccw08S9Z.s 			page 36


 1531 001e 62F31F43 		bfi	r3, r2, #16, #16
 534:Src/mc_api.c  **** }
 1532              		.loc 1 534 1
 1533 0022 1846     		mov	r0, r3
 1534 0024 0837     		adds	r7, r7, #8
 1535              	.LCFI106:
 1536              		.cfi_def_cfa_offset 8
 1537 0026 BD46     		mov	sp, r7
 1538              	.LCFI107:
 1539              		.cfi_def_cfa_register 13
 1540              		@ sp needed
 1541 0028 80BD     		pop	{r7, pc}
 1542              	.L125:
 1543 002a 00BF     		.align	2
 1544              	.L124:
 1545 002c 00000000 		.word	pMCI
 1546              		.cfi_endproc
 1547              	.LFE1745:
 1549              		.section	.text.MC_GetValphabetaMotor1,"ax",%progbits
 1550              		.align	1
 1551              		.weak	MC_GetValphabetaMotor1
 1552              		.syntax unified
 1553              		.thumb
 1554              		.thumb_func
 1555              		.fpu fpv4-sp-d16
 1557              	MC_GetValphabetaMotor1:
 1558              	.LFB1746:
 535:Src/mc_api.c  **** 
 536:Src/mc_api.c  **** /**
 537:Src/mc_api.c  ****  * @brief returns Valpha and Vbeta voltage values for Motor 1 in alphabeta_t format
 538:Src/mc_api.c  ****  */
 539:Src/mc_api.c  **** __weak alphabeta_t MC_GetValphabetaMotor1(void)
 540:Src/mc_api.c  **** {
 1559              		.loc 1 540 1
 1560              		.cfi_startproc
 1561              		@ args = 0, pretend = 0, frame = 8
 1562              		@ frame_needed = 1, uses_anonymous_args = 0
 1563 0000 80B5     		push	{r7, lr}
 1564              	.LCFI108:
 1565              		.cfi_def_cfa_offset 8
 1566              		.cfi_offset 7, -8
 1567              		.cfi_offset 14, -4
 1568 0002 82B0     		sub	sp, sp, #8
 1569              	.LCFI109:
 1570              		.cfi_def_cfa_offset 16
 1571 0004 00AF     		add	r7, sp, #0
 1572              	.LCFI110:
 1573              		.cfi_def_cfa_register 7
 541:Src/mc_api.c  ****   return (MCI_GetValphabeta(pMCI[M1]));
 1574              		.loc 1 541 11
 1575 0006 094B     		ldr	r3, .L128
 1576 0008 1B68     		ldr	r3, [r3]
 1577 000a 1846     		mov	r0, r3
 1578 000c FFF7FEFF 		bl	MCI_GetValphabeta
 1579 0010 0346     		mov	r3, r0
 1580 0012 7B60     		str	r3, [r7, #4]
 1581 0014 0023     		movs	r3, #0
ARM GAS  /tmp/ccw08S9Z.s 			page 37


 1582 0016 BA88     		ldrh	r2, [r7, #4]
 1583 0018 62F30F03 		bfi	r3, r2, #0, #16
 1584 001c FA88     		ldrh	r2, [r7, #6]
 1585 001e 62F31F43 		bfi	r3, r2, #16, #16
 542:Src/mc_api.c  **** }
 1586              		.loc 1 542 1
 1587 0022 1846     		mov	r0, r3
 1588 0024 0837     		adds	r7, r7, #8
 1589              	.LCFI111:
 1590              		.cfi_def_cfa_offset 8
 1591 0026 BD46     		mov	sp, r7
 1592              	.LCFI112:
 1593              		.cfi_def_cfa_register 13
 1594              		@ sp needed
 1595 0028 80BD     		pop	{r7, pc}
 1596              	.L129:
 1597 002a 00BF     		.align	2
 1598              	.L128:
 1599 002c 00000000 		.word	pMCI
 1600              		.cfi_endproc
 1601              	.LFE1746:
 1603              		.section	.text.MC_GetElAngledppMotor1,"ax",%progbits
 1604              		.align	1
 1605              		.weak	MC_GetElAngledppMotor1
 1606              		.syntax unified
 1607              		.thumb
 1608              		.thumb_func
 1609              		.fpu fpv4-sp-d16
 1611              	MC_GetElAngledppMotor1:
 1612              	.LFB1747:
 543:Src/mc_api.c  **** 
 544:Src/mc_api.c  **** /**
 545:Src/mc_api.c  ****  * @brief returns the electrical angle of the rotor of Motor 1, in DDP format
 546:Src/mc_api.c  ****  */
 547:Src/mc_api.c  **** __weak int16_t MC_GetElAngledppMotor1(void)
 548:Src/mc_api.c  **** {
 1613              		.loc 1 548 1
 1614              		.cfi_startproc
 1615              		@ args = 0, pretend = 0, frame = 0
 1616              		@ frame_needed = 1, uses_anonymous_args = 0
 1617 0000 80B5     		push	{r7, lr}
 1618              	.LCFI113:
 1619              		.cfi_def_cfa_offset 8
 1620              		.cfi_offset 7, -8
 1621              		.cfi_offset 14, -4
 1622 0002 00AF     		add	r7, sp, #0
 1623              	.LCFI114:
 1624              		.cfi_def_cfa_register 7
 549:Src/mc_api.c  ****   return (MCI_GetElAngledpp(pMCI[M1]));
 1625              		.loc 1 549 11
 1626 0004 034B     		ldr	r3, .L132
 1627 0006 1B68     		ldr	r3, [r3]
 1628 0008 1846     		mov	r0, r3
 1629 000a FFF7FEFF 		bl	MCI_GetElAngledpp
 1630 000e 0346     		mov	r3, r0
 550:Src/mc_api.c  **** }
 1631              		.loc 1 550 1
ARM GAS  /tmp/ccw08S9Z.s 			page 38


 1632 0010 1846     		mov	r0, r3
 1633 0012 80BD     		pop	{r7, pc}
 1634              	.L133:
 1635              		.align	2
 1636              	.L132:
 1637 0014 00000000 		.word	pMCI
 1638              		.cfi_endproc
 1639              	.LFE1747:
 1641              		.section	.text.MC_GetTerefMotor1,"ax",%progbits
 1642              		.align	1
 1643              		.weak	MC_GetTerefMotor1
 1644              		.syntax unified
 1645              		.thumb
 1646              		.thumb_func
 1647              		.fpu fpv4-sp-d16
 1649              	MC_GetTerefMotor1:
 1650              	.LFB1748:
 551:Src/mc_api.c  **** 
 552:Src/mc_api.c  **** /**
 553:Src/mc_api.c  ****  * @brief returns the electrical torque reference for Motor 1
 554:Src/mc_api.c  ****  */
 555:Src/mc_api.c  **** __weak int16_t MC_GetTerefMotor1(void)
 556:Src/mc_api.c  **** {
 1651              		.loc 1 556 1
 1652              		.cfi_startproc
 1653              		@ args = 0, pretend = 0, frame = 0
 1654              		@ frame_needed = 1, uses_anonymous_args = 0
 1655 0000 80B5     		push	{r7, lr}
 1656              	.LCFI115:
 1657              		.cfi_def_cfa_offset 8
 1658              		.cfi_offset 7, -8
 1659              		.cfi_offset 14, -4
 1660 0002 00AF     		add	r7, sp, #0
 1661              	.LCFI116:
 1662              		.cfi_def_cfa_register 7
 557:Src/mc_api.c  ****   return (MCI_GetTeref(pMCI[M1]));
 1663              		.loc 1 557 11
 1664 0004 034B     		ldr	r3, .L136
 1665 0006 1B68     		ldr	r3, [r3]
 1666 0008 1846     		mov	r0, r3
 1667 000a FFF7FEFF 		bl	MCI_GetTeref
 1668 000e 0346     		mov	r3, r0
 558:Src/mc_api.c  **** }
 1669              		.loc 1 558 1
 1670 0010 1846     		mov	r0, r3
 1671 0012 80BD     		pop	{r7, pc}
 1672              	.L137:
 1673              		.align	2
 1674              	.L136:
 1675 0014 00000000 		.word	pMCI
 1676              		.cfi_endproc
 1677              	.LFE1748:
 1679              		.section	.text.MC_GetTerefMotor1_F,"ax",%progbits
 1680              		.align	1
 1681              		.weak	MC_GetTerefMotor1_F
 1682              		.syntax unified
 1683              		.thumb
ARM GAS  /tmp/ccw08S9Z.s 			page 39


 1684              		.thumb_func
 1685              		.fpu fpv4-sp-d16
 1687              	MC_GetTerefMotor1_F:
 1688              	.LFB1749:
 559:Src/mc_api.c  **** 
 560:Src/mc_api.c  **** /**
 561:Src/mc_api.c  ****  * @brief returns the electrical torque reference for Motor 1
 562:Src/mc_api.c  ****  */
 563:Src/mc_api.c  **** __weak float_t MC_GetTerefMotor1_F(void)
 564:Src/mc_api.c  **** {
 1689              		.loc 1 564 1
 1690              		.cfi_startproc
 1691              		@ args = 0, pretend = 0, frame = 0
 1692              		@ frame_needed = 1, uses_anonymous_args = 0
 1693 0000 80B5     		push	{r7, lr}
 1694              	.LCFI117:
 1695              		.cfi_def_cfa_offset 8
 1696              		.cfi_offset 7, -8
 1697              		.cfi_offset 14, -4
 1698 0002 00AF     		add	r7, sp, #0
 1699              	.LCFI118:
 1700              		.cfi_def_cfa_register 7
 565:Src/mc_api.c  ****   return (MCI_GetTeref_F(pMCI[M1]));
 1701              		.loc 1 565 11
 1702 0004 044B     		ldr	r3, .L140
 1703 0006 1B68     		ldr	r3, [r3]
 1704 0008 1846     		mov	r0, r3
 1705 000a FFF7FEFF 		bl	MCI_GetTeref_F
 1706 000e F0EE407A 		vmov.f32	s15, s0
 566:Src/mc_api.c  **** }
 1707              		.loc 1 566 1
 1708 0012 B0EE670A 		vmov.f32	s0, s15
 1709 0016 80BD     		pop	{r7, pc}
 1710              	.L141:
 1711              		.align	2
 1712              	.L140:
 1713 0018 00000000 		.word	pMCI
 1714              		.cfi_endproc
 1715              	.LFE1749:
 1717              		.section	.text.MC_Clear_IqdrefMotor1,"ax",%progbits
 1718              		.align	1
 1719              		.weak	MC_Clear_IqdrefMotor1
 1720              		.syntax unified
 1721              		.thumb
 1722              		.thumb_func
 1723              		.fpu fpv4-sp-d16
 1725              	MC_Clear_IqdrefMotor1:
 1726              	.LFB1750:
 567:Src/mc_api.c  **** 
 568:Src/mc_api.c  **** /**
 569:Src/mc_api.c  ****  * @brief re-initializes Iq and Id references to their default values for Motor 1
 570:Src/mc_api.c  ****  *
 571:Src/mc_api.c  ****  * The default values for the Iq and Id references are coming from the Speed
 572:Src/mc_api.c  ****  * or the Torque controller depending on the control mode.
 573:Src/mc_api.c  ****  *
 574:Src/mc_api.c  ****  * @see   SpeednTorqCtrl for more details.
 575:Src/mc_api.c  ****  */
ARM GAS  /tmp/ccw08S9Z.s 			page 40


 576:Src/mc_api.c  **** __weak void MC_Clear_IqdrefMotor1(void)
 577:Src/mc_api.c  **** {
 1727              		.loc 1 577 1
 1728              		.cfi_startproc
 1729              		@ args = 0, pretend = 0, frame = 0
 1730              		@ frame_needed = 1, uses_anonymous_args = 0
 1731 0000 80B5     		push	{r7, lr}
 1732              	.LCFI119:
 1733              		.cfi_def_cfa_offset 8
 1734              		.cfi_offset 7, -8
 1735              		.cfi_offset 14, -4
 1736 0002 00AF     		add	r7, sp, #0
 1737              	.LCFI120:
 1738              		.cfi_def_cfa_register 7
 578:Src/mc_api.c  ****   MCI_Clear_Iqdref(pMCI[M1]);
 1739              		.loc 1 578 3
 1740 0004 034B     		ldr	r3, .L143
 1741 0006 1B68     		ldr	r3, [r3]
 1742 0008 1846     		mov	r0, r3
 1743 000a FFF7FEFF 		bl	MCI_Clear_Iqdref
 579:Src/mc_api.c  **** }
 1744              		.loc 1 579 1
 1745 000e 00BF     		nop
 1746 0010 80BD     		pop	{r7, pc}
 1747              	.L144:
 1748 0012 00BF     		.align	2
 1749              	.L143:
 1750 0014 00000000 		.word	pMCI
 1751              		.cfi_endproc
 1752              	.LFE1750:
 1754              		.section	.text.MC_AcknowledgeFaultMotor1,"ax",%progbits
 1755              		.align	1
 1756              		.weak	MC_AcknowledgeFaultMotor1
 1757              		.syntax unified
 1758              		.thumb
 1759              		.thumb_func
 1760              		.fpu fpv4-sp-d16
 1762              	MC_AcknowledgeFaultMotor1:
 1763              	.LFB1751:
 580:Src/mc_api.c  **** 
 581:Src/mc_api.c  **** /**
 582:Src/mc_api.c  ****  * @brief Acknowledge a Motor Control fault that occured on Motor 1
 583:Src/mc_api.c  ****  *
 584:Src/mc_api.c  ****  *  This function informs Motor 1's state machine that the Application has taken
 585:Src/mc_api.c  ****  * the error condition that occured into account. If no error condition exists when
 586:Src/mc_api.c  ****  * the function is called, nothing is done and false is returned. Otherwise, true is
 587:Src/mc_api.c  ****  * returned.
 588:Src/mc_api.c  ****  */
 589:Src/mc_api.c  **** __weak bool MC_AcknowledgeFaultMotor1(void)
 590:Src/mc_api.c  **** {
 1764              		.loc 1 590 1
 1765              		.cfi_startproc
 1766              		@ args = 0, pretend = 0, frame = 0
 1767              		@ frame_needed = 1, uses_anonymous_args = 0
 1768 0000 80B5     		push	{r7, lr}
 1769              	.LCFI121:
 1770              		.cfi_def_cfa_offset 8
ARM GAS  /tmp/ccw08S9Z.s 			page 41


 1771              		.cfi_offset 7, -8
 1772              		.cfi_offset 14, -4
 1773 0002 00AF     		add	r7, sp, #0
 1774              	.LCFI122:
 1775              		.cfi_def_cfa_register 7
 591:Src/mc_api.c  ****   return (MCI_FaultAcknowledged(pMCI[M1]));
 1776              		.loc 1 591 11
 1777 0004 034B     		ldr	r3, .L147
 1778 0006 1B68     		ldr	r3, [r3]
 1779 0008 1846     		mov	r0, r3
 1780 000a FFF7FEFF 		bl	MCI_FaultAcknowledged
 1781 000e 0346     		mov	r3, r0
 592:Src/mc_api.c  **** }
 1782              		.loc 1 592 1
 1783 0010 1846     		mov	r0, r3
 1784 0012 80BD     		pop	{r7, pc}
 1785              	.L148:
 1786              		.align	2
 1787              	.L147:
 1788 0014 00000000 		.word	pMCI
 1789              		.cfi_endproc
 1790              	.LFE1751:
 1792              		.section	.text.MC_GetOccurredFaultsMotor1,"ax",%progbits
 1793              		.align	1
 1794              		.weak	MC_GetOccurredFaultsMotor1
 1795              		.syntax unified
 1796              		.thumb
 1797              		.thumb_func
 1798              		.fpu fpv4-sp-d16
 1800              	MC_GetOccurredFaultsMotor1:
 1801              	.LFB1752:
 593:Src/mc_api.c  **** 
 594:Src/mc_api.c  **** /**
 595:Src/mc_api.c  ****  * @brief Returns a bit-field showing non acknowledged faults that occurred on Motor 1.
 596:Src/mc_api.c  ****  *
 597:Src/mc_api.c  ****  * This function returns a 16 bit fields containing the Motor Control faults
 598:Src/mc_api.c  ****  * that have occurred on Motor 1 since its state machine moved to the #FAULT_NOW state.
 599:Src/mc_api.c  ****  *
 600:Src/mc_api.c  ****  * See @ref fault_codes "Motor Control Faults" for a list of
 601:Src/mc_api.c  ****  * of all possible faults codes.
 602:Src/mc_api.c  ****  */
 603:Src/mc_api.c  **** __weak uint16_t MC_GetOccurredFaultsMotor1(void)
 604:Src/mc_api.c  **** {
 1802              		.loc 1 604 1
 1803              		.cfi_startproc
 1804              		@ args = 0, pretend = 0, frame = 0
 1805              		@ frame_needed = 1, uses_anonymous_args = 0
 1806 0000 80B5     		push	{r7, lr}
 1807              	.LCFI123:
 1808              		.cfi_def_cfa_offset 8
 1809              		.cfi_offset 7, -8
 1810              		.cfi_offset 14, -4
 1811 0002 00AF     		add	r7, sp, #0
 1812              	.LCFI124:
 1813              		.cfi_def_cfa_register 7
 605:Src/mc_api.c  ****   return (MCI_GetOccurredFaults(pMCI[M1]));
 1814              		.loc 1 605 11
ARM GAS  /tmp/ccw08S9Z.s 			page 42


 1815 0004 034B     		ldr	r3, .L151
 1816 0006 1B68     		ldr	r3, [r3]
 1817 0008 1846     		mov	r0, r3
 1818 000a FFF7FEFF 		bl	MCI_GetOccurredFaults
 1819 000e 0346     		mov	r3, r0
 606:Src/mc_api.c  **** }
 1820              		.loc 1 606 1
 1821 0010 1846     		mov	r0, r3
 1822 0012 80BD     		pop	{r7, pc}
 1823              	.L152:
 1824              		.align	2
 1825              	.L151:
 1826 0014 00000000 		.word	pMCI
 1827              		.cfi_endproc
 1828              	.LFE1752:
 1830              		.section	.text.MC_GetCurrentFaultsMotor1,"ax",%progbits
 1831              		.align	1
 1832              		.weak	MC_GetCurrentFaultsMotor1
 1833              		.syntax unified
 1834              		.thumb
 1835              		.thumb_func
 1836              		.fpu fpv4-sp-d16
 1838              	MC_GetCurrentFaultsMotor1:
 1839              	.LFB1753:
 607:Src/mc_api.c  **** 
 608:Src/mc_api.c  **** /**
 609:Src/mc_api.c  ****  * @brief returns a bitfield showing all current faults on Motor 1
 610:Src/mc_api.c  ****  *
 611:Src/mc_api.c  ****  * This function returns a 16 bit fields containing the Motor Control faults
 612:Src/mc_api.c  ****  * that are currently active.
 613:Src/mc_api.c  ****  *
 614:Src/mc_api.c  ****  * See @ref fault_codes "Motor Control Faults" for a list of
 615:Src/mc_api.c  ****  * of all possible faults codes.
 616:Src/mc_api.c  ****  */
 617:Src/mc_api.c  **** __weak uint16_t MC_GetCurrentFaultsMotor1(void)
 618:Src/mc_api.c  **** {
 1840              		.loc 1 618 1
 1841              		.cfi_startproc
 1842              		@ args = 0, pretend = 0, frame = 0
 1843              		@ frame_needed = 1, uses_anonymous_args = 0
 1844 0000 80B5     		push	{r7, lr}
 1845              	.LCFI125:
 1846              		.cfi_def_cfa_offset 8
 1847              		.cfi_offset 7, -8
 1848              		.cfi_offset 14, -4
 1849 0002 00AF     		add	r7, sp, #0
 1850              	.LCFI126:
 1851              		.cfi_def_cfa_register 7
 619:Src/mc_api.c  ****   return (MCI_GetCurrentFaults(pMCI[M1]));
 1852              		.loc 1 619 11
 1853 0004 034B     		ldr	r3, .L155
 1854 0006 1B68     		ldr	r3, [r3]
 1855 0008 1846     		mov	r0, r3
 1856 000a FFF7FEFF 		bl	MCI_GetCurrentFaults
 1857 000e 0346     		mov	r3, r0
 620:Src/mc_api.c  **** }
 1858              		.loc 1 620 1
ARM GAS  /tmp/ccw08S9Z.s 			page 43


 1859 0010 1846     		mov	r0, r3
 1860 0012 80BD     		pop	{r7, pc}
 1861              	.L156:
 1862              		.align	2
 1863              	.L155:
 1864 0014 00000000 		.word	pMCI
 1865              		.cfi_endproc
 1866              	.LFE1753:
 1868              		.section	.text.MC_GetSTMStateMotor1,"ax",%progbits
 1869              		.align	1
 1870              		.weak	MC_GetSTMStateMotor1
 1871              		.syntax unified
 1872              		.thumb
 1873              		.thumb_func
 1874              		.fpu fpv4-sp-d16
 1876              	MC_GetSTMStateMotor1:
 1877              	.LFB1754:
 621:Src/mc_api.c  **** 
 622:Src/mc_api.c  **** /**
 623:Src/mc_api.c  ****  * @brief returns the current state of Motor 1 state machine
 624:Src/mc_api.c  ****  */
 625:Src/mc_api.c  **** __weak MCI_State_t MC_GetSTMStateMotor1(void)
 626:Src/mc_api.c  **** {
 1878              		.loc 1 626 1
 1879              		.cfi_startproc
 1880              		@ args = 0, pretend = 0, frame = 0
 1881              		@ frame_needed = 1, uses_anonymous_args = 0
 1882 0000 80B5     		push	{r7, lr}
 1883              	.LCFI127:
 1884              		.cfi_def_cfa_offset 8
 1885              		.cfi_offset 7, -8
 1886              		.cfi_offset 14, -4
 1887 0002 00AF     		add	r7, sp, #0
 1888              	.LCFI128:
 1889              		.cfi_def_cfa_register 7
 627:Src/mc_api.c  ****   return (MCI_GetSTMState(pMCI[M1]));
 1890              		.loc 1 627 11
 1891 0004 034B     		ldr	r3, .L159
 1892 0006 1B68     		ldr	r3, [r3]
 1893 0008 1846     		mov	r0, r3
 1894 000a FFF7FEFF 		bl	MCI_GetSTMState
 1895 000e 0346     		mov	r3, r0
 628:Src/mc_api.c  **** }
 1896              		.loc 1 628 1
 1897 0010 1846     		mov	r0, r3
 1898 0012 80BD     		pop	{r7, pc}
 1899              	.L160:
 1900              		.align	2
 1901              	.L159:
 1902 0014 00000000 		.word	pMCI
 1903              		.cfi_endproc
 1904              	.LFE1754:
 1906              		.section	.text.MC_SetPolarizationOffsetsMotor1,"ax",%progbits
 1907              		.align	1
 1908              		.global	MC_SetPolarizationOffsetsMotor1
 1909              		.syntax unified
 1910              		.thumb
ARM GAS  /tmp/ccw08S9Z.s 			page 44


 1911              		.thumb_func
 1912              		.fpu fpv4-sp-d16
 1914              	MC_SetPolarizationOffsetsMotor1:
 1915              	.LFB1755:
 629:Src/mc_api.c  **** 
 630:Src/mc_api.c  **** /**
 631:Src/mc_api.c  ****   * @brief Sets the polarization offset values to use for Motor 1
 632:Src/mc_api.c  ****   *
 633:Src/mc_api.c  ****   * The Motor Control algorithm relies on a number of current and voltage measures. The hardware
 634:Src/mc_api.c  ****   * parts that make these measurements need to be characterized at least once in the course of
 635:Src/mc_api.c  ****   * product life, prior to its first activation. This characterization consists in measuring the
 636:Src/mc_api.c  ****   * voltage presented to the ADC channels when either no current flows into the phases of the motor
 637:Src/mc_api.c  ****   * or no voltage is applied to them. This characterization is named polarization offsets measureme
 638:Src/mc_api.c  ****   * and its results are the polarization offsets.
 639:Src/mc_api.c  ****   *
 640:Src/mc_api.c  ****   * The Motor Control Firmware can performs this polarization offsets measurement procedure which
 641:Src/mc_api.c  ****   * results in a number of offset values that the application can store in a non volatile memory an
 642:Src/mc_api.c  ****   * then set into the Motor Control subsystem at power-on or after a reset.
 643:Src/mc_api.c  ****   *
 644:Src/mc_api.c  ****   * The application uses this function to set the polarization offset values that the Motor Control
 645:Src/mc_api.c  ****   * subsystem is to use in the current session. This function can only be used when the state machi
 646:Src/mc_api.c  ****   * of the motor is in the #IDLE state in which case it returns #MC_SUCCESS. Otherwise, it does not
 647:Src/mc_api.c  ****   * and returns the #MC_WRONG_STATE_ERROR error code.
 648:Src/mc_api.c  ****   *
 649:Src/mc_api.c  ****   *  The Motor Control subsystem needs to know the polarization offsets before the motor can be con
 650:Src/mc_api.c  ****   * The MC_SetPolarizationOffsetsMotor1() function provides a way to set these offsets. Alternative
 651:Src/mc_api.c  ****   * application can either:
 652:Src/mc_api.c  ****   *
 653:Src/mc_api.c  ****   *  * Execute the polarization offsets measurement procedure with a call to
 654:Src/mc_api.c  ****   *    MC_StartPolarizationOffsetsMeasurementMotor1() after a reset or a power on;
 655:Src/mc_api.c  ****   *  * Start the motor control with the MC_StartWithPolarizationMotor1() that will execute the proc
 656:Src/mc_api.c  ****   *    before actually starting the motor, on the first time it is called after a reset or a power 
 657:Src/mc_api.c  ****   *
 658:Src/mc_api.c  ****   * When this function completes successfully, the state of the polarization offsets measurement pr
 659:Src/mc_api.c  ****   * is set to #COMPLETED. See MC_GetPolarizationState().
 660:Src/mc_api.c  ****   *
 661:Src/mc_api.c  ****   * @param PolarizationOffsets an pointer on a structure containing the offset values
 662:Src/mc_api.c  ****   */
 663:Src/mc_api.c  **** bool MC_SetPolarizationOffsetsMotor1(PolarizationOffsets_t * PolarizationOffsets)
 664:Src/mc_api.c  **** {
 1916              		.loc 1 664 1
 1917              		.cfi_startproc
 1918              		@ args = 0, pretend = 0, frame = 8
 1919              		@ frame_needed = 1, uses_anonymous_args = 0
 1920 0000 80B5     		push	{r7, lr}
 1921              	.LCFI129:
 1922              		.cfi_def_cfa_offset 8
 1923              		.cfi_offset 7, -8
 1924              		.cfi_offset 14, -4
 1925 0002 82B0     		sub	sp, sp, #8
 1926              	.LCFI130:
 1927              		.cfi_def_cfa_offset 16
 1928 0004 00AF     		add	r7, sp, #0
 1929              	.LCFI131:
 1930              		.cfi_def_cfa_register 7
 1931 0006 7860     		str	r0, [r7, #4]
 665:Src/mc_api.c  ****   return (MCI_SetCalibratedOffsetsMotor(pMCI[M1], PolarizationOffsets));
ARM GAS  /tmp/ccw08S9Z.s 			page 45


 1932              		.loc 1 665 11
 1933 0008 054B     		ldr	r3, .L163
 1934 000a 1B68     		ldr	r3, [r3]
 1935 000c 7968     		ldr	r1, [r7, #4]
 1936 000e 1846     		mov	r0, r3
 1937 0010 FFF7FEFF 		bl	MCI_SetCalibratedOffsetsMotor
 1938 0014 0346     		mov	r3, r0
 666:Src/mc_api.c  **** }
 1939              		.loc 1 666 1
 1940 0016 1846     		mov	r0, r3
 1941 0018 0837     		adds	r7, r7, #8
 1942              	.LCFI132:
 1943              		.cfi_def_cfa_offset 8
 1944 001a BD46     		mov	sp, r7
 1945              	.LCFI133:
 1946              		.cfi_def_cfa_register 13
 1947              		@ sp needed
 1948 001c 80BD     		pop	{r7, pc}
 1949              	.L164:
 1950 001e 00BF     		.align	2
 1951              	.L163:
 1952 0020 00000000 		.word	pMCI
 1953              		.cfi_endproc
 1954              	.LFE1755:
 1956              		.section	.text.MC_GetPolarizationOffsetsMotor1,"ax",%progbits
 1957              		.align	1
 1958              		.global	MC_GetPolarizationOffsetsMotor1
 1959              		.syntax unified
 1960              		.thumb
 1961              		.thumb_func
 1962              		.fpu fpv4-sp-d16
 1964              	MC_GetPolarizationOffsetsMotor1:
 1965              	.LFB1756:
 667:Src/mc_api.c  **** 
 668:Src/mc_api.c  **** /**
 669:Src/mc_api.c  ****   * @brief Returns the polarization offset values measured or set for Motor 1
 670:Src/mc_api.c  ****   *
 671:Src/mc_api.c  ****   *  See MC_SetPolarizationOffsetsMotor1() for more details.
 672:Src/mc_api.c  ****   *
 673:Src/mc_api.c  ****   *  If the Motor Control Firmware knows the polarization offset values, they are copied into the
 674:Src/mc_api.c  ****   * @p PolarizationOffsets structure and #MC_SUCCESS is returned. Otherwise, nothing is done and
 675:Src/mc_api.c  ****   * #MC_NO_POLARIZATION_OFFSETS_ERROR is returned.
 676:Src/mc_api.c  ****   *
 677:Src/mc_api.c  ****   * @param PolarizationOffsets an pointer on the structure into which the polarization offsets will
 678:Src/mc_api.c  ****   *        copied
 679:Src/mc_api.c  ****   * @return #MC_SUCCESS if calibration data were present and could be copied into @p PolarizationOf
 680:Src/mc_api.c  ****   *         #MC_NO_POLARIZATION_OFFSETS_ERROR otherwise.
 681:Src/mc_api.c  ****   */
 682:Src/mc_api.c  **** bool MC_GetPolarizationOffsetsMotor1(PolarizationOffsets_t * PolarizationOffsets)
 683:Src/mc_api.c  **** {
 1966              		.loc 1 683 1
 1967              		.cfi_startproc
 1968              		@ args = 0, pretend = 0, frame = 8
 1969              		@ frame_needed = 1, uses_anonymous_args = 0
 1970 0000 80B5     		push	{r7, lr}
 1971              	.LCFI134:
 1972              		.cfi_def_cfa_offset 8
ARM GAS  /tmp/ccw08S9Z.s 			page 46


 1973              		.cfi_offset 7, -8
 1974              		.cfi_offset 14, -4
 1975 0002 82B0     		sub	sp, sp, #8
 1976              	.LCFI135:
 1977              		.cfi_def_cfa_offset 16
 1978 0004 00AF     		add	r7, sp, #0
 1979              	.LCFI136:
 1980              		.cfi_def_cfa_register 7
 1981 0006 7860     		str	r0, [r7, #4]
 684:Src/mc_api.c  ****    return (MCI_GetCalibratedOffsetsMotor(pMCI[M1], PolarizationOffsets));
 1982              		.loc 1 684 12
 1983 0008 054B     		ldr	r3, .L167
 1984 000a 1B68     		ldr	r3, [r3]
 1985 000c 7968     		ldr	r1, [r7, #4]
 1986 000e 1846     		mov	r0, r3
 1987 0010 FFF7FEFF 		bl	MCI_GetCalibratedOffsetsMotor
 1988 0014 0346     		mov	r3, r0
 685:Src/mc_api.c  **** }
 1989              		.loc 1 685 1
 1990 0016 1846     		mov	r0, r3
 1991 0018 0837     		adds	r7, r7, #8
 1992              	.LCFI137:
 1993              		.cfi_def_cfa_offset 8
 1994 001a BD46     		mov	sp, r7
 1995              	.LCFI138:
 1996              		.cfi_def_cfa_register 13
 1997              		@ sp needed
 1998 001c 80BD     		pop	{r7, pc}
 1999              	.L168:
 2000 001e 00BF     		.align	2
 2001              	.L167:
 2002 0020 00000000 		.word	pMCI
 2003              		.cfi_endproc
 2004              	.LFE1756:
 2006              		.section	.text.MC_StartPolarizationOffsetsMeasurementMotor1,"ax",%progbits
 2007              		.align	1
 2008              		.global	MC_StartPolarizationOffsetsMeasurementMotor1
 2009              		.syntax unified
 2010              		.thumb
 2011              		.thumb_func
 2012              		.fpu fpv4-sp-d16
 2014              	MC_StartPolarizationOffsetsMeasurementMotor1:
 2015              	.LFB1757:
 686:Src/mc_api.c  **** 
 687:Src/mc_api.c  **** /**
 688:Src/mc_api.c  ****   * @brief Starts the polarization offsets measurement procedure.
 689:Src/mc_api.c  ****   *
 690:Src/mc_api.c  ****   * See MC_SetPolarizationOffsetsMotor1() for more details.
 691:Src/mc_api.c  ****   *
 692:Src/mc_api.c  ****   * If the Motor Control Firmware is in the #IDLE state, the procedure is started, the state machin
 693:Src/mc_api.c  ****   * of the motor switches to #OFFSET_CALIB and #MC_SUCCESS is returned. Otherwise, nothing is done
 694:Src/mc_api.c  ****   * and the #MC_WRONG_STATE_ERROR error code is returned.
 695:Src/mc_api.c  ****   *
 696:Src/mc_api.c  ****   * The polarization offsets measurement procedure is only triggered by this function and it is has
 697:Src/mc_api.c  ****   * completed when this function returns. The application can use the MC_GetPolarizationState()
 698:Src/mc_api.c  ****   * function to query the state of the procedure.
 699:Src/mc_api.c  ****   *
ARM GAS  /tmp/ccw08S9Z.s 			page 47


 700:Src/mc_api.c  ****   * @see MC_GetPolarizationState()
 701:Src/mc_api.c  ****   */
 702:Src/mc_api.c  **** bool MC_StartPolarizationOffsetsMeasurementMotor1(void)
 703:Src/mc_api.c  **** {
 2016              		.loc 1 703 1
 2017              		.cfi_startproc
 2018              		@ args = 0, pretend = 0, frame = 0
 2019              		@ frame_needed = 1, uses_anonymous_args = 0
 2020 0000 80B5     		push	{r7, lr}
 2021              	.LCFI139:
 2022              		.cfi_def_cfa_offset 8
 2023              		.cfi_offset 7, -8
 2024              		.cfi_offset 14, -4
 2025 0002 00AF     		add	r7, sp, #0
 2026              	.LCFI140:
 2027              		.cfi_def_cfa_register 7
 704:Src/mc_api.c  ****   return (MCI_StartOffsetMeasurments(pMCI[M1]));
 2028              		.loc 1 704 11
 2029 0004 034B     		ldr	r3, .L171
 2030 0006 1B68     		ldr	r3, [r3]
 2031 0008 1846     		mov	r0, r3
 2032 000a FFF7FEFF 		bl	MCI_StartOffsetMeasurments
 2033 000e 0346     		mov	r3, r0
 705:Src/mc_api.c  **** }
 2034              		.loc 1 705 1
 2035 0010 1846     		mov	r0, r3
 2036 0012 80BD     		pop	{r7, pc}
 2037              	.L172:
 2038              		.align	2
 2039              	.L171:
 2040 0014 00000000 		.word	pMCI
 2041              		.cfi_endproc
 2042              	.LFE1757:
 2044              		.section	.text.MC_GetAveragePowerMotor1_F,"ax",%progbits
 2045              		.align	1
 2046              		.weak	MC_GetAveragePowerMotor1_F
 2047              		.syntax unified
 2048              		.thumb
 2049              		.thumb_func
 2050              		.fpu fpv4-sp-d16
 2052              	MC_GetAveragePowerMotor1_F:
 2053              	.LFB1758:
 706:Src/mc_api.c  **** 
 707:Src/mc_api.c  **** /**
 708:Src/mc_api.c  ****  * @brief This method is used to get the average measured motor power
 709:Src/mc_api.c  ****  *        expressed in watt for Motor 1.
 710:Src/mc_api.c  **** 
 711:Src/mc_api.c  ****  * @retval float_t The average measured motor power expressed in watt.
 712:Src/mc_api.c  ****  */
 713:Src/mc_api.c  **** __weak float_t MC_GetAveragePowerMotor1_F(void)
 714:Src/mc_api.c  **** {
 2054              		.loc 1 714 1
 2055              		.cfi_startproc
 2056              		@ args = 0, pretend = 0, frame = 0
 2057              		@ frame_needed = 1, uses_anonymous_args = 0
 2058 0000 80B5     		push	{r7, lr}
 2059              	.LCFI141:
ARM GAS  /tmp/ccw08S9Z.s 			page 48


 2060              		.cfi_def_cfa_offset 8
 2061              		.cfi_offset 7, -8
 2062              		.cfi_offset 14, -4
 2063 0002 00AF     		add	r7, sp, #0
 2064              	.LCFI142:
 2065              		.cfi_def_cfa_register 7
 715:Src/mc_api.c  ****   return (PQD_GetAvrgElMotorPowerW(pMPM[M1]));
 2066              		.loc 1 715 40
 2067 0004 044B     		ldr	r3, .L175
 2068 0006 1B68     		ldr	r3, [r3]
 2069              		.loc 1 715 11
 2070 0008 1846     		mov	r0, r3
 2071 000a FFF7FEFF 		bl	PQD_GetAvrgElMotorPowerW
 2072 000e F0EE407A 		vmov.f32	s15, s0
 716:Src/mc_api.c  **** }
 2073              		.loc 1 716 1
 2074 0012 B0EE670A 		vmov.f32	s0, s15
 2075 0016 80BD     		pop	{r7, pc}
 2076              	.L176:
 2077              		.align	2
 2078              	.L175:
 2079 0018 00000000 		.word	pMPM
 2080              		.cfi_endproc
 2081              	.LFE1758:
 2083              		.section	.text.MC_ProfilerCommand,"ax",%progbits
 2084              		.align	1
 2085              		.weak	MC_ProfilerCommand
 2086              		.syntax unified
 2087              		.thumb
 2088              		.thumb_func
 2089              		.fpu fpv4-sp-d16
 2091              	MC_ProfilerCommand:
 2092              	.LFB1759:
 717:Src/mc_api.c  **** 
 718:Src/mc_api.c  **** /**
 719:Src/mc_api.c  ****  * @brief call the correct profiler command.
 720:Src/mc_api.c  ****  * Interface is generic MCPV2 interface :
 721:Src/mc_api.c  ****  * - rxLength : length of data send in the payload command
 722:Src/mc_api.c  ****  * - rxBuffer : pointer to the actual payload command
 723:Src/mc_api.c  ****  * - txSyncFreeSpace : Total amount of space available for the answer
 724:Src/mc_api.c  ****  * - txLength : Amount of space actually used for the answer - Set in the command itself
 725:Src/mc_api.c  ****  * - txBuffer : Pointer to the buffer containing the answer
 726:Src/mc_api.c  ****  * @retval returns MCP_CMD_OK or MCP_CMD_NOK if profiler is started correctly or not.
 727:Src/mc_api.c  ****  *  */
 728:Src/mc_api.c  **** __weak uint8_t MC_ProfilerCommand(uint16_t rxLength, uint8_t *rxBuffer, int16_t txSyncFreeSpace, ui
 729:Src/mc_api.c  **** {
 2093              		.loc 1 729 1
 2094              		.cfi_startproc
 2095              		@ args = 4, pretend = 0, frame = 16
 2096              		@ frame_needed = 1, uses_anonymous_args = 0
 2097 0000 80B5     		push	{r7, lr}
 2098              	.LCFI143:
 2099              		.cfi_def_cfa_offset 8
 2100              		.cfi_offset 7, -8
 2101              		.cfi_offset 14, -4
 2102 0002 86B0     		sub	sp, sp, #24
 2103              	.LCFI144:
ARM GAS  /tmp/ccw08S9Z.s 			page 49


 2104              		.cfi_def_cfa_offset 32
 2105 0004 02AF     		add	r7, sp, #8
 2106              	.LCFI145:
 2107              		.cfi_def_cfa 7, 24
 2108 0006 B960     		str	r1, [r7, #8]
 2109 0008 7B60     		str	r3, [r7, #4]
 2110 000a 0346     		mov	r3, r0	@ movhi
 2111 000c FB81     		strh	r3, [r7, #14]	@ movhi
 2112 000e 1346     		mov	r3, r2	@ movhi
 2113 0010 BB81     		strh	r3, [r7, #12]	@ movhi
 730:Src/mc_api.c  ****   return (SCC_CMD(&SCC, rxLength, rxBuffer, txSyncFreeSpace, txLength, txBuffer));
 2114              		.loc 1 730 11
 2115 0012 B7F90C20 		ldrsh	r2, [r7, #12]
 2116 0016 F989     		ldrh	r1, [r7, #14]
 2117 0018 BB69     		ldr	r3, [r7, #24]
 2118 001a 0193     		str	r3, [sp, #4]
 2119 001c 7B68     		ldr	r3, [r7, #4]
 2120 001e 0093     		str	r3, [sp]
 2121 0020 1346     		mov	r3, r2
 2122 0022 BA68     		ldr	r2, [r7, #8]
 2123 0024 0348     		ldr	r0, .L179
 2124 0026 FFF7FEFF 		bl	SCC_CMD
 2125 002a 0346     		mov	r3, r0
 731:Src/mc_api.c  **** }
 2126              		.loc 1 731 1
 2127 002c 1846     		mov	r0, r3
 2128 002e 1037     		adds	r7, r7, #16
 2129              	.LCFI146:
 2130              		.cfi_def_cfa_offset 8
 2131 0030 BD46     		mov	sp, r7
 2132              	.LCFI147:
 2133              		.cfi_def_cfa_register 13
 2134              		@ sp needed
 2135 0032 80BD     		pop	{r7, pc}
 2136              	.L180:
 2137              		.align	2
 2138              	.L179:
 2139 0034 00000000 		.word	SCC
 2140              		.cfi_endproc
 2141              	.LFE1759:
 2143              		.text
 2144              	.Letext0:
 2145              		.file 2 "/usr/share/gcc-arm-none-eabi-10-2020-q4-major/arm-none-eabi/include/machine/_default_type
 2146              		.file 3 "/usr/share/gcc-arm-none-eabi-10-2020-q4-major/arm-none-eabi/include/sys/_stdint.h"
 2147              		.file 4 "Drivers/CMSIS/Device/ST/STM32G4xx/Include/stm32g431xx.h"
 2148              		.file 5 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_tim.h"
 2149              		.file 6 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_usart.h"
 2150              		.file 7 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_dma.h"
 2151              		.file 8 "Inc/mc_type.h"
 2152              		.file 9 "Inc/pwm_curr_fdbk.h"
 2153              		.file 10 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/pid_regulator.h"
 2154              		.file 11 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h"
 2155              		.file 12 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h"
 2156              		.file 13 "Inc/mc_perf.h"
 2157              		.file 14 "Inc/mc_interface.h"
 2158              		.file 15 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/virtual_speed_sensor.h"
 2159              		.file 16 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/sto_speed_pos_fdbk.h"
ARM GAS  /tmp/ccw08S9Z.s 			page 50


 2160              		.file 17 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/revup_ctrl.h"
 2161              		.file 18 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/bus_voltage_sensor.h"
 2162              		.file 19 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/r_divider_bus_voltage_sensor.h"
 2163              		.file 20 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/sto_pll_speed_pos_fdbk.h"
 2164              		.file 21 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/ramp_ext_mngr.h"
 2165              		.file 22 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/mp_one_touch_tuning.h"
 2166              		.file 23 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/circle_limitation.h"
 2167              		.file 24 "Inc/hall_speed_pos_fdbk.h"
 2168              		.file 25 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/mp_hall_tuning.h"
 2169              		.file 26 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/mp_self_com_ctrl.h"
 2170              		.file 27 "MCSDK_v6.3.2-Full/MotorControl/MCSDK/MCLib/Any/Inc/pqd_motor_power_measurement.h"
 2171              		.file 28 "Inc/mc_config.h"
ARM GAS  /tmp/ccw08S9Z.s 			page 51


DEFINED SYMBOLS
                            *ABS*:0000000000000000 mc_api.c
     /tmp/ccw08S9Z.s:18     .rodata.OFFSET_TAB_CCMRx:0000000000000000 $d
     /tmp/ccw08S9Z.s:21     .rodata.OFFSET_TAB_CCMRx:0000000000000000 OFFSET_TAB_CCMRx
     /tmp/ccw08S9Z.s:24     .rodata.SHIFT_TAB_OCxx:0000000000000000 $d
     /tmp/ccw08S9Z.s:27     .rodata.SHIFT_TAB_OCxx:0000000000000000 SHIFT_TAB_OCxx
     /tmp/ccw08S9Z.s:30     .rodata.SHIFT_TAB_ICxx:0000000000000000 $d
     /tmp/ccw08S9Z.s:33     .rodata.SHIFT_TAB_ICxx:0000000000000000 SHIFT_TAB_ICxx
     /tmp/ccw08S9Z.s:36     .rodata.SHIFT_TAB_CCxP:0000000000000000 $d
     /tmp/ccw08S9Z.s:39     .rodata.SHIFT_TAB_CCxP:0000000000000000 SHIFT_TAB_CCxP
     /tmp/ccw08S9Z.s:42     .rodata.SHIFT_TAB_OISx:0000000000000000 $d
     /tmp/ccw08S9Z.s:45     .rodata.SHIFT_TAB_OISx:0000000000000000 SHIFT_TAB_OISx
     /tmp/ccw08S9Z.s:48     .rodata.USART_PRESCALER_TAB:0000000000000000 $d
     /tmp/ccw08S9Z.s:51     .rodata.USART_PRESCALER_TAB:0000000000000000 USART_PRESCALER_TAB
     /tmp/ccw08S9Z.s:65     .rodata.CHANNEL_OFFSET_TAB:0000000000000000 $d
     /tmp/ccw08S9Z.s:68     .rodata.CHANNEL_OFFSET_TAB:0000000000000000 CHANNEL_OFFSET_TAB
     /tmp/ccw08S9Z.s:71     .text.MC_StartMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:79     .text.MC_StartMotor1:0000000000000000 MC_StartMotor1
     /tmp/ccw08S9Z.s:106    .text.MC_StartMotor1:0000000000000014 $d
     /tmp/ccw08S9Z.s:111    .text.MC_StopMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:118    .text.MC_StopMotor1:0000000000000000 MC_StopMotor1
     /tmp/ccw08S9Z.s:144    .text.MC_StopMotor1:0000000000000014 $d
     /tmp/ccw08S9Z.s:149    .text.MC_ProgramSpeedRampMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:156    .text.MC_ProgramSpeedRampMotor1:0000000000000000 MC_ProgramSpeedRampMotor1
     /tmp/ccw08S9Z.s:198    .text.MC_ProgramSpeedRampMotor1:0000000000000028 $d
     /tmp/ccw08S9Z.s:203    .text.MC_ProgramSpeedRampMotor1_F:0000000000000000 $t
     /tmp/ccw08S9Z.s:210    .text.MC_ProgramSpeedRampMotor1_F:0000000000000000 MC_ProgramSpeedRampMotor1_F
     /tmp/ccw08S9Z.s:251    .text.MC_ProgramSpeedRampMotor1_F:0000000000000028 $d
     /tmp/ccw08S9Z.s:256    .text.MC_ProgramTorqueRampMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:263    .text.MC_ProgramTorqueRampMotor1:0000000000000000 MC_ProgramTorqueRampMotor1
     /tmp/ccw08S9Z.s:305    .text.MC_ProgramTorqueRampMotor1:0000000000000028 $d
     /tmp/ccw08S9Z.s:310    .text.MC_ProgramTorqueRampMotor1_F:0000000000000000 $t
     /tmp/ccw08S9Z.s:317    .text.MC_ProgramTorqueRampMotor1_F:0000000000000000 MC_ProgramTorqueRampMotor1_F
     /tmp/ccw08S9Z.s:358    .text.MC_ProgramTorqueRampMotor1_F:0000000000000028 $d
     /tmp/ccw08S9Z.s:363    .text.MC_SetCurrentReferenceMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:370    .text.MC_SetCurrentReferenceMotor1:0000000000000000 MC_SetCurrentReferenceMotor1
     /tmp/ccw08S9Z.s:407    .text.MC_SetCurrentReferenceMotor1:000000000000001c $d
     /tmp/ccw08S9Z.s:412    .text.MC_SetCurrentReferenceMotor1_F:0000000000000000 $t
     /tmp/ccw08S9Z.s:419    .text.MC_SetCurrentReferenceMotor1_F:0000000000000000 MC_SetCurrentReferenceMotor1_F
     /tmp/ccw08S9Z.s:462    .text.MC_SetCurrentReferenceMotor1_F:0000000000000038 $d
     /tmp/ccw08S9Z.s:467    .text.MC_GetCommandStateMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:474    .text.MC_GetCommandStateMotor1:0000000000000000 MC_GetCommandStateMotor1
     /tmp/ccw08S9Z.s:500    .text.MC_GetCommandStateMotor1:0000000000000014 $d
     /tmp/ccw08S9Z.s:505    .text.MC_StopSpeedRampMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:512    .text.MC_StopSpeedRampMotor1:0000000000000000 MC_StopSpeedRampMotor1
     /tmp/ccw08S9Z.s:538    .text.MC_StopSpeedRampMotor1:0000000000000014 $d
     /tmp/ccw08S9Z.s:543    .text.MC_StopRampMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:550    .text.MC_StopRampMotor1:0000000000000000 MC_StopRampMotor1
     /tmp/ccw08S9Z.s:575    .text.MC_StopRampMotor1:0000000000000014 $d
     /tmp/ccw08S9Z.s:580    .text.MC_HasRampCompletedMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:587    .text.MC_HasRampCompletedMotor1:0000000000000000 MC_HasRampCompletedMotor1
     /tmp/ccw08S9Z.s:613    .text.MC_HasRampCompletedMotor1:0000000000000014 $d
     /tmp/ccw08S9Z.s:618    .text.MC_GetMecSpeedReferenceMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:625    .text.MC_GetMecSpeedReferenceMotor1:0000000000000000 MC_GetMecSpeedReferenceMotor1
     /tmp/ccw08S9Z.s:651    .text.MC_GetMecSpeedReferenceMotor1:0000000000000014 $d
     /tmp/ccw08S9Z.s:656    .text.MC_GetMecSpeedReferenceMotor1_F:0000000000000000 $t
     /tmp/ccw08S9Z.s:663    .text.MC_GetMecSpeedReferenceMotor1_F:0000000000000000 MC_GetMecSpeedReferenceMotor1_F
ARM GAS  /tmp/ccw08S9Z.s 			page 52


     /tmp/ccw08S9Z.s:689    .text.MC_GetMecSpeedReferenceMotor1_F:0000000000000018 $d
     /tmp/ccw08S9Z.s:694    .text.MC_GetMecSpeedAverageMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:701    .text.MC_GetMecSpeedAverageMotor1:0000000000000000 MC_GetMecSpeedAverageMotor1
     /tmp/ccw08S9Z.s:727    .text.MC_GetMecSpeedAverageMotor1:0000000000000014 $d
     /tmp/ccw08S9Z.s:732    .text.MC_GetAverageMecSpeedMotor1_F:0000000000000000 $t
     /tmp/ccw08S9Z.s:739    .text.MC_GetAverageMecSpeedMotor1_F:0000000000000000 MC_GetAverageMecSpeedMotor1_F
     /tmp/ccw08S9Z.s:765    .text.MC_GetAverageMecSpeedMotor1_F:0000000000000018 $d
     /tmp/ccw08S9Z.s:770    .text.MC_GetLastRampFinalSpeedMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:777    .text.MC_GetLastRampFinalSpeedMotor1:0000000000000000 MC_GetLastRampFinalSpeedMotor1
     /tmp/ccw08S9Z.s:803    .text.MC_GetLastRampFinalSpeedMotor1:0000000000000014 $d
     /tmp/ccw08S9Z.s:808    .text.MC_GetLastRampFinalSpeedM1_F:0000000000000000 $t
     /tmp/ccw08S9Z.s:815    .text.MC_GetLastRampFinalSpeedM1_F:0000000000000000 MC_GetLastRampFinalSpeedM1_F
     /tmp/ccw08S9Z.s:841    .text.MC_GetLastRampFinalSpeedM1_F:0000000000000018 $d
     /tmp/ccw08S9Z.s:846    .text.MC_GetFinalTorqueReferenceMotor1_F:0000000000000000 $t
     /tmp/ccw08S9Z.s:853    .text.MC_GetFinalTorqueReferenceMotor1_F:0000000000000000 MC_GetFinalTorqueReferenceMotor1_F
     /tmp/ccw08S9Z.s:879    .text.MC_GetFinalTorqueReferenceMotor1_F:0000000000000018 $d
     /tmp/ccw08S9Z.s:884    .text.MC_GetFinalTorqueReferenceMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:891    .text.MC_GetFinalTorqueReferenceMotor1:0000000000000000 MC_GetFinalTorqueReferenceMotor1
     /tmp/ccw08S9Z.s:917    .text.MC_GetFinalTorqueReferenceMotor1:0000000000000014 $d
     /tmp/ccw08S9Z.s:922    .text.MC_GetControlModeMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:929    .text.MC_GetControlModeMotor1:0000000000000000 MC_GetControlModeMotor1
     /tmp/ccw08S9Z.s:955    .text.MC_GetControlModeMotor1:0000000000000014 $d
     /tmp/ccw08S9Z.s:960    .text.MC_GetImposedDirectionMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:967    .text.MC_GetImposedDirectionMotor1:0000000000000000 MC_GetImposedDirectionMotor1
     /tmp/ccw08S9Z.s:993    .text.MC_GetImposedDirectionMotor1:0000000000000014 $d
     /tmp/ccw08S9Z.s:998    .text.MC_GetSpeedSensorReliabilityMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:1005   .text.MC_GetSpeedSensorReliabilityMotor1:0000000000000000 MC_GetSpeedSensorReliabilityMotor1
     /tmp/ccw08S9Z.s:1031   .text.MC_GetSpeedSensorReliabilityMotor1:0000000000000014 $d
     /tmp/ccw08S9Z.s:1036   .text.MC_GetPhaseCurrentAmplitudeMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:1043   .text.MC_GetPhaseCurrentAmplitudeMotor1:0000000000000000 MC_GetPhaseCurrentAmplitudeMotor1
     /tmp/ccw08S9Z.s:1069   .text.MC_GetPhaseCurrentAmplitudeMotor1:0000000000000014 $d
     /tmp/ccw08S9Z.s:1074   .text.MC_GetPhaseVoltageAmplitudeMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:1081   .text.MC_GetPhaseVoltageAmplitudeMotor1:0000000000000000 MC_GetPhaseVoltageAmplitudeMotor1
     /tmp/ccw08S9Z.s:1107   .text.MC_GetPhaseVoltageAmplitudeMotor1:0000000000000014 $d
     /tmp/ccw08S9Z.s:1112   .text.MC_GetIabMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:1119   .text.MC_GetIabMotor1:0000000000000000 MC_GetIabMotor1
     /tmp/ccw08S9Z.s:1161   .text.MC_GetIabMotor1:000000000000002c $d
     /tmp/ccw08S9Z.s:1166   .text.MC_GetIabMotor1_F:0000000000000000 $t
     /tmp/ccw08S9Z.s:1173   .text.MC_GetIabMotor1_F:0000000000000000 MC_GetIabMotor1_F
     /tmp/ccw08S9Z.s:1217   .text.MC_GetIabMotor1_F:000000000000003c $d
     /tmp/ccw08S9Z.s:1222   .text.MC_GetIalphabetaMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:1229   .text.MC_GetIalphabetaMotor1:0000000000000000 MC_GetIalphabetaMotor1
     /tmp/ccw08S9Z.s:1271   .text.MC_GetIalphabetaMotor1:000000000000002c $d
     /tmp/ccw08S9Z.s:1276   .text.MC_GetIqdMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:1283   .text.MC_GetIqdMotor1:0000000000000000 MC_GetIqdMotor1
     /tmp/ccw08S9Z.s:1325   .text.MC_GetIqdMotor1:000000000000002c $d
     /tmp/ccw08S9Z.s:1330   .text.MC_GetIqdMotor1_F:0000000000000000 $t
     /tmp/ccw08S9Z.s:1337   .text.MC_GetIqdMotor1_F:0000000000000000 MC_GetIqdMotor1_F
     /tmp/ccw08S9Z.s:1381   .text.MC_GetIqdMotor1_F:000000000000003c $d
     /tmp/ccw08S9Z.s:1386   .text.MC_GetIqdrefMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:1393   .text.MC_GetIqdrefMotor1:0000000000000000 MC_GetIqdrefMotor1
     /tmp/ccw08S9Z.s:1435   .text.MC_GetIqdrefMotor1:000000000000002c $d
     /tmp/ccw08S9Z.s:1440   .text.MC_GetIqdrefMotor1_F:0000000000000000 $t
     /tmp/ccw08S9Z.s:1447   .text.MC_GetIqdrefMotor1_F:0000000000000000 MC_GetIqdrefMotor1_F
     /tmp/ccw08S9Z.s:1491   .text.MC_GetIqdrefMotor1_F:000000000000003c $d
     /tmp/ccw08S9Z.s:1496   .text.MC_GetVqdMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:1503   .text.MC_GetVqdMotor1:0000000000000000 MC_GetVqdMotor1
ARM GAS  /tmp/ccw08S9Z.s 			page 53


     /tmp/ccw08S9Z.s:1545   .text.MC_GetVqdMotor1:000000000000002c $d
     /tmp/ccw08S9Z.s:1550   .text.MC_GetValphabetaMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:1557   .text.MC_GetValphabetaMotor1:0000000000000000 MC_GetValphabetaMotor1
     /tmp/ccw08S9Z.s:1599   .text.MC_GetValphabetaMotor1:000000000000002c $d
     /tmp/ccw08S9Z.s:1604   .text.MC_GetElAngledppMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:1611   .text.MC_GetElAngledppMotor1:0000000000000000 MC_GetElAngledppMotor1
     /tmp/ccw08S9Z.s:1637   .text.MC_GetElAngledppMotor1:0000000000000014 $d
     /tmp/ccw08S9Z.s:1642   .text.MC_GetTerefMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:1649   .text.MC_GetTerefMotor1:0000000000000000 MC_GetTerefMotor1
     /tmp/ccw08S9Z.s:1675   .text.MC_GetTerefMotor1:0000000000000014 $d
     /tmp/ccw08S9Z.s:1680   .text.MC_GetTerefMotor1_F:0000000000000000 $t
     /tmp/ccw08S9Z.s:1687   .text.MC_GetTerefMotor1_F:0000000000000000 MC_GetTerefMotor1_F
     /tmp/ccw08S9Z.s:1713   .text.MC_GetTerefMotor1_F:0000000000000018 $d
     /tmp/ccw08S9Z.s:1718   .text.MC_Clear_IqdrefMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:1725   .text.MC_Clear_IqdrefMotor1:0000000000000000 MC_Clear_IqdrefMotor1
     /tmp/ccw08S9Z.s:1750   .text.MC_Clear_IqdrefMotor1:0000000000000014 $d
     /tmp/ccw08S9Z.s:1755   .text.MC_AcknowledgeFaultMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:1762   .text.MC_AcknowledgeFaultMotor1:0000000000000000 MC_AcknowledgeFaultMotor1
     /tmp/ccw08S9Z.s:1788   .text.MC_AcknowledgeFaultMotor1:0000000000000014 $d
     /tmp/ccw08S9Z.s:1793   .text.MC_GetOccurredFaultsMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:1800   .text.MC_GetOccurredFaultsMotor1:0000000000000000 MC_GetOccurredFaultsMotor1
     /tmp/ccw08S9Z.s:1826   .text.MC_GetOccurredFaultsMotor1:0000000000000014 $d
     /tmp/ccw08S9Z.s:1831   .text.MC_GetCurrentFaultsMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:1838   .text.MC_GetCurrentFaultsMotor1:0000000000000000 MC_GetCurrentFaultsMotor1
     /tmp/ccw08S9Z.s:1864   .text.MC_GetCurrentFaultsMotor1:0000000000000014 $d
     /tmp/ccw08S9Z.s:1869   .text.MC_GetSTMStateMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:1876   .text.MC_GetSTMStateMotor1:0000000000000000 MC_GetSTMStateMotor1
     /tmp/ccw08S9Z.s:1902   .text.MC_GetSTMStateMotor1:0000000000000014 $d
     /tmp/ccw08S9Z.s:1907   .text.MC_SetPolarizationOffsetsMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:1914   .text.MC_SetPolarizationOffsetsMotor1:0000000000000000 MC_SetPolarizationOffsetsMotor1
     /tmp/ccw08S9Z.s:1952   .text.MC_SetPolarizationOffsetsMotor1:0000000000000020 $d
     /tmp/ccw08S9Z.s:1957   .text.MC_GetPolarizationOffsetsMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:1964   .text.MC_GetPolarizationOffsetsMotor1:0000000000000000 MC_GetPolarizationOffsetsMotor1
     /tmp/ccw08S9Z.s:2002   .text.MC_GetPolarizationOffsetsMotor1:0000000000000020 $d
     /tmp/ccw08S9Z.s:2007   .text.MC_StartPolarizationOffsetsMeasurementMotor1:0000000000000000 $t
     /tmp/ccw08S9Z.s:2014   .text.MC_StartPolarizationOffsetsMeasurementMotor1:0000000000000000 MC_StartPolarizationOffsetsMeasurementMotor1
     /tmp/ccw08S9Z.s:2040   .text.MC_StartPolarizationOffsetsMeasurementMotor1:0000000000000014 $d
     /tmp/ccw08S9Z.s:2045   .text.MC_GetAveragePowerMotor1_F:0000000000000000 $t
     /tmp/ccw08S9Z.s:2052   .text.MC_GetAveragePowerMotor1_F:0000000000000000 MC_GetAveragePowerMotor1_F
     /tmp/ccw08S9Z.s:2079   .text.MC_GetAveragePowerMotor1_F:0000000000000018 $d
     /tmp/ccw08S9Z.s:2084   .text.MC_ProfilerCommand:0000000000000000 $t
     /tmp/ccw08S9Z.s:2091   .text.MC_ProfilerCommand:0000000000000000 MC_ProfilerCommand
     /tmp/ccw08S9Z.s:2139   .text.MC_ProfilerCommand:0000000000000034 $d

UNDEFINED SYMBOLS
MCI_StartMotor
pMCI
MCI_StopMotor
MCI_ExecSpeedRamp
MCI_ExecSpeedRamp_F
MCI_ExecTorqueRamp
MCI_ExecTorqueRamp_F
MCI_SetCurrentReferences
MCI_SetCurrentReferences_F
MCI_IsCommandAcknowledged
MCI_StopSpeedRamp
MCI_StopRamp
ARM GAS  /tmp/ccw08S9Z.s 			page 54


MCI_RampCompleted
MCI_GetMecSpeedRefUnit
MCI_GetMecSpeedRef_F
MCI_GetAvrgMecSpeedUnit
MCI_GetAvrgMecSpeed_F
MCI_GetLastRampFinalSpeed
MCI_GetLastRampFinalSpeed_F
MCI_GetLastRampFinalTorque_F
MCI_GetLastRampFinalTorque
MCI_GetControlMode
MCI_GetImposedMotorDirection
MCI_GetSpdSensorReliability
MCI_GetPhaseCurrentAmplitude
MCI_GetPhaseVoltageAmplitude
MCI_GetIab
MCI_GetIab_F
MCI_GetIalphabeta
MCI_GetIqd
MCI_GetIqd_F
MCI_GetIqdref
MCI_GetIqdref_F
MCI_GetVqd
MCI_GetValphabeta
MCI_GetElAngledpp
MCI_GetTeref
MCI_GetTeref_F
MCI_Clear_Iqdref
MCI_FaultAcknowledged
MCI_GetOccurredFaults
MCI_GetCurrentFaults
MCI_GetSTMState
MCI_SetCalibratedOffsetsMotor
MCI_GetCalibratedOffsetsMotor
MCI_StartOffsetMeasurments
PQD_GetAvrgElMotorPowerW
pMPM
SCC_CMD
SCC
